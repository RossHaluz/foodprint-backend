
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model HeroBillboards
 * 
 */
export type HeroBillboards = $Result.DefaultSelection<Prisma.$HeroBillboardsPayload>
/**
 * Model HeroBillboardsTranslation
 * 
 */
export type HeroBillboardsTranslation = $Result.DefaultSelection<Prisma.$HeroBillboardsTranslationPayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Billboard
 * 
 */
export type Billboard = $Result.DefaultSelection<Prisma.$BillboardPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model ProductCategory
 * 
 */
export type ProductCategory = $Result.DefaultSelection<Prisma.$ProductCategoryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductTranslation
 * 
 */
export type ProductTranslation = $Result.DefaultSelection<Prisma.$ProductTranslationPayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Characteristic
 * 
 */
export type Characteristic = $Result.DefaultSelection<Prisma.$CharacteristicPayload>
/**
 * Model CharacteristicTranslation
 * 
 */
export type CharacteristicTranslation = $Result.DefaultSelection<Prisma.$CharacteristicTranslationPayload>
/**
 * Model ProductCharacteristic
 * 
 */
export type ProductCharacteristic = $Result.DefaultSelection<Prisma.$ProductCharacteristicPayload>
/**
 * Model ProductCharacteristicTranslation
 * 
 */
export type ProductCharacteristicTranslation = $Result.DefaultSelection<Prisma.$ProductCharacteristicTranslationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ReviewPhoto
 * 
 */
export type ReviewPhoto = $Result.DefaultSelection<Prisma.$ReviewPhotoPayload>
/**
 * Model ReviewTranslation
 * 
 */
export type ReviewTranslation = $Result.DefaultSelection<Prisma.$ReviewTranslationPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model DeliveryInfo
 * 
 */
export type DeliveryInfo = $Result.DefaultSelection<Prisma.$DeliveryInfoPayload>
/**
 * Model DeliveryInfoTranslation
 * 
 */
export type DeliveryInfoTranslation = $Result.DefaultSelection<Prisma.$DeliveryInfoTranslationPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model PaymentMethodTranslation
 * 
 */
export type PaymentMethodTranslation = $Result.DefaultSelection<Prisma.$PaymentMethodTranslationPayload>
/**
 * Model FAQ
 * 
 */
export type FAQ = $Result.DefaultSelection<Prisma.$FAQPayload>
/**
 * Model FAQTranslation
 * 
 */
export type FAQTranslation = $Result.DefaultSelection<Prisma.$FAQTranslationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TypeCategory: {
  main: 'main',
  subcategory: 'subcategory'
};

export type TypeCategory = (typeof TypeCategory)[keyof typeof TypeCategory]


export const ProductType: {
  main: 'main',
  additional: 'additional'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const OrderTypes: {
  new: 'new',
  pending: 'pending',
  success: 'success',
  reject: 'reject'
};

export type OrderTypes = (typeof OrderTypes)[keyof typeof OrderTypes]

}

export type TypeCategory = $Enums.TypeCategory

export const TypeCategory: typeof $Enums.TypeCategory

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type OrderTypes = $Enums.OrderTypes

export const OrderTypes: typeof $Enums.OrderTypes

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more HeroBillboards
 * const heroBillboards = await prisma.heroBillboards.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more HeroBillboards
   * const heroBillboards = await prisma.heroBillboards.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.heroBillboards`: Exposes CRUD operations for the **HeroBillboards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeroBillboards
    * const heroBillboards = await prisma.heroBillboards.findMany()
    * ```
    */
  get heroBillboards(): Prisma.HeroBillboardsDelegate<ExtArgs>;

  /**
   * `prisma.heroBillboardsTranslation`: Exposes CRUD operations for the **HeroBillboardsTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeroBillboardsTranslations
    * const heroBillboardsTranslations = await prisma.heroBillboardsTranslation.findMany()
    * ```
    */
  get heroBillboardsTranslation(): Prisma.HeroBillboardsTranslationDelegate<ExtArgs>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs>;

  /**
   * `prisma.billboard`: Exposes CRUD operations for the **Billboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Billboards
    * const billboards = await prisma.billboard.findMany()
    * ```
    */
  get billboard(): Prisma.BillboardDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.productCategory`: Exposes CRUD operations for the **ProductCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCategories
    * const productCategories = await prisma.productCategory.findMany()
    * ```
    */
  get productCategory(): Prisma.ProductCategoryDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.productTranslation`: Exposes CRUD operations for the **ProductTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTranslations
    * const productTranslations = await prisma.productTranslation.findMany()
    * ```
    */
  get productTranslation(): Prisma.ProductTranslationDelegate<ExtArgs>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.characteristic`: Exposes CRUD operations for the **Characteristic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characteristics
    * const characteristics = await prisma.characteristic.findMany()
    * ```
    */
  get characteristic(): Prisma.CharacteristicDelegate<ExtArgs>;

  /**
   * `prisma.characteristicTranslation`: Exposes CRUD operations for the **CharacteristicTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacteristicTranslations
    * const characteristicTranslations = await prisma.characteristicTranslation.findMany()
    * ```
    */
  get characteristicTranslation(): Prisma.CharacteristicTranslationDelegate<ExtArgs>;

  /**
   * `prisma.productCharacteristic`: Exposes CRUD operations for the **ProductCharacteristic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCharacteristics
    * const productCharacteristics = await prisma.productCharacteristic.findMany()
    * ```
    */
  get productCharacteristic(): Prisma.ProductCharacteristicDelegate<ExtArgs>;

  /**
   * `prisma.productCharacteristicTranslation`: Exposes CRUD operations for the **ProductCharacteristicTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductCharacteristicTranslations
    * const productCharacteristicTranslations = await prisma.productCharacteristicTranslation.findMany()
    * ```
    */
  get productCharacteristicTranslation(): Prisma.ProductCharacteristicTranslationDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.reviewPhoto`: Exposes CRUD operations for the **ReviewPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewPhotos
    * const reviewPhotos = await prisma.reviewPhoto.findMany()
    * ```
    */
  get reviewPhoto(): Prisma.ReviewPhotoDelegate<ExtArgs>;

  /**
   * `prisma.reviewTranslation`: Exposes CRUD operations for the **ReviewTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewTranslations
    * const reviewTranslations = await prisma.reviewTranslation.findMany()
    * ```
    */
  get reviewTranslation(): Prisma.ReviewTranslationDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs>;

  /**
   * `prisma.deliveryInfo`: Exposes CRUD operations for the **DeliveryInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryInfos
    * const deliveryInfos = await prisma.deliveryInfo.findMany()
    * ```
    */
  get deliveryInfo(): Prisma.DeliveryInfoDelegate<ExtArgs>;

  /**
   * `prisma.deliveryInfoTranslation`: Exposes CRUD operations for the **DeliveryInfoTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryInfoTranslations
    * const deliveryInfoTranslations = await prisma.deliveryInfoTranslation.findMany()
    * ```
    */
  get deliveryInfoTranslation(): Prisma.DeliveryInfoTranslationDelegate<ExtArgs>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs>;

  /**
   * `prisma.paymentMethodTranslation`: Exposes CRUD operations for the **PaymentMethodTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethodTranslations
    * const paymentMethodTranslations = await prisma.paymentMethodTranslation.findMany()
    * ```
    */
  get paymentMethodTranslation(): Prisma.PaymentMethodTranslationDelegate<ExtArgs>;

  /**
   * `prisma.fAQ`: Exposes CRUD operations for the **FAQ** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQS
    * const fAQS = await prisma.fAQ.findMany()
    * ```
    */
  get fAQ(): Prisma.FAQDelegate<ExtArgs>;

  /**
   * `prisma.fAQTranslation`: Exposes CRUD operations for the **FAQTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FAQTranslations
    * const fAQTranslations = await prisma.fAQTranslation.findMany()
    * ```
    */
  get fAQTranslation(): Prisma.FAQTranslationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.1.0
   * Query Engine version: bf0e5e8a04cada8225617067eaa03d041e2bba36
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    HeroBillboards: 'HeroBillboards',
    HeroBillboardsTranslation: 'HeroBillboardsTranslation',
    Language: 'Language',
    Billboard: 'Billboard',
    Category: 'Category',
    ProductCategory: 'ProductCategory',
    Product: 'Product',
    ProductTranslation: 'ProductTranslation',
    Image: 'Image',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Characteristic: 'Characteristic',
    CharacteristicTranslation: 'CharacteristicTranslation',
    ProductCharacteristic: 'ProductCharacteristic',
    ProductCharacteristicTranslation: 'ProductCharacteristicTranslation',
    User: 'User',
    Review: 'Review',
    ReviewPhoto: 'ReviewPhoto',
    ReviewTranslation: 'ReviewTranslation',
    Feedback: 'Feedback',
    DeliveryInfo: 'DeliveryInfo',
    DeliveryInfoTranslation: 'DeliveryInfoTranslation',
    PaymentMethod: 'PaymentMethod',
    PaymentMethodTranslation: 'PaymentMethodTranslation',
    FAQ: 'FAQ',
    FAQTranslation: 'FAQTranslation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "heroBillboards" | "heroBillboardsTranslation" | "language" | "billboard" | "category" | "productCategory" | "product" | "productTranslation" | "image" | "order" | "orderItem" | "characteristic" | "characteristicTranslation" | "productCharacteristic" | "productCharacteristicTranslation" | "user" | "review" | "reviewPhoto" | "reviewTranslation" | "feedback" | "deliveryInfo" | "deliveryInfoTranslation" | "paymentMethod" | "paymentMethodTranslation" | "fAQ" | "fAQTranslation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      HeroBillboards: {
        payload: Prisma.$HeroBillboardsPayload<ExtArgs>
        fields: Prisma.HeroBillboardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeroBillboardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeroBillboardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload>
          }
          findFirst: {
            args: Prisma.HeroBillboardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeroBillboardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload>
          }
          findMany: {
            args: Prisma.HeroBillboardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload>[]
          }
          create: {
            args: Prisma.HeroBillboardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload>
          }
          createMany: {
            args: Prisma.HeroBillboardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HeroBillboardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload>[]
          }
          delete: {
            args: Prisma.HeroBillboardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload>
          }
          update: {
            args: Prisma.HeroBillboardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload>
          }
          deleteMany: {
            args: Prisma.HeroBillboardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeroBillboardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HeroBillboardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsPayload>
          }
          aggregate: {
            args: Prisma.HeroBillboardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeroBillboards>
          }
          groupBy: {
            args: Prisma.HeroBillboardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeroBillboardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.HeroBillboardsCountArgs<ExtArgs>
            result: $Utils.Optional<HeroBillboardsCountAggregateOutputType> | number
          }
        }
      }
      HeroBillboardsTranslation: {
        payload: Prisma.$HeroBillboardsTranslationPayload<ExtArgs>
        fields: Prisma.HeroBillboardsTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeroBillboardsTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeroBillboardsTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload>
          }
          findFirst: {
            args: Prisma.HeroBillboardsTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeroBillboardsTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload>
          }
          findMany: {
            args: Prisma.HeroBillboardsTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload>[]
          }
          create: {
            args: Prisma.HeroBillboardsTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload>
          }
          createMany: {
            args: Prisma.HeroBillboardsTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HeroBillboardsTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload>[]
          }
          delete: {
            args: Prisma.HeroBillboardsTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload>
          }
          update: {
            args: Prisma.HeroBillboardsTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload>
          }
          deleteMany: {
            args: Prisma.HeroBillboardsTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeroBillboardsTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HeroBillboardsTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBillboardsTranslationPayload>
          }
          aggregate: {
            args: Prisma.HeroBillboardsTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeroBillboardsTranslation>
          }
          groupBy: {
            args: Prisma.HeroBillboardsTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeroBillboardsTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.HeroBillboardsTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<HeroBillboardsTranslationCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Billboard: {
        payload: Prisma.$BillboardPayload<ExtArgs>
        fields: Prisma.BillboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload>
          }
          findFirst: {
            args: Prisma.BillboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload>
          }
          findMany: {
            args: Prisma.BillboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload>[]
          }
          create: {
            args: Prisma.BillboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload>
          }
          createMany: {
            args: Prisma.BillboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload>[]
          }
          delete: {
            args: Prisma.BillboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload>
          }
          update: {
            args: Prisma.BillboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload>
          }
          deleteMany: {
            args: Prisma.BillboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillboardPayload>
          }
          aggregate: {
            args: Prisma.BillboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBillboard>
          }
          groupBy: {
            args: Prisma.BillboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillboardCountArgs<ExtArgs>
            result: $Utils.Optional<BillboardCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      ProductCategory: {
        payload: Prisma.$ProductCategoryPayload<ExtArgs>
        fields: Prisma.ProductCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findFirst: {
            args: Prisma.ProductCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          findMany: {
            args: Prisma.ProductCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          create: {
            args: Prisma.ProductCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          createMany: {
            args: Prisma.ProductCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>[]
          }
          delete: {
            args: Prisma.ProductCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          update: {
            args: Prisma.ProductCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCategoryPayload>
          }
          aggregate: {
            args: Prisma.ProductCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCategory>
          }
          groupBy: {
            args: Prisma.ProductCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCategoryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductTranslation: {
        payload: Prisma.$ProductTranslationPayload<ExtArgs>
        fields: Prisma.ProductTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          findFirst: {
            args: Prisma.ProductTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          findMany: {
            args: Prisma.ProductTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
          }
          create: {
            args: Prisma.ProductTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          createMany: {
            args: Prisma.ProductTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>[]
          }
          delete: {
            args: Prisma.ProductTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          update: {
            args: Prisma.ProductTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ProductTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTranslationPayload>
          }
          aggregate: {
            args: Prisma.ProductTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductTranslation>
          }
          groupBy: {
            args: Prisma.ProductTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductTranslationCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Characteristic: {
        payload: Prisma.$CharacteristicPayload<ExtArgs>
        fields: Prisma.CharacteristicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacteristicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacteristicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          findFirst: {
            args: Prisma.CharacteristicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacteristicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          findMany: {
            args: Prisma.CharacteristicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>[]
          }
          create: {
            args: Prisma.CharacteristicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          createMany: {
            args: Prisma.CharacteristicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacteristicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>[]
          }
          delete: {
            args: Prisma.CharacteristicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          update: {
            args: Prisma.CharacteristicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          deleteMany: {
            args: Prisma.CharacteristicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacteristicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacteristicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicPayload>
          }
          aggregate: {
            args: Prisma.CharacteristicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacteristic>
          }
          groupBy: {
            args: Prisma.CharacteristicGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacteristicCountArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicCountAggregateOutputType> | number
          }
        }
      }
      CharacteristicTranslation: {
        payload: Prisma.$CharacteristicTranslationPayload<ExtArgs>
        fields: Prisma.CharacteristicTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacteristicTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacteristicTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload>
          }
          findFirst: {
            args: Prisma.CharacteristicTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacteristicTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload>
          }
          findMany: {
            args: Prisma.CharacteristicTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload>[]
          }
          create: {
            args: Prisma.CharacteristicTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload>
          }
          createMany: {
            args: Prisma.CharacteristicTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacteristicTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload>[]
          }
          delete: {
            args: Prisma.CharacteristicTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload>
          }
          update: {
            args: Prisma.CharacteristicTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload>
          }
          deleteMany: {
            args: Prisma.CharacteristicTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacteristicTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacteristicTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacteristicTranslationPayload>
          }
          aggregate: {
            args: Prisma.CharacteristicTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacteristicTranslation>
          }
          groupBy: {
            args: Prisma.CharacteristicTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacteristicTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<CharacteristicTranslationCountAggregateOutputType> | number
          }
        }
      }
      ProductCharacteristic: {
        payload: Prisma.$ProductCharacteristicPayload<ExtArgs>
        fields: Prisma.ProductCharacteristicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCharacteristicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCharacteristicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          findFirst: {
            args: Prisma.ProductCharacteristicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCharacteristicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          findMany: {
            args: Prisma.ProductCharacteristicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>[]
          }
          create: {
            args: Prisma.ProductCharacteristicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          createMany: {
            args: Prisma.ProductCharacteristicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCharacteristicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>[]
          }
          delete: {
            args: Prisma.ProductCharacteristicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          update: {
            args: Prisma.ProductCharacteristicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          deleteMany: {
            args: Prisma.ProductCharacteristicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCharacteristicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCharacteristicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicPayload>
          }
          aggregate: {
            args: Prisma.ProductCharacteristicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCharacteristic>
          }
          groupBy: {
            args: Prisma.ProductCharacteristicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCharacteristicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCharacteristicCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCharacteristicCountAggregateOutputType> | number
          }
        }
      }
      ProductCharacteristicTranslation: {
        payload: Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>
        fields: Prisma.ProductCharacteristicTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductCharacteristicTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductCharacteristicTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload>
          }
          findFirst: {
            args: Prisma.ProductCharacteristicTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductCharacteristicTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload>
          }
          findMany: {
            args: Prisma.ProductCharacteristicTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload>[]
          }
          create: {
            args: Prisma.ProductCharacteristicTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload>
          }
          createMany: {
            args: Prisma.ProductCharacteristicTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCharacteristicTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload>[]
          }
          delete: {
            args: Prisma.ProductCharacteristicTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload>
          }
          update: {
            args: Prisma.ProductCharacteristicTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ProductCharacteristicTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductCharacteristicTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductCharacteristicTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductCharacteristicTranslationPayload>
          }
          aggregate: {
            args: Prisma.ProductCharacteristicTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductCharacteristicTranslation>
          }
          groupBy: {
            args: Prisma.ProductCharacteristicTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductCharacteristicTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCharacteristicTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCharacteristicTranslationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ReviewPhoto: {
        payload: Prisma.$ReviewPhotoPayload<ExtArgs>
        fields: Prisma.ReviewPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload>
          }
          findFirst: {
            args: Prisma.ReviewPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload>
          }
          findMany: {
            args: Prisma.ReviewPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload>[]
          }
          create: {
            args: Prisma.ReviewPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload>
          }
          createMany: {
            args: Prisma.ReviewPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload>[]
          }
          delete: {
            args: Prisma.ReviewPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload>
          }
          update: {
            args: Prisma.ReviewPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload>
          }
          deleteMany: {
            args: Prisma.ReviewPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPhotoPayload>
          }
          aggregate: {
            args: Prisma.ReviewPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewPhoto>
          }
          groupBy: {
            args: Prisma.ReviewPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewPhotoCountAggregateOutputType> | number
          }
        }
      }
      ReviewTranslation: {
        payload: Prisma.$ReviewTranslationPayload<ExtArgs>
        fields: Prisma.ReviewTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload>
          }
          findFirst: {
            args: Prisma.ReviewTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload>
          }
          findMany: {
            args: Prisma.ReviewTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload>[]
          }
          create: {
            args: Prisma.ReviewTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload>
          }
          createMany: {
            args: Prisma.ReviewTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload>[]
          }
          delete: {
            args: Prisma.ReviewTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload>
          }
          update: {
            args: Prisma.ReviewTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload>
          }
          deleteMany: {
            args: Prisma.ReviewTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewTranslationPayload>
          }
          aggregate: {
            args: Prisma.ReviewTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewTranslation>
          }
          groupBy: {
            args: Prisma.ReviewTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewTranslationCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      DeliveryInfo: {
        payload: Prisma.$DeliveryInfoPayload<ExtArgs>
        fields: Prisma.DeliveryInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload>
          }
          findFirst: {
            args: Prisma.DeliveryInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload>
          }
          findMany: {
            args: Prisma.DeliveryInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload>[]
          }
          create: {
            args: Prisma.DeliveryInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload>
          }
          createMany: {
            args: Prisma.DeliveryInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload>[]
          }
          delete: {
            args: Prisma.DeliveryInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload>
          }
          update: {
            args: Prisma.DeliveryInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoPayload>
          }
          aggregate: {
            args: Prisma.DeliveryInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryInfo>
          }
          groupBy: {
            args: Prisma.DeliveryInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryInfoCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryInfoCountAggregateOutputType> | number
          }
        }
      }
      DeliveryInfoTranslation: {
        payload: Prisma.$DeliveryInfoTranslationPayload<ExtArgs>
        fields: Prisma.DeliveryInfoTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryInfoTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryInfoTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload>
          }
          findFirst: {
            args: Prisma.DeliveryInfoTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryInfoTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload>
          }
          findMany: {
            args: Prisma.DeliveryInfoTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload>[]
          }
          create: {
            args: Prisma.DeliveryInfoTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload>
          }
          createMany: {
            args: Prisma.DeliveryInfoTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryInfoTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload>[]
          }
          delete: {
            args: Prisma.DeliveryInfoTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload>
          }
          update: {
            args: Prisma.DeliveryInfoTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryInfoTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryInfoTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryInfoTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryInfoTranslationPayload>
          }
          aggregate: {
            args: Prisma.DeliveryInfoTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryInfoTranslation>
          }
          groupBy: {
            args: Prisma.DeliveryInfoTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryInfoTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryInfoTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryInfoTranslationCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethodTranslation: {
        payload: Prisma.$PaymentMethodTranslationPayload<ExtArgs>
        fields: Prisma.PaymentMethodTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentMethodTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload>[]
          }
          delete: {
            args: Prisma.PaymentMethodTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload>
          }
          update: {
            args: Prisma.PaymentMethodTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodTranslationPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethodTranslation>
          }
          groupBy: {
            args: Prisma.PaymentMethodTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentMethodTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodTranslationCountAggregateOutputType> | number
          }
        }
      }
      FAQ: {
        payload: Prisma.$FAQPayload<ExtArgs>
        fields: Prisma.FAQFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findFirst: {
            args: Prisma.FAQFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          findMany: {
            args: Prisma.FAQFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          create: {
            args: Prisma.FAQCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          createMany: {
            args: Prisma.FAQCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>[]
          }
          delete: {
            args: Prisma.FAQDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          update: {
            args: Prisma.FAQUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          deleteMany: {
            args: Prisma.FAQDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FAQUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQPayload>
          }
          aggregate: {
            args: Prisma.FAQAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQ>
          }
          groupBy: {
            args: Prisma.FAQGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQCountArgs<ExtArgs>
            result: $Utils.Optional<FAQCountAggregateOutputType> | number
          }
        }
      }
      FAQTranslation: {
        payload: Prisma.$FAQTranslationPayload<ExtArgs>
        fields: Prisma.FAQTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FAQTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FAQTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload>
          }
          findFirst: {
            args: Prisma.FAQTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FAQTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload>
          }
          findMany: {
            args: Prisma.FAQTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload>[]
          }
          create: {
            args: Prisma.FAQTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload>
          }
          createMany: {
            args: Prisma.FAQTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FAQTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload>[]
          }
          delete: {
            args: Prisma.FAQTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload>
          }
          update: {
            args: Prisma.FAQTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload>
          }
          deleteMany: {
            args: Prisma.FAQTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FAQTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FAQTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FAQTranslationPayload>
          }
          aggregate: {
            args: Prisma.FAQTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFAQTranslation>
          }
          groupBy: {
            args: Prisma.FAQTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FAQTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FAQTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<FAQTranslationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type HeroBillboardsCountOutputType
   */

  export type HeroBillboardsCountOutputType = {
    translations: number
  }

  export type HeroBillboardsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | HeroBillboardsCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * HeroBillboardsCountOutputType without action
   */
  export type HeroBillboardsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsCountOutputType
     */
    select?: HeroBillboardsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HeroBillboardsCountOutputType without action
   */
  export type HeroBillboardsCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroBillboardsTranslationWhereInput
  }


  /**
   * Count Type BillboardCountOutputType
   */

  export type BillboardCountOutputType = {
    categories: number
  }

  export type BillboardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | BillboardCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * BillboardCountOutputType without action
   */
  export type BillboardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillboardCountOutputType
     */
    select?: BillboardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BillboardCountOutputType without action
   */
  export type BillboardCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
    children: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    categories: number
    images: number
    orderItems: number
    productCharacteristics: number
    translations: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | ProductCountOutputTypeCountCategoriesArgs
    images?: boolean | ProductCountOutputTypeCountImagesArgs
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    productCharacteristics?: boolean | ProductCountOutputTypeCountProductCharacteristicsArgs
    translations?: boolean | ProductCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountProductCharacteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCharacteristicWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    orderItems: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type CharacteristicCountOutputType
   */

  export type CharacteristicCountOutputType = {
    productCharacteristics: number
    translations: number
  }

  export type CharacteristicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productCharacteristics?: boolean | CharacteristicCountOutputTypeCountProductCharacteristicsArgs
    translations?: boolean | CharacteristicCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * CharacteristicCountOutputType without action
   */
  export type CharacteristicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicCountOutputType
     */
    select?: CharacteristicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacteristicCountOutputType without action
   */
  export type CharacteristicCountOutputTypeCountProductCharacteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCharacteristicWhereInput
  }

  /**
   * CharacteristicCountOutputType without action
   */
  export type CharacteristicCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicTranslationWhereInput
  }


  /**
   * Count Type ProductCharacteristicCountOutputType
   */

  export type ProductCharacteristicCountOutputType = {
    translations: number
  }

  export type ProductCharacteristicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | ProductCharacteristicCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * ProductCharacteristicCountOutputType without action
   */
  export type ProductCharacteristicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicCountOutputType
     */
    select?: ProductCharacteristicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCharacteristicCountOutputType without action
   */
  export type ProductCharacteristicCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCharacteristicTranslationWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type ReviewCountOutputType
   */

  export type ReviewCountOutputType = {
    photo: number
    translation: number
  }

  export type ReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photo?: boolean | ReviewCountOutputTypeCountPhotoArgs
    translation?: boolean | ReviewCountOutputTypeCountTranslationArgs
  }

  // Custom InputTypes
  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     */
    select?: ReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountPhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewPhotoWhereInput
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewTranslationWhereInput
  }


  /**
   * Count Type DeliveryInfoCountOutputType
   */

  export type DeliveryInfoCountOutputType = {
    translation: number
  }

  export type DeliveryInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | DeliveryInfoCountOutputTypeCountTranslationArgs
  }

  // Custom InputTypes
  /**
   * DeliveryInfoCountOutputType without action
   */
  export type DeliveryInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoCountOutputType
     */
    select?: DeliveryInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryInfoCountOutputType without action
   */
  export type DeliveryInfoCountOutputTypeCountTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryInfoTranslationWhereInput
  }


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    translation: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | PaymentMethodCountOutputTypeCountTranslationArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodTranslationWhereInput
  }


  /**
   * Count Type FAQCountOutputType
   */

  export type FAQCountOutputType = {
    translations: number
  }

  export type FAQCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | FAQCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * FAQCountOutputType without action
   */
  export type FAQCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQCountOutputType
     */
    select?: FAQCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FAQCountOutputType without action
   */
  export type FAQCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQTranslationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model HeroBillboards
   */

  export type AggregateHeroBillboards = {
    _count: HeroBillboardsCountAggregateOutputType | null
    _min: HeroBillboardsMinAggregateOutputType | null
    _max: HeroBillboardsMaxAggregateOutputType | null
  }

  export type HeroBillboardsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    image: string | null
    title: string | null
    subtitle: string | null
    url: string | null
  }

  export type HeroBillboardsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    image: string | null
    title: string | null
    subtitle: string | null
    url: string | null
  }

  export type HeroBillboardsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    image: number
    title: number
    subtitle: number
    url: number
    _all: number
  }


  export type HeroBillboardsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    image?: true
    title?: true
    subtitle?: true
    url?: true
  }

  export type HeroBillboardsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    image?: true
    title?: true
    subtitle?: true
    url?: true
  }

  export type HeroBillboardsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    image?: true
    title?: true
    subtitle?: true
    url?: true
    _all?: true
  }

  export type HeroBillboardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroBillboards to aggregate.
     */
    where?: HeroBillboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBillboards to fetch.
     */
    orderBy?: HeroBillboardsOrderByWithRelationInput | HeroBillboardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeroBillboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBillboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBillboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeroBillboards
    **/
    _count?: true | HeroBillboardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeroBillboardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeroBillboardsMaxAggregateInputType
  }

  export type GetHeroBillboardsAggregateType<T extends HeroBillboardsAggregateArgs> = {
        [P in keyof T & keyof AggregateHeroBillboards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroBillboards[P]>
      : GetScalarType<T[P], AggregateHeroBillboards[P]>
  }




  export type HeroBillboardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroBillboardsWhereInput
    orderBy?: HeroBillboardsOrderByWithAggregationInput | HeroBillboardsOrderByWithAggregationInput[]
    by: HeroBillboardsScalarFieldEnum[] | HeroBillboardsScalarFieldEnum
    having?: HeroBillboardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeroBillboardsCountAggregateInputType | true
    _min?: HeroBillboardsMinAggregateInputType
    _max?: HeroBillboardsMaxAggregateInputType
  }

  export type HeroBillboardsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    image: string
    title: string
    subtitle: string
    url: string
    _count: HeroBillboardsCountAggregateOutputType | null
    _min: HeroBillboardsMinAggregateOutputType | null
    _max: HeroBillboardsMaxAggregateOutputType | null
  }

  type GetHeroBillboardsGroupByPayload<T extends HeroBillboardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeroBillboardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeroBillboardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroBillboardsGroupByOutputType[P]>
            : GetScalarType<T[P], HeroBillboardsGroupByOutputType[P]>
        }
      >
    >


  export type HeroBillboardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    url?: boolean
    translations?: boolean | HeroBillboards$translationsArgs<ExtArgs>
    _count?: boolean | HeroBillboardsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["heroBillboards"]>

  export type HeroBillboardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    url?: boolean
  }, ExtArgs["result"]["heroBillboards"]>

  export type HeroBillboardsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    image?: boolean
    title?: boolean
    subtitle?: boolean
    url?: boolean
  }

  export type HeroBillboardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | HeroBillboards$translationsArgs<ExtArgs>
    _count?: boolean | HeroBillboardsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HeroBillboardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HeroBillboardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeroBillboards"
    objects: {
      translations: Prisma.$HeroBillboardsTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      image: string
      title: string
      subtitle: string
      url: string
    }, ExtArgs["result"]["heroBillboards"]>
    composites: {}
  }

  type HeroBillboardsGetPayload<S extends boolean | null | undefined | HeroBillboardsDefaultArgs> = $Result.GetResult<Prisma.$HeroBillboardsPayload, S>

  type HeroBillboardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HeroBillboardsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HeroBillboardsCountAggregateInputType | true
    }

  export interface HeroBillboardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeroBillboards'], meta: { name: 'HeroBillboards' } }
    /**
     * Find zero or one HeroBillboards that matches the filter.
     * @param {HeroBillboardsFindUniqueArgs} args - Arguments to find a HeroBillboards
     * @example
     * // Get one HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroBillboardsFindUniqueArgs>(args: SelectSubset<T, HeroBillboardsFindUniqueArgs<ExtArgs>>): Prisma__HeroBillboardsClient<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HeroBillboards that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HeroBillboardsFindUniqueOrThrowArgs} args - Arguments to find a HeroBillboards
     * @example
     * // Get one HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroBillboardsFindUniqueOrThrowArgs>(args: SelectSubset<T, HeroBillboardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeroBillboardsClient<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HeroBillboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsFindFirstArgs} args - Arguments to find a HeroBillboards
     * @example
     * // Get one HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroBillboardsFindFirstArgs>(args?: SelectSubset<T, HeroBillboardsFindFirstArgs<ExtArgs>>): Prisma__HeroBillboardsClient<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HeroBillboards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsFindFirstOrThrowArgs} args - Arguments to find a HeroBillboards
     * @example
     * // Get one HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroBillboardsFindFirstOrThrowArgs>(args?: SelectSubset<T, HeroBillboardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeroBillboardsClient<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HeroBillboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.findMany()
     * 
     * // Get first 10 HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heroBillboardsWithIdOnly = await prisma.heroBillboards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeroBillboardsFindManyArgs>(args?: SelectSubset<T, HeroBillboardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HeroBillboards.
     * @param {HeroBillboardsCreateArgs} args - Arguments to create a HeroBillboards.
     * @example
     * // Create one HeroBillboards
     * const HeroBillboards = await prisma.heroBillboards.create({
     *   data: {
     *     // ... data to create a HeroBillboards
     *   }
     * })
     * 
     */
    create<T extends HeroBillboardsCreateArgs>(args: SelectSubset<T, HeroBillboardsCreateArgs<ExtArgs>>): Prisma__HeroBillboardsClient<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HeroBillboards.
     * @param {HeroBillboardsCreateManyArgs} args - Arguments to create many HeroBillboards.
     * @example
     * // Create many HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeroBillboardsCreateManyArgs>(args?: SelectSubset<T, HeroBillboardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HeroBillboards and returns the data saved in the database.
     * @param {HeroBillboardsCreateManyAndReturnArgs} args - Arguments to create many HeroBillboards.
     * @example
     * // Create many HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HeroBillboards and only return the `id`
     * const heroBillboardsWithIdOnly = await prisma.heroBillboards.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HeroBillboardsCreateManyAndReturnArgs>(args?: SelectSubset<T, HeroBillboardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HeroBillboards.
     * @param {HeroBillboardsDeleteArgs} args - Arguments to delete one HeroBillboards.
     * @example
     * // Delete one HeroBillboards
     * const HeroBillboards = await prisma.heroBillboards.delete({
     *   where: {
     *     // ... filter to delete one HeroBillboards
     *   }
     * })
     * 
     */
    delete<T extends HeroBillboardsDeleteArgs>(args: SelectSubset<T, HeroBillboardsDeleteArgs<ExtArgs>>): Prisma__HeroBillboardsClient<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HeroBillboards.
     * @param {HeroBillboardsUpdateArgs} args - Arguments to update one HeroBillboards.
     * @example
     * // Update one HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeroBillboardsUpdateArgs>(args: SelectSubset<T, HeroBillboardsUpdateArgs<ExtArgs>>): Prisma__HeroBillboardsClient<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HeroBillboards.
     * @param {HeroBillboardsDeleteManyArgs} args - Arguments to filter HeroBillboards to delete.
     * @example
     * // Delete a few HeroBillboards
     * const { count } = await prisma.heroBillboards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeroBillboardsDeleteManyArgs>(args?: SelectSubset<T, HeroBillboardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroBillboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeroBillboardsUpdateManyArgs>(args: SelectSubset<T, HeroBillboardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HeroBillboards.
     * @param {HeroBillboardsUpsertArgs} args - Arguments to update or create a HeroBillboards.
     * @example
     * // Update or create a HeroBillboards
     * const heroBillboards = await prisma.heroBillboards.upsert({
     *   create: {
     *     // ... data to create a HeroBillboards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroBillboards we want to update
     *   }
     * })
     */
    upsert<T extends HeroBillboardsUpsertArgs>(args: SelectSubset<T, HeroBillboardsUpsertArgs<ExtArgs>>): Prisma__HeroBillboardsClient<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HeroBillboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsCountArgs} args - Arguments to filter HeroBillboards to count.
     * @example
     * // Count the number of HeroBillboards
     * const count = await prisma.heroBillboards.count({
     *   where: {
     *     // ... the filter for the HeroBillboards we want to count
     *   }
     * })
    **/
    count<T extends HeroBillboardsCountArgs>(
      args?: Subset<T, HeroBillboardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeroBillboardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeroBillboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeroBillboardsAggregateArgs>(args: Subset<T, HeroBillboardsAggregateArgs>): Prisma.PrismaPromise<GetHeroBillboardsAggregateType<T>>

    /**
     * Group by HeroBillboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeroBillboardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroBillboardsGroupByArgs['orderBy'] }
        : { orderBy?: HeroBillboardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeroBillboardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeroBillboardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeroBillboards model
   */
  readonly fields: HeroBillboardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroBillboards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroBillboardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends HeroBillboards$translationsArgs<ExtArgs> = {}>(args?: Subset<T, HeroBillboards$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeroBillboards model
   */ 
  interface HeroBillboardsFieldRefs {
    readonly id: FieldRef<"HeroBillboards", 'String'>
    readonly createdAt: FieldRef<"HeroBillboards", 'DateTime'>
    readonly updatedAt: FieldRef<"HeroBillboards", 'DateTime'>
    readonly image: FieldRef<"HeroBillboards", 'String'>
    readonly title: FieldRef<"HeroBillboards", 'String'>
    readonly subtitle: FieldRef<"HeroBillboards", 'String'>
    readonly url: FieldRef<"HeroBillboards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HeroBillboards findUnique
   */
  export type HeroBillboardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboards to fetch.
     */
    where: HeroBillboardsWhereUniqueInput
  }

  /**
   * HeroBillboards findUniqueOrThrow
   */
  export type HeroBillboardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboards to fetch.
     */
    where: HeroBillboardsWhereUniqueInput
  }

  /**
   * HeroBillboards findFirst
   */
  export type HeroBillboardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboards to fetch.
     */
    where?: HeroBillboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBillboards to fetch.
     */
    orderBy?: HeroBillboardsOrderByWithRelationInput | HeroBillboardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroBillboards.
     */
    cursor?: HeroBillboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBillboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBillboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroBillboards.
     */
    distinct?: HeroBillboardsScalarFieldEnum | HeroBillboardsScalarFieldEnum[]
  }

  /**
   * HeroBillboards findFirstOrThrow
   */
  export type HeroBillboardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboards to fetch.
     */
    where?: HeroBillboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBillboards to fetch.
     */
    orderBy?: HeroBillboardsOrderByWithRelationInput | HeroBillboardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroBillboards.
     */
    cursor?: HeroBillboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBillboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBillboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroBillboards.
     */
    distinct?: HeroBillboardsScalarFieldEnum | HeroBillboardsScalarFieldEnum[]
  }

  /**
   * HeroBillboards findMany
   */
  export type HeroBillboardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboards to fetch.
     */
    where?: HeroBillboardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBillboards to fetch.
     */
    orderBy?: HeroBillboardsOrderByWithRelationInput | HeroBillboardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeroBillboards.
     */
    cursor?: HeroBillboardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBillboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBillboards.
     */
    skip?: number
    distinct?: HeroBillboardsScalarFieldEnum | HeroBillboardsScalarFieldEnum[]
  }

  /**
   * HeroBillboards create
   */
  export type HeroBillboardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
    /**
     * The data needed to create a HeroBillboards.
     */
    data: XOR<HeroBillboardsCreateInput, HeroBillboardsUncheckedCreateInput>
  }

  /**
   * HeroBillboards createMany
   */
  export type HeroBillboardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeroBillboards.
     */
    data: HeroBillboardsCreateManyInput | HeroBillboardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroBillboards createManyAndReturn
   */
  export type HeroBillboardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HeroBillboards.
     */
    data: HeroBillboardsCreateManyInput | HeroBillboardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroBillboards update
   */
  export type HeroBillboardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
    /**
     * The data needed to update a HeroBillboards.
     */
    data: XOR<HeroBillboardsUpdateInput, HeroBillboardsUncheckedUpdateInput>
    /**
     * Choose, which HeroBillboards to update.
     */
    where: HeroBillboardsWhereUniqueInput
  }

  /**
   * HeroBillboards updateMany
   */
  export type HeroBillboardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeroBillboards.
     */
    data: XOR<HeroBillboardsUpdateManyMutationInput, HeroBillboardsUncheckedUpdateManyInput>
    /**
     * Filter which HeroBillboards to update
     */
    where?: HeroBillboardsWhereInput
  }

  /**
   * HeroBillboards upsert
   */
  export type HeroBillboardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
    /**
     * The filter to search for the HeroBillboards to update in case it exists.
     */
    where: HeroBillboardsWhereUniqueInput
    /**
     * In case the HeroBillboards found by the `where` argument doesn't exist, create a new HeroBillboards with this data.
     */
    create: XOR<HeroBillboardsCreateInput, HeroBillboardsUncheckedCreateInput>
    /**
     * In case the HeroBillboards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroBillboardsUpdateInput, HeroBillboardsUncheckedUpdateInput>
  }

  /**
   * HeroBillboards delete
   */
  export type HeroBillboardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
    /**
     * Filter which HeroBillboards to delete.
     */
    where: HeroBillboardsWhereUniqueInput
  }

  /**
   * HeroBillboards deleteMany
   */
  export type HeroBillboardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroBillboards to delete
     */
    where?: HeroBillboardsWhereInput
  }

  /**
   * HeroBillboards.translations
   */
  export type HeroBillboards$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    where?: HeroBillboardsTranslationWhereInput
    orderBy?: HeroBillboardsTranslationOrderByWithRelationInput | HeroBillboardsTranslationOrderByWithRelationInput[]
    cursor?: HeroBillboardsTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HeroBillboardsTranslationScalarFieldEnum | HeroBillboardsTranslationScalarFieldEnum[]
  }

  /**
   * HeroBillboards without action
   */
  export type HeroBillboardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboards
     */
    select?: HeroBillboardsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsInclude<ExtArgs> | null
  }


  /**
   * Model HeroBillboardsTranslation
   */

  export type AggregateHeroBillboardsTranslation = {
    _count: HeroBillboardsTranslationCountAggregateOutputType | null
    _min: HeroBillboardsTranslationMinAggregateOutputType | null
    _max: HeroBillboardsTranslationMaxAggregateOutputType | null
  }

  export type HeroBillboardsTranslationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    langCode: string | null
    subtitle: string | null
    heroBillboardId: string | null
  }

  export type HeroBillboardsTranslationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    langCode: string | null
    subtitle: string | null
    heroBillboardId: string | null
  }

  export type HeroBillboardsTranslationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    title: number
    langCode: number
    subtitle: number
    heroBillboardId: number
    _all: number
  }


  export type HeroBillboardsTranslationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    langCode?: true
    subtitle?: true
    heroBillboardId?: true
  }

  export type HeroBillboardsTranslationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    langCode?: true
    subtitle?: true
    heroBillboardId?: true
  }

  export type HeroBillboardsTranslationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    langCode?: true
    subtitle?: true
    heroBillboardId?: true
    _all?: true
  }

  export type HeroBillboardsTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroBillboardsTranslation to aggregate.
     */
    where?: HeroBillboardsTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBillboardsTranslations to fetch.
     */
    orderBy?: HeroBillboardsTranslationOrderByWithRelationInput | HeroBillboardsTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeroBillboardsTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBillboardsTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBillboardsTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeroBillboardsTranslations
    **/
    _count?: true | HeroBillboardsTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeroBillboardsTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeroBillboardsTranslationMaxAggregateInputType
  }

  export type GetHeroBillboardsTranslationAggregateType<T extends HeroBillboardsTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateHeroBillboardsTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroBillboardsTranslation[P]>
      : GetScalarType<T[P], AggregateHeroBillboardsTranslation[P]>
  }




  export type HeroBillboardsTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroBillboardsTranslationWhereInput
    orderBy?: HeroBillboardsTranslationOrderByWithAggregationInput | HeroBillboardsTranslationOrderByWithAggregationInput[]
    by: HeroBillboardsTranslationScalarFieldEnum[] | HeroBillboardsTranslationScalarFieldEnum
    having?: HeroBillboardsTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeroBillboardsTranslationCountAggregateInputType | true
    _min?: HeroBillboardsTranslationMinAggregateInputType
    _max?: HeroBillboardsTranslationMaxAggregateInputType
  }

  export type HeroBillboardsTranslationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    title: string
    langCode: string
    subtitle: string
    heroBillboardId: string
    _count: HeroBillboardsTranslationCountAggregateOutputType | null
    _min: HeroBillboardsTranslationMinAggregateOutputType | null
    _max: HeroBillboardsTranslationMaxAggregateOutputType | null
  }

  type GetHeroBillboardsTranslationGroupByPayload<T extends HeroBillboardsTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeroBillboardsTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeroBillboardsTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroBillboardsTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], HeroBillboardsTranslationGroupByOutputType[P]>
        }
      >
    >


  export type HeroBillboardsTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    langCode?: boolean
    subtitle?: boolean
    heroBillboardId?: boolean
    heroBillboard?: boolean | HeroBillboardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["heroBillboardsTranslation"]>

  export type HeroBillboardsTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    langCode?: boolean
    subtitle?: boolean
    heroBillboardId?: boolean
    heroBillboard?: boolean | HeroBillboardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["heroBillboardsTranslation"]>

  export type HeroBillboardsTranslationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    langCode?: boolean
    subtitle?: boolean
    heroBillboardId?: boolean
  }

  export type HeroBillboardsTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    heroBillboard?: boolean | HeroBillboardsDefaultArgs<ExtArgs>
  }
  export type HeroBillboardsTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    heroBillboard?: boolean | HeroBillboardsDefaultArgs<ExtArgs>
  }

  export type $HeroBillboardsTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeroBillboardsTranslation"
    objects: {
      heroBillboard: Prisma.$HeroBillboardsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      title: string
      langCode: string
      subtitle: string
      heroBillboardId: string
    }, ExtArgs["result"]["heroBillboardsTranslation"]>
    composites: {}
  }

  type HeroBillboardsTranslationGetPayload<S extends boolean | null | undefined | HeroBillboardsTranslationDefaultArgs> = $Result.GetResult<Prisma.$HeroBillboardsTranslationPayload, S>

  type HeroBillboardsTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HeroBillboardsTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HeroBillboardsTranslationCountAggregateInputType | true
    }

  export interface HeroBillboardsTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeroBillboardsTranslation'], meta: { name: 'HeroBillboardsTranslation' } }
    /**
     * Find zero or one HeroBillboardsTranslation that matches the filter.
     * @param {HeroBillboardsTranslationFindUniqueArgs} args - Arguments to find a HeroBillboardsTranslation
     * @example
     * // Get one HeroBillboardsTranslation
     * const heroBillboardsTranslation = await prisma.heroBillboardsTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroBillboardsTranslationFindUniqueArgs>(args: SelectSubset<T, HeroBillboardsTranslationFindUniqueArgs<ExtArgs>>): Prisma__HeroBillboardsTranslationClient<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HeroBillboardsTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HeroBillboardsTranslationFindUniqueOrThrowArgs} args - Arguments to find a HeroBillboardsTranslation
     * @example
     * // Get one HeroBillboardsTranslation
     * const heroBillboardsTranslation = await prisma.heroBillboardsTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroBillboardsTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, HeroBillboardsTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeroBillboardsTranslationClient<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HeroBillboardsTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsTranslationFindFirstArgs} args - Arguments to find a HeroBillboardsTranslation
     * @example
     * // Get one HeroBillboardsTranslation
     * const heroBillboardsTranslation = await prisma.heroBillboardsTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroBillboardsTranslationFindFirstArgs>(args?: SelectSubset<T, HeroBillboardsTranslationFindFirstArgs<ExtArgs>>): Prisma__HeroBillboardsTranslationClient<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HeroBillboardsTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsTranslationFindFirstOrThrowArgs} args - Arguments to find a HeroBillboardsTranslation
     * @example
     * // Get one HeroBillboardsTranslation
     * const heroBillboardsTranslation = await prisma.heroBillboardsTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroBillboardsTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, HeroBillboardsTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeroBillboardsTranslationClient<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HeroBillboardsTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroBillboardsTranslations
     * const heroBillboardsTranslations = await prisma.heroBillboardsTranslation.findMany()
     * 
     * // Get first 10 HeroBillboardsTranslations
     * const heroBillboardsTranslations = await prisma.heroBillboardsTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heroBillboardsTranslationWithIdOnly = await prisma.heroBillboardsTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeroBillboardsTranslationFindManyArgs>(args?: SelectSubset<T, HeroBillboardsTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HeroBillboardsTranslation.
     * @param {HeroBillboardsTranslationCreateArgs} args - Arguments to create a HeroBillboardsTranslation.
     * @example
     * // Create one HeroBillboardsTranslation
     * const HeroBillboardsTranslation = await prisma.heroBillboardsTranslation.create({
     *   data: {
     *     // ... data to create a HeroBillboardsTranslation
     *   }
     * })
     * 
     */
    create<T extends HeroBillboardsTranslationCreateArgs>(args: SelectSubset<T, HeroBillboardsTranslationCreateArgs<ExtArgs>>): Prisma__HeroBillboardsTranslationClient<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HeroBillboardsTranslations.
     * @param {HeroBillboardsTranslationCreateManyArgs} args - Arguments to create many HeroBillboardsTranslations.
     * @example
     * // Create many HeroBillboardsTranslations
     * const heroBillboardsTranslation = await prisma.heroBillboardsTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeroBillboardsTranslationCreateManyArgs>(args?: SelectSubset<T, HeroBillboardsTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HeroBillboardsTranslations and returns the data saved in the database.
     * @param {HeroBillboardsTranslationCreateManyAndReturnArgs} args - Arguments to create many HeroBillboardsTranslations.
     * @example
     * // Create many HeroBillboardsTranslations
     * const heroBillboardsTranslation = await prisma.heroBillboardsTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HeroBillboardsTranslations and only return the `id`
     * const heroBillboardsTranslationWithIdOnly = await prisma.heroBillboardsTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HeroBillboardsTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, HeroBillboardsTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HeroBillboardsTranslation.
     * @param {HeroBillboardsTranslationDeleteArgs} args - Arguments to delete one HeroBillboardsTranslation.
     * @example
     * // Delete one HeroBillboardsTranslation
     * const HeroBillboardsTranslation = await prisma.heroBillboardsTranslation.delete({
     *   where: {
     *     // ... filter to delete one HeroBillboardsTranslation
     *   }
     * })
     * 
     */
    delete<T extends HeroBillboardsTranslationDeleteArgs>(args: SelectSubset<T, HeroBillboardsTranslationDeleteArgs<ExtArgs>>): Prisma__HeroBillboardsTranslationClient<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HeroBillboardsTranslation.
     * @param {HeroBillboardsTranslationUpdateArgs} args - Arguments to update one HeroBillboardsTranslation.
     * @example
     * // Update one HeroBillboardsTranslation
     * const heroBillboardsTranslation = await prisma.heroBillboardsTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeroBillboardsTranslationUpdateArgs>(args: SelectSubset<T, HeroBillboardsTranslationUpdateArgs<ExtArgs>>): Prisma__HeroBillboardsTranslationClient<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HeroBillboardsTranslations.
     * @param {HeroBillboardsTranslationDeleteManyArgs} args - Arguments to filter HeroBillboardsTranslations to delete.
     * @example
     * // Delete a few HeroBillboardsTranslations
     * const { count } = await prisma.heroBillboardsTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeroBillboardsTranslationDeleteManyArgs>(args?: SelectSubset<T, HeroBillboardsTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroBillboardsTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroBillboardsTranslations
     * const heroBillboardsTranslation = await prisma.heroBillboardsTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeroBillboardsTranslationUpdateManyArgs>(args: SelectSubset<T, HeroBillboardsTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HeroBillboardsTranslation.
     * @param {HeroBillboardsTranslationUpsertArgs} args - Arguments to update or create a HeroBillboardsTranslation.
     * @example
     * // Update or create a HeroBillboardsTranslation
     * const heroBillboardsTranslation = await prisma.heroBillboardsTranslation.upsert({
     *   create: {
     *     // ... data to create a HeroBillboardsTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroBillboardsTranslation we want to update
     *   }
     * })
     */
    upsert<T extends HeroBillboardsTranslationUpsertArgs>(args: SelectSubset<T, HeroBillboardsTranslationUpsertArgs<ExtArgs>>): Prisma__HeroBillboardsTranslationClient<$Result.GetResult<Prisma.$HeroBillboardsTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HeroBillboardsTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsTranslationCountArgs} args - Arguments to filter HeroBillboardsTranslations to count.
     * @example
     * // Count the number of HeroBillboardsTranslations
     * const count = await prisma.heroBillboardsTranslation.count({
     *   where: {
     *     // ... the filter for the HeroBillboardsTranslations we want to count
     *   }
     * })
    **/
    count<T extends HeroBillboardsTranslationCountArgs>(
      args?: Subset<T, HeroBillboardsTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeroBillboardsTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeroBillboardsTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeroBillboardsTranslationAggregateArgs>(args: Subset<T, HeroBillboardsTranslationAggregateArgs>): Prisma.PrismaPromise<GetHeroBillboardsTranslationAggregateType<T>>

    /**
     * Group by HeroBillboardsTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBillboardsTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeroBillboardsTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroBillboardsTranslationGroupByArgs['orderBy'] }
        : { orderBy?: HeroBillboardsTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeroBillboardsTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeroBillboardsTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeroBillboardsTranslation model
   */
  readonly fields: HeroBillboardsTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroBillboardsTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroBillboardsTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    heroBillboard<T extends HeroBillboardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HeroBillboardsDefaultArgs<ExtArgs>>): Prisma__HeroBillboardsClient<$Result.GetResult<Prisma.$HeroBillboardsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeroBillboardsTranslation model
   */ 
  interface HeroBillboardsTranslationFieldRefs {
    readonly id: FieldRef<"HeroBillboardsTranslation", 'String'>
    readonly createdAt: FieldRef<"HeroBillboardsTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"HeroBillboardsTranslation", 'DateTime'>
    readonly title: FieldRef<"HeroBillboardsTranslation", 'String'>
    readonly langCode: FieldRef<"HeroBillboardsTranslation", 'String'>
    readonly subtitle: FieldRef<"HeroBillboardsTranslation", 'String'>
    readonly heroBillboardId: FieldRef<"HeroBillboardsTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HeroBillboardsTranslation findUnique
   */
  export type HeroBillboardsTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboardsTranslation to fetch.
     */
    where: HeroBillboardsTranslationWhereUniqueInput
  }

  /**
   * HeroBillboardsTranslation findUniqueOrThrow
   */
  export type HeroBillboardsTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboardsTranslation to fetch.
     */
    where: HeroBillboardsTranslationWhereUniqueInput
  }

  /**
   * HeroBillboardsTranslation findFirst
   */
  export type HeroBillboardsTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboardsTranslation to fetch.
     */
    where?: HeroBillboardsTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBillboardsTranslations to fetch.
     */
    orderBy?: HeroBillboardsTranslationOrderByWithRelationInput | HeroBillboardsTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroBillboardsTranslations.
     */
    cursor?: HeroBillboardsTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBillboardsTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBillboardsTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroBillboardsTranslations.
     */
    distinct?: HeroBillboardsTranslationScalarFieldEnum | HeroBillboardsTranslationScalarFieldEnum[]
  }

  /**
   * HeroBillboardsTranslation findFirstOrThrow
   */
  export type HeroBillboardsTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboardsTranslation to fetch.
     */
    where?: HeroBillboardsTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBillboardsTranslations to fetch.
     */
    orderBy?: HeroBillboardsTranslationOrderByWithRelationInput | HeroBillboardsTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroBillboardsTranslations.
     */
    cursor?: HeroBillboardsTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBillboardsTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBillboardsTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroBillboardsTranslations.
     */
    distinct?: HeroBillboardsTranslationScalarFieldEnum | HeroBillboardsTranslationScalarFieldEnum[]
  }

  /**
   * HeroBillboardsTranslation findMany
   */
  export type HeroBillboardsTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HeroBillboardsTranslations to fetch.
     */
    where?: HeroBillboardsTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBillboardsTranslations to fetch.
     */
    orderBy?: HeroBillboardsTranslationOrderByWithRelationInput | HeroBillboardsTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeroBillboardsTranslations.
     */
    cursor?: HeroBillboardsTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBillboardsTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBillboardsTranslations.
     */
    skip?: number
    distinct?: HeroBillboardsTranslationScalarFieldEnum | HeroBillboardsTranslationScalarFieldEnum[]
  }

  /**
   * HeroBillboardsTranslation create
   */
  export type HeroBillboardsTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a HeroBillboardsTranslation.
     */
    data: XOR<HeroBillboardsTranslationCreateInput, HeroBillboardsTranslationUncheckedCreateInput>
  }

  /**
   * HeroBillboardsTranslation createMany
   */
  export type HeroBillboardsTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeroBillboardsTranslations.
     */
    data: HeroBillboardsTranslationCreateManyInput | HeroBillboardsTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HeroBillboardsTranslation createManyAndReturn
   */
  export type HeroBillboardsTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HeroBillboardsTranslations.
     */
    data: HeroBillboardsTranslationCreateManyInput | HeroBillboardsTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HeroBillboardsTranslation update
   */
  export type HeroBillboardsTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a HeroBillboardsTranslation.
     */
    data: XOR<HeroBillboardsTranslationUpdateInput, HeroBillboardsTranslationUncheckedUpdateInput>
    /**
     * Choose, which HeroBillboardsTranslation to update.
     */
    where: HeroBillboardsTranslationWhereUniqueInput
  }

  /**
   * HeroBillboardsTranslation updateMany
   */
  export type HeroBillboardsTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeroBillboardsTranslations.
     */
    data: XOR<HeroBillboardsTranslationUpdateManyMutationInput, HeroBillboardsTranslationUncheckedUpdateManyInput>
    /**
     * Filter which HeroBillboardsTranslations to update
     */
    where?: HeroBillboardsTranslationWhereInput
  }

  /**
   * HeroBillboardsTranslation upsert
   */
  export type HeroBillboardsTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the HeroBillboardsTranslation to update in case it exists.
     */
    where: HeroBillboardsTranslationWhereUniqueInput
    /**
     * In case the HeroBillboardsTranslation found by the `where` argument doesn't exist, create a new HeroBillboardsTranslation with this data.
     */
    create: XOR<HeroBillboardsTranslationCreateInput, HeroBillboardsTranslationUncheckedCreateInput>
    /**
     * In case the HeroBillboardsTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroBillboardsTranslationUpdateInput, HeroBillboardsTranslationUncheckedUpdateInput>
  }

  /**
   * HeroBillboardsTranslation delete
   */
  export type HeroBillboardsTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
    /**
     * Filter which HeroBillboardsTranslation to delete.
     */
    where: HeroBillboardsTranslationWhereUniqueInput
  }

  /**
   * HeroBillboardsTranslation deleteMany
   */
  export type HeroBillboardsTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroBillboardsTranslations to delete
     */
    where?: HeroBillboardsTranslationWhereInput
  }

  /**
   * HeroBillboardsTranslation without action
   */
  export type HeroBillboardsTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBillboardsTranslation
     */
    select?: HeroBillboardsTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HeroBillboardsTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    code: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    code: string | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    code: number
    _all: number
  }


  export type LanguageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    code?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    code: string
    _count: LanguageCountAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    code?: boolean
  }


  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      code: string
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'String'>
    readonly createdAt: FieldRef<"Language", 'DateTime'>
    readonly updatedAt: FieldRef<"Language", 'DateTime'>
    readonly name: FieldRef<"Language", 'String'>
    readonly code: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
  }


  /**
   * Model Billboard
   */

  export type AggregateBillboard = {
    _count: BillboardCountAggregateOutputType | null
    _min: BillboardMinAggregateOutputType | null
    _max: BillboardMaxAggregateOutputType | null
  }

  export type BillboardMinAggregateOutputType = {
    id: string | null
    label: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillboardMaxAggregateOutputType = {
    id: string | null
    label: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BillboardCountAggregateOutputType = {
    id: number
    label: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BillboardMinAggregateInputType = {
    id?: true
    label?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillboardMaxAggregateInputType = {
    id?: true
    label?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BillboardCountAggregateInputType = {
    id?: true
    label?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BillboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billboard to aggregate.
     */
    where?: BillboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billboards to fetch.
     */
    orderBy?: BillboardOrderByWithRelationInput | BillboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Billboards
    **/
    _count?: true | BillboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillboardMaxAggregateInputType
  }

  export type GetBillboardAggregateType<T extends BillboardAggregateArgs> = {
        [P in keyof T & keyof AggregateBillboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillboard[P]>
      : GetScalarType<T[P], AggregateBillboard[P]>
  }




  export type BillboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillboardWhereInput
    orderBy?: BillboardOrderByWithAggregationInput | BillboardOrderByWithAggregationInput[]
    by: BillboardScalarFieldEnum[] | BillboardScalarFieldEnum
    having?: BillboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillboardCountAggregateInputType | true
    _min?: BillboardMinAggregateInputType
    _max?: BillboardMaxAggregateInputType
  }

  export type BillboardGroupByOutputType = {
    id: string
    label: string
    imageUrl: string
    createdAt: Date
    updatedAt: Date
    _count: BillboardCountAggregateOutputType | null
    _min: BillboardMinAggregateOutputType | null
    _max: BillboardMaxAggregateOutputType | null
  }

  type GetBillboardGroupByPayload<T extends BillboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillboardGroupByOutputType[P]>
            : GetScalarType<T[P], BillboardGroupByOutputType[P]>
        }
      >
    >


  export type BillboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categories?: boolean | Billboard$categoriesArgs<ExtArgs>
    _count?: boolean | BillboardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["billboard"]>

  export type BillboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["billboard"]>

  export type BillboardSelectScalar = {
    id?: boolean
    label?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BillboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Billboard$categoriesArgs<ExtArgs>
    _count?: boolean | BillboardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BillboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BillboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Billboard"
    objects: {
      categories: Prisma.$CategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      imageUrl: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["billboard"]>
    composites: {}
  }

  type BillboardGetPayload<S extends boolean | null | undefined | BillboardDefaultArgs> = $Result.GetResult<Prisma.$BillboardPayload, S>

  type BillboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillboardCountAggregateInputType | true
    }

  export interface BillboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Billboard'], meta: { name: 'Billboard' } }
    /**
     * Find zero or one Billboard that matches the filter.
     * @param {BillboardFindUniqueArgs} args - Arguments to find a Billboard
     * @example
     * // Get one Billboard
     * const billboard = await prisma.billboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillboardFindUniqueArgs>(args: SelectSubset<T, BillboardFindUniqueArgs<ExtArgs>>): Prisma__BillboardClient<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Billboard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillboardFindUniqueOrThrowArgs} args - Arguments to find a Billboard
     * @example
     * // Get one Billboard
     * const billboard = await prisma.billboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillboardFindUniqueOrThrowArgs>(args: SelectSubset<T, BillboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillboardClient<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Billboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillboardFindFirstArgs} args - Arguments to find a Billboard
     * @example
     * // Get one Billboard
     * const billboard = await prisma.billboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillboardFindFirstArgs>(args?: SelectSubset<T, BillboardFindFirstArgs<ExtArgs>>): Prisma__BillboardClient<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Billboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillboardFindFirstOrThrowArgs} args - Arguments to find a Billboard
     * @example
     * // Get one Billboard
     * const billboard = await prisma.billboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillboardFindFirstOrThrowArgs>(args?: SelectSubset<T, BillboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillboardClient<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Billboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Billboards
     * const billboards = await prisma.billboard.findMany()
     * 
     * // Get first 10 Billboards
     * const billboards = await prisma.billboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billboardWithIdOnly = await prisma.billboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BillboardFindManyArgs>(args?: SelectSubset<T, BillboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Billboard.
     * @param {BillboardCreateArgs} args - Arguments to create a Billboard.
     * @example
     * // Create one Billboard
     * const Billboard = await prisma.billboard.create({
     *   data: {
     *     // ... data to create a Billboard
     *   }
     * })
     * 
     */
    create<T extends BillboardCreateArgs>(args: SelectSubset<T, BillboardCreateArgs<ExtArgs>>): Prisma__BillboardClient<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Billboards.
     * @param {BillboardCreateManyArgs} args - Arguments to create many Billboards.
     * @example
     * // Create many Billboards
     * const billboard = await prisma.billboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillboardCreateManyArgs>(args?: SelectSubset<T, BillboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Billboards and returns the data saved in the database.
     * @param {BillboardCreateManyAndReturnArgs} args - Arguments to create many Billboards.
     * @example
     * // Create many Billboards
     * const billboard = await prisma.billboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Billboards and only return the `id`
     * const billboardWithIdOnly = await prisma.billboard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillboardCreateManyAndReturnArgs>(args?: SelectSubset<T, BillboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Billboard.
     * @param {BillboardDeleteArgs} args - Arguments to delete one Billboard.
     * @example
     * // Delete one Billboard
     * const Billboard = await prisma.billboard.delete({
     *   where: {
     *     // ... filter to delete one Billboard
     *   }
     * })
     * 
     */
    delete<T extends BillboardDeleteArgs>(args: SelectSubset<T, BillboardDeleteArgs<ExtArgs>>): Prisma__BillboardClient<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Billboard.
     * @param {BillboardUpdateArgs} args - Arguments to update one Billboard.
     * @example
     * // Update one Billboard
     * const billboard = await prisma.billboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillboardUpdateArgs>(args: SelectSubset<T, BillboardUpdateArgs<ExtArgs>>): Prisma__BillboardClient<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Billboards.
     * @param {BillboardDeleteManyArgs} args - Arguments to filter Billboards to delete.
     * @example
     * // Delete a few Billboards
     * const { count } = await prisma.billboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillboardDeleteManyArgs>(args?: SelectSubset<T, BillboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Billboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Billboards
     * const billboard = await prisma.billboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillboardUpdateManyArgs>(args: SelectSubset<T, BillboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Billboard.
     * @param {BillboardUpsertArgs} args - Arguments to update or create a Billboard.
     * @example
     * // Update or create a Billboard
     * const billboard = await prisma.billboard.upsert({
     *   create: {
     *     // ... data to create a Billboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Billboard we want to update
     *   }
     * })
     */
    upsert<T extends BillboardUpsertArgs>(args: SelectSubset<T, BillboardUpsertArgs<ExtArgs>>): Prisma__BillboardClient<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Billboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillboardCountArgs} args - Arguments to filter Billboards to count.
     * @example
     * // Count the number of Billboards
     * const count = await prisma.billboard.count({
     *   where: {
     *     // ... the filter for the Billboards we want to count
     *   }
     * })
    **/
    count<T extends BillboardCountArgs>(
      args?: Subset<T, BillboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Billboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillboardAggregateArgs>(args: Subset<T, BillboardAggregateArgs>): Prisma.PrismaPromise<GetBillboardAggregateType<T>>

    /**
     * Group by Billboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillboardGroupByArgs['orderBy'] }
        : { orderBy?: BillboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Billboard model
   */
  readonly fields: BillboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Billboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Billboard$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Billboard$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Billboard model
   */ 
  interface BillboardFieldRefs {
    readonly id: FieldRef<"Billboard", 'String'>
    readonly label: FieldRef<"Billboard", 'String'>
    readonly imageUrl: FieldRef<"Billboard", 'String'>
    readonly createdAt: FieldRef<"Billboard", 'DateTime'>
    readonly updatedAt: FieldRef<"Billboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Billboard findUnique
   */
  export type BillboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    /**
     * Filter, which Billboard to fetch.
     */
    where: BillboardWhereUniqueInput
  }

  /**
   * Billboard findUniqueOrThrow
   */
  export type BillboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    /**
     * Filter, which Billboard to fetch.
     */
    where: BillboardWhereUniqueInput
  }

  /**
   * Billboard findFirst
   */
  export type BillboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    /**
     * Filter, which Billboard to fetch.
     */
    where?: BillboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billboards to fetch.
     */
    orderBy?: BillboardOrderByWithRelationInput | BillboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billboards.
     */
    cursor?: BillboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billboards.
     */
    distinct?: BillboardScalarFieldEnum | BillboardScalarFieldEnum[]
  }

  /**
   * Billboard findFirstOrThrow
   */
  export type BillboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    /**
     * Filter, which Billboard to fetch.
     */
    where?: BillboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billboards to fetch.
     */
    orderBy?: BillboardOrderByWithRelationInput | BillboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Billboards.
     */
    cursor?: BillboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Billboards.
     */
    distinct?: BillboardScalarFieldEnum | BillboardScalarFieldEnum[]
  }

  /**
   * Billboard findMany
   */
  export type BillboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    /**
     * Filter, which Billboards to fetch.
     */
    where?: BillboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Billboards to fetch.
     */
    orderBy?: BillboardOrderByWithRelationInput | BillboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Billboards.
     */
    cursor?: BillboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Billboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Billboards.
     */
    skip?: number
    distinct?: BillboardScalarFieldEnum | BillboardScalarFieldEnum[]
  }

  /**
   * Billboard create
   */
  export type BillboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Billboard.
     */
    data: XOR<BillboardCreateInput, BillboardUncheckedCreateInput>
  }

  /**
   * Billboard createMany
   */
  export type BillboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Billboards.
     */
    data: BillboardCreateManyInput | BillboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Billboard createManyAndReturn
   */
  export type BillboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Billboards.
     */
    data: BillboardCreateManyInput | BillboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Billboard update
   */
  export type BillboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Billboard.
     */
    data: XOR<BillboardUpdateInput, BillboardUncheckedUpdateInput>
    /**
     * Choose, which Billboard to update.
     */
    where: BillboardWhereUniqueInput
  }

  /**
   * Billboard updateMany
   */
  export type BillboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Billboards.
     */
    data: XOR<BillboardUpdateManyMutationInput, BillboardUncheckedUpdateManyInput>
    /**
     * Filter which Billboards to update
     */
    where?: BillboardWhereInput
  }

  /**
   * Billboard upsert
   */
  export type BillboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Billboard to update in case it exists.
     */
    where: BillboardWhereUniqueInput
    /**
     * In case the Billboard found by the `where` argument doesn't exist, create a new Billboard with this data.
     */
    create: XOR<BillboardCreateInput, BillboardUncheckedCreateInput>
    /**
     * In case the Billboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillboardUpdateInput, BillboardUncheckedUpdateInput>
  }

  /**
   * Billboard delete
   */
  export type BillboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    /**
     * Filter which Billboard to delete.
     */
    where: BillboardWhereUniqueInput
  }

  /**
   * Billboard deleteMany
   */
  export type BillboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Billboards to delete
     */
    where?: BillboardWhereInput
  }

  /**
   * Billboard.categories
   */
  export type Billboard$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Billboard without action
   */
  export type BillboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    maxPrice: Decimal | null
  }

  export type CategorySumAggregateOutputType = {
    maxPrice: Decimal | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    billboardId: string | null
    name: string | null
    type: $Enums.TypeCategory | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    maxPrice: Decimal | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    billboardId: string | null
    name: string | null
    type: $Enums.TypeCategory | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    maxPrice: Decimal | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    billboardId: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    parentId: number
    maxPrice: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    maxPrice?: true
  }

  export type CategorySumAggregateInputType = {
    maxPrice?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    billboardId?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    maxPrice?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    billboardId?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    maxPrice?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    billboardId?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    maxPrice?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    billboardId: string | null
    name: string
    type: $Enums.TypeCategory
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    maxPrice: Decimal | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billboardId?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    maxPrice?: boolean
    billboard?: boolean | Category$billboardArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    billboardId?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    maxPrice?: boolean
    billboard?: boolean | Category$billboardArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    billboardId?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    maxPrice?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billboard?: boolean | Category$billboardArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    billboard?: boolean | Category$billboardArgs<ExtArgs>
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      billboard: Prisma.$BillboardPayload<ExtArgs> | null
      products: Prisma.$ProductCategoryPayload<ExtArgs>[]
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      billboardId: string | null
      name: string
      type: $Enums.TypeCategory
      createdAt: Date
      updatedAt: Date
      parentId: string | null
      maxPrice: Prisma.Decimal | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    billboard<T extends Category$billboardArgs<ExtArgs> = {}>(args?: Subset<T, Category$billboardArgs<ExtArgs>>): Prisma__BillboardClient<$Result.GetResult<Prisma.$BillboardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly billboardId: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly type: FieldRef<"Category", 'TypeCategory'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly maxPrice: FieldRef<"Category", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.billboard
   */
  export type Category$billboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Billboard
     */
    select?: BillboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillboardInclude<ExtArgs> | null
    where?: BillboardWhereInput
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model ProductCategory
   */

  export type AggregateProductCategory = {
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  export type ProductCategoryMinAggregateOutputType = {
    id: string | null
    productId: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    categoryId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCategoryCountAggregateOutputType = {
    id: number
    productId: number
    categoryId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductCategoryMinAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryMaxAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCategoryCountAggregateInputType = {
    id?: true
    productId?: true
    categoryId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategory to aggregate.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCategories
    **/
    _count?: true | ProductCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type GetProductCategoryAggregateType<T extends ProductCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCategory[P]>
      : GetScalarType<T[P], AggregateProductCategory[P]>
  }




  export type ProductCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithAggregationInput | ProductCategoryOrderByWithAggregationInput[]
    by: ProductCategoryScalarFieldEnum[] | ProductCategoryScalarFieldEnum
    having?: ProductCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCategoryCountAggregateInputType | true
    _min?: ProductCategoryMinAggregateInputType
    _max?: ProductCategoryMaxAggregateInputType
  }

  export type ProductCategoryGroupByOutputType = {
    id: string
    productId: string
    categoryId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductCategoryCountAggregateOutputType | null
    _min: ProductCategoryMinAggregateOutputType | null
    _max: ProductCategoryMaxAggregateOutputType | null
  }

  type GetProductCategoryGroupByPayload<T extends ProductCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCategory"]>

  export type ProductCategorySelectScalar = {
    id?: boolean
    productId?: boolean
    categoryId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type ProductCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $ProductCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCategory"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      categoryId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productCategory"]>
    composites: {}
  }

  type ProductCategoryGetPayload<S extends boolean | null | undefined | ProductCategoryDefaultArgs> = $Result.GetResult<Prisma.$ProductCategoryPayload, S>

  type ProductCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCategoryCountAggregateInputType | true
    }

  export interface ProductCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCategory'], meta: { name: 'ProductCategory' } }
    /**
     * Find zero or one ProductCategory that matches the filter.
     * @param {ProductCategoryFindUniqueArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCategoryFindUniqueArgs>(args: SelectSubset<T, ProductCategoryFindUniqueArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductCategoryFindUniqueOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCategoryFindFirstArgs>(args?: SelectSubset<T, ProductCategoryFindFirstArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindFirstOrThrowArgs} args - Arguments to find a ProductCategory
     * @example
     * // Get one ProductCategory
     * const productCategory = await prisma.productCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCategories
     * const productCategories = await prisma.productCategory.findMany()
     * 
     * // Get first 10 ProductCategories
     * const productCategories = await prisma.productCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCategoryFindManyArgs>(args?: SelectSubset<T, ProductCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductCategory.
     * @param {ProductCategoryCreateArgs} args - Arguments to create a ProductCategory.
     * @example
     * // Create one ProductCategory
     * const ProductCategory = await prisma.productCategory.create({
     *   data: {
     *     // ... data to create a ProductCategory
     *   }
     * })
     * 
     */
    create<T extends ProductCategoryCreateArgs>(args: SelectSubset<T, ProductCategoryCreateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductCategories.
     * @param {ProductCategoryCreateManyArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCategoryCreateManyArgs>(args?: SelectSubset<T, ProductCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCategories and returns the data saved in the database.
     * @param {ProductCategoryCreateManyAndReturnArgs} args - Arguments to create many ProductCategories.
     * @example
     * // Create many ProductCategories
     * const productCategory = await prisma.productCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCategories and only return the `id`
     * const productCategoryWithIdOnly = await prisma.productCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductCategory.
     * @param {ProductCategoryDeleteArgs} args - Arguments to delete one ProductCategory.
     * @example
     * // Delete one ProductCategory
     * const ProductCategory = await prisma.productCategory.delete({
     *   where: {
     *     // ... filter to delete one ProductCategory
     *   }
     * })
     * 
     */
    delete<T extends ProductCategoryDeleteArgs>(args: SelectSubset<T, ProductCategoryDeleteArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductCategory.
     * @param {ProductCategoryUpdateArgs} args - Arguments to update one ProductCategory.
     * @example
     * // Update one ProductCategory
     * const productCategory = await prisma.productCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCategoryUpdateArgs>(args: SelectSubset<T, ProductCategoryUpdateArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductCategories.
     * @param {ProductCategoryDeleteManyArgs} args - Arguments to filter ProductCategories to delete.
     * @example
     * // Delete a few ProductCategories
     * const { count } = await prisma.productCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCategoryDeleteManyArgs>(args?: SelectSubset<T, ProductCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCategories
     * const productCategory = await prisma.productCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCategoryUpdateManyArgs>(args: SelectSubset<T, ProductCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCategory.
     * @param {ProductCategoryUpsertArgs} args - Arguments to update or create a ProductCategory.
     * @example
     * // Update or create a ProductCategory
     * const productCategory = await prisma.productCategory.upsert({
     *   create: {
     *     // ... data to create a ProductCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCategory we want to update
     *   }
     * })
     */
    upsert<T extends ProductCategoryUpsertArgs>(args: SelectSubset<T, ProductCategoryUpsertArgs<ExtArgs>>): Prisma__ProductCategoryClient<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryCountArgs} args - Arguments to filter ProductCategories to count.
     * @example
     * // Count the number of ProductCategories
     * const count = await prisma.productCategory.count({
     *   where: {
     *     // ... the filter for the ProductCategories we want to count
     *   }
     * })
    **/
    count<T extends ProductCategoryCountArgs>(
      args?: Subset<T, ProductCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCategoryAggregateArgs>(args: Subset<T, ProductCategoryAggregateArgs>): Prisma.PrismaPromise<GetProductCategoryAggregateType<T>>

    /**
     * Group by ProductCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCategory model
   */
  readonly fields: ProductCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCategory model
   */ 
  interface ProductCategoryFieldRefs {
    readonly id: FieldRef<"ProductCategory", 'String'>
    readonly productId: FieldRef<"ProductCategory", 'String'>
    readonly categoryId: FieldRef<"ProductCategory", 'String'>
    readonly createdAt: FieldRef<"ProductCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCategory findUnique
   */
  export type ProductCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findUniqueOrThrow
   */
  export type ProductCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory findFirst
   */
  export type ProductCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findFirstOrThrow
   */
  export type ProductCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategory to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCategories.
     */
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory findMany
   */
  export type ProductCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductCategories to fetch.
     */
    where?: ProductCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCategories to fetch.
     */
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCategories.
     */
    cursor?: ProductCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCategories.
     */
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * ProductCategory create
   */
  export type ProductCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCategory.
     */
    data: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
  }

  /**
   * ProductCategory createMany
   */
  export type ProductCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCategory createManyAndReturn
   */
  export type ProductCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductCategories.
     */
    data: ProductCategoryCreateManyInput | ProductCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCategory update
   */
  export type ProductCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCategory.
     */
    data: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
    /**
     * Choose, which ProductCategory to update.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory updateMany
   */
  export type ProductCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCategories.
     */
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductCategories to update
     */
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory upsert
   */
  export type ProductCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCategory to update in case it exists.
     */
    where: ProductCategoryWhereUniqueInput
    /**
     * In case the ProductCategory found by the `where` argument doesn't exist, create a new ProductCategory with this data.
     */
    create: XOR<ProductCategoryCreateInput, ProductCategoryUncheckedCreateInput>
    /**
     * In case the ProductCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCategoryUpdateInput, ProductCategoryUncheckedUpdateInput>
  }

  /**
   * ProductCategory delete
   */
  export type ProductCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    /**
     * Filter which ProductCategory to delete.
     */
    where: ProductCategoryWhereUniqueInput
  }

  /**
   * ProductCategory deleteMany
   */
  export type ProductCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCategories to delete
     */
    where?: ProductCategoryWhereInput
  }

  /**
   * ProductCategory without action
   */
  export type ProductCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    quantity: number | null
    price: number | null
    position: number | null
  }

  export type ProductSumAggregateOutputType = {
    quantity: number | null
    price: number | null
    position: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    quantity: number | null
    price: number | null
    type: $Enums.ProductType | null
    isArchived: boolean | null
    isFeatured: boolean | null
    backgroundColor: string | null
    textColor: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    article: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    quantity: number | null
    price: number | null
    type: $Enums.ProductType | null
    isArchived: boolean | null
    isFeatured: boolean | null
    backgroundColor: string | null
    textColor: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
    article: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    title: number
    description: number
    quantity: number
    price: number
    type: number
    isArchived: number
    isFeatured: number
    backgroundColor: number
    textColor: number
    position: number
    createdAt: number
    updatedAt: number
    article: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    quantity?: true
    price?: true
    position?: true
  }

  export type ProductSumAggregateInputType = {
    quantity?: true
    price?: true
    position?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    quantity?: true
    price?: true
    type?: true
    isArchived?: true
    isFeatured?: true
    backgroundColor?: true
    textColor?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    article?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    quantity?: true
    price?: true
    type?: true
    isArchived?: true
    isFeatured?: true
    backgroundColor?: true
    textColor?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    article?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    quantity?: true
    price?: true
    type?: true
    isArchived?: true
    isFeatured?: true
    backgroundColor?: true
    textColor?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    article?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    title: string
    description: string
    quantity: number
    price: number
    type: $Enums.ProductType
    isArchived: boolean
    isFeatured: boolean
    backgroundColor: string
    textColor: string
    position: number
    createdAt: Date
    updatedAt: Date
    article: string
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    quantity?: boolean
    price?: boolean
    type?: boolean
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    images?: boolean | Product$imagesArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    productCharacteristics?: boolean | Product$productCharacteristicsArgs<ExtArgs>
    translations?: boolean | Product$translationsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    quantity?: boolean
    price?: boolean
    type?: boolean
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    quantity?: boolean
    price?: boolean
    type?: boolean
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: boolean
    textColor?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    article?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | Product$categoriesArgs<ExtArgs>
    images?: boolean | Product$imagesArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    productCharacteristics?: boolean | Product$productCharacteristicsArgs<ExtArgs>
    translations?: boolean | Product$translationsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      categories: Prisma.$ProductCategoryPayload<ExtArgs>[]
      images: Prisma.$ImagePayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      productCharacteristics: Prisma.$ProductCharacteristicPayload<ExtArgs>[]
      translations: Prisma.$ProductTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      quantity: number
      price: number
      type: $Enums.ProductType
      isArchived: boolean
      isFeatured: boolean
      backgroundColor: string
      textColor: string
      position: number
      createdAt: Date
      updatedAt: Date
      article: string
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends Product$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    images<T extends Product$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Product$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany"> | Null>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    productCharacteristics<T extends Product$productCharacteristicsArgs<ExtArgs> = {}>(args?: Subset<T, Product$productCharacteristicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findMany"> | Null>
    translations<T extends Product$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Product$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly quantity: FieldRef<"Product", 'Int'>
    readonly price: FieldRef<"Product", 'Int'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly isArchived: FieldRef<"Product", 'Boolean'>
    readonly isFeatured: FieldRef<"Product", 'Boolean'>
    readonly backgroundColor: FieldRef<"Product", 'String'>
    readonly textColor: FieldRef<"Product", 'String'>
    readonly position: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly article: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.categories
   */
  export type Product$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCategory
     */
    select?: ProductCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCategoryInclude<ExtArgs> | null
    where?: ProductCategoryWhereInput
    orderBy?: ProductCategoryOrderByWithRelationInput | ProductCategoryOrderByWithRelationInput[]
    cursor?: ProductCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCategoryScalarFieldEnum | ProductCategoryScalarFieldEnum[]
  }

  /**
   * Product.images
   */
  export type Product$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.productCharacteristics
   */
  export type Product$productCharacteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    where?: ProductCharacteristicWhereInput
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    cursor?: ProductCharacteristicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * Product.translations
   */
  export type Product$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    cursor?: ProductTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductTranslation
   */

  export type AggregateProductTranslation = {
    _count: ProductTranslationCountAggregateOutputType | null
    _min: ProductTranslationMinAggregateOutputType | null
    _max: ProductTranslationMaxAggregateOutputType | null
  }

  export type ProductTranslationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    languageCode: string | null
    title: string | null
    description: string | null
    productId: string | null
  }

  export type ProductTranslationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    languageCode: string | null
    title: string | null
    description: string | null
    productId: string | null
  }

  export type ProductTranslationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    languageCode: number
    title: number
    description: number
    productId: number
    _all: number
  }


  export type ProductTranslationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    languageCode?: true
    title?: true
    description?: true
    productId?: true
  }

  export type ProductTranslationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    languageCode?: true
    title?: true
    description?: true
    productId?: true
  }

  export type ProductTranslationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    languageCode?: true
    title?: true
    description?: true
    productId?: true
    _all?: true
  }

  export type ProductTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTranslation to aggregate.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTranslations
    **/
    _count?: true | ProductTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTranslationMaxAggregateInputType
  }

  export type GetProductTranslationAggregateType<T extends ProductTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductTranslation[P]>
      : GetScalarType<T[P], AggregateProductTranslation[P]>
  }




  export type ProductTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTranslationWhereInput
    orderBy?: ProductTranslationOrderByWithAggregationInput | ProductTranslationOrderByWithAggregationInput[]
    by: ProductTranslationScalarFieldEnum[] | ProductTranslationScalarFieldEnum
    having?: ProductTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTranslationCountAggregateInputType | true
    _min?: ProductTranslationMinAggregateInputType
    _max?: ProductTranslationMaxAggregateInputType
  }

  export type ProductTranslationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    languageCode: string
    title: string
    description: string
    productId: string
    _count: ProductTranslationCountAggregateOutputType | null
    _min: ProductTranslationMinAggregateOutputType | null
    _max: ProductTranslationMaxAggregateOutputType | null
  }

  type GetProductTranslationGroupByPayload<T extends ProductTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ProductTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    languageCode?: boolean
    title?: boolean
    description?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTranslation"]>

  export type ProductTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    languageCode?: boolean
    title?: boolean
    description?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTranslation"]>

  export type ProductTranslationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    languageCode?: boolean
    title?: boolean
    description?: boolean
    productId?: boolean
  }

  export type ProductTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductTranslation"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      languageCode: string
      title: string
      description: string
      productId: string
    }, ExtArgs["result"]["productTranslation"]>
    composites: {}
  }

  type ProductTranslationGetPayload<S extends boolean | null | undefined | ProductTranslationDefaultArgs> = $Result.GetResult<Prisma.$ProductTranslationPayload, S>

  type ProductTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductTranslationCountAggregateInputType | true
    }

  export interface ProductTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductTranslation'], meta: { name: 'ProductTranslation' } }
    /**
     * Find zero or one ProductTranslation that matches the filter.
     * @param {ProductTranslationFindUniqueArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductTranslationFindUniqueArgs>(args: SelectSubset<T, ProductTranslationFindUniqueArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductTranslationFindUniqueOrThrowArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationFindFirstArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductTranslationFindFirstArgs>(args?: SelectSubset<T, ProductTranslationFindFirstArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationFindFirstOrThrowArgs} args - Arguments to find a ProductTranslation
     * @example
     * // Get one ProductTranslation
     * const productTranslation = await prisma.productTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTranslations
     * const productTranslations = await prisma.productTranslation.findMany()
     * 
     * // Get first 10 ProductTranslations
     * const productTranslations = await prisma.productTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productTranslationWithIdOnly = await prisma.productTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductTranslationFindManyArgs>(args?: SelectSubset<T, ProductTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductTranslation.
     * @param {ProductTranslationCreateArgs} args - Arguments to create a ProductTranslation.
     * @example
     * // Create one ProductTranslation
     * const ProductTranslation = await prisma.productTranslation.create({
     *   data: {
     *     // ... data to create a ProductTranslation
     *   }
     * })
     * 
     */
    create<T extends ProductTranslationCreateArgs>(args: SelectSubset<T, ProductTranslationCreateArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductTranslations.
     * @param {ProductTranslationCreateManyArgs} args - Arguments to create many ProductTranslations.
     * @example
     * // Create many ProductTranslations
     * const productTranslation = await prisma.productTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductTranslationCreateManyArgs>(args?: SelectSubset<T, ProductTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductTranslations and returns the data saved in the database.
     * @param {ProductTranslationCreateManyAndReturnArgs} args - Arguments to create many ProductTranslations.
     * @example
     * // Create many ProductTranslations
     * const productTranslation = await prisma.productTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductTranslations and only return the `id`
     * const productTranslationWithIdOnly = await prisma.productTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductTranslation.
     * @param {ProductTranslationDeleteArgs} args - Arguments to delete one ProductTranslation.
     * @example
     * // Delete one ProductTranslation
     * const ProductTranslation = await prisma.productTranslation.delete({
     *   where: {
     *     // ... filter to delete one ProductTranslation
     *   }
     * })
     * 
     */
    delete<T extends ProductTranslationDeleteArgs>(args: SelectSubset<T, ProductTranslationDeleteArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductTranslation.
     * @param {ProductTranslationUpdateArgs} args - Arguments to update one ProductTranslation.
     * @example
     * // Update one ProductTranslation
     * const productTranslation = await prisma.productTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductTranslationUpdateArgs>(args: SelectSubset<T, ProductTranslationUpdateArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductTranslations.
     * @param {ProductTranslationDeleteManyArgs} args - Arguments to filter ProductTranslations to delete.
     * @example
     * // Delete a few ProductTranslations
     * const { count } = await prisma.productTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductTranslationDeleteManyArgs>(args?: SelectSubset<T, ProductTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTranslations
     * const productTranslation = await prisma.productTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductTranslationUpdateManyArgs>(args: SelectSubset<T, ProductTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductTranslation.
     * @param {ProductTranslationUpsertArgs} args - Arguments to update or create a ProductTranslation.
     * @example
     * // Update or create a ProductTranslation
     * const productTranslation = await prisma.productTranslation.upsert({
     *   create: {
     *     // ... data to create a ProductTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ProductTranslationUpsertArgs>(args: SelectSubset<T, ProductTranslationUpsertArgs<ExtArgs>>): Prisma__ProductTranslationClient<$Result.GetResult<Prisma.$ProductTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationCountArgs} args - Arguments to filter ProductTranslations to count.
     * @example
     * // Count the number of ProductTranslations
     * const count = await prisma.productTranslation.count({
     *   where: {
     *     // ... the filter for the ProductTranslations we want to count
     *   }
     * })
    **/
    count<T extends ProductTranslationCountArgs>(
      args?: Subset<T, ProductTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTranslationAggregateArgs>(args: Subset<T, ProductTranslationAggregateArgs>): Prisma.PrismaPromise<GetProductTranslationAggregateType<T>>

    /**
     * Group by ProductTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ProductTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductTranslation model
   */
  readonly fields: ProductTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductTranslation model
   */ 
  interface ProductTranslationFieldRefs {
    readonly id: FieldRef<"ProductTranslation", 'String'>
    readonly createdAt: FieldRef<"ProductTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductTranslation", 'DateTime'>
    readonly languageCode: FieldRef<"ProductTranslation", 'String'>
    readonly title: FieldRef<"ProductTranslation", 'String'>
    readonly description: FieldRef<"ProductTranslation", 'String'>
    readonly productId: FieldRef<"ProductTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductTranslation findUnique
   */
  export type ProductTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation findUniqueOrThrow
   */
  export type ProductTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation findFirst
   */
  export type ProductTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTranslations.
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTranslations.
     */
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation findFirstOrThrow
   */
  export type ProductTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslation to fetch.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTranslations.
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTranslations.
     */
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation findMany
   */
  export type ProductTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductTranslations to fetch.
     */
    where?: ProductTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTranslations to fetch.
     */
    orderBy?: ProductTranslationOrderByWithRelationInput | ProductTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTranslations.
     */
    cursor?: ProductTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTranslations.
     */
    skip?: number
    distinct?: ProductTranslationScalarFieldEnum | ProductTranslationScalarFieldEnum[]
  }

  /**
   * ProductTranslation create
   */
  export type ProductTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductTranslation.
     */
    data: XOR<ProductTranslationCreateInput, ProductTranslationUncheckedCreateInput>
  }

  /**
   * ProductTranslation createMany
   */
  export type ProductTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTranslations.
     */
    data: ProductTranslationCreateManyInput | ProductTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductTranslation createManyAndReturn
   */
  export type ProductTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductTranslations.
     */
    data: ProductTranslationCreateManyInput | ProductTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTranslation update
   */
  export type ProductTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductTranslation.
     */
    data: XOR<ProductTranslationUpdateInput, ProductTranslationUncheckedUpdateInput>
    /**
     * Choose, which ProductTranslation to update.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation updateMany
   */
  export type ProductTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTranslations.
     */
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ProductTranslations to update
     */
    where?: ProductTranslationWhereInput
  }

  /**
   * ProductTranslation upsert
   */
  export type ProductTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductTranslation to update in case it exists.
     */
    where: ProductTranslationWhereUniqueInput
    /**
     * In case the ProductTranslation found by the `where` argument doesn't exist, create a new ProductTranslation with this data.
     */
    create: XOR<ProductTranslationCreateInput, ProductTranslationUncheckedCreateInput>
    /**
     * In case the ProductTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTranslationUpdateInput, ProductTranslationUncheckedUpdateInput>
  }

  /**
   * ProductTranslation delete
   */
  export type ProductTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
    /**
     * Filter which ProductTranslation to delete.
     */
    where: ProductTranslationWhereUniqueInput
  }

  /**
   * ProductTranslation deleteMany
   */
  export type ProductTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTranslations to delete
     */
    where?: ProductTranslationWhereInput
  }

  /**
   * ProductTranslation without action
   */
  export type ProductTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTranslation
     */
    select?: ProductTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageMinAggregateOutputType = {
    id: string | null
    productId: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    productId: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImageMinAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: string
    productId: string
    url: string
    createdAt: Date
    updatedAt: Date
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    id?: boolean
    productId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      url: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */ 
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'String'>
    readonly productId: FieldRef<"Image", 'String'>
    readonly url: FieldRef<"Image", 'String'>
    readonly createdAt: FieldRef<"Image", 'DateTime'>
    readonly updatedAt: FieldRef<"Image", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image createManyAndReturn
   */
  export type ImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalPrice: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalPrice: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    isPaid: boolean | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    orderNumber: string | null
    message: string | null
    messagngerType: string | null
    messenger: string | null
    totalPrice: number | null
    orderStatus: $Enums.OrderTypes | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    isPaid: boolean | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    orderNumber: string | null
    message: string | null
    messagngerType: string | null
    messenger: string | null
    totalPrice: number | null
    orderStatus: $Enums.OrderTypes | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    isPaid: number
    firstName: number
    lastName: number
    phone: number
    email: number
    orderNumber: number
    message: number
    messagngerType: number
    messenger: number
    totalPrice: number
    orderStatus: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalPrice?: true
  }

  export type OrderSumAggregateInputType = {
    totalPrice?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    isPaid?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    orderNumber?: true
    message?: true
    messagngerType?: true
    messenger?: true
    totalPrice?: true
    orderStatus?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    isPaid?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    orderNumber?: true
    message?: true
    messagngerType?: true
    messenger?: true
    totalPrice?: true
    orderStatus?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    isPaid?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    orderNumber?: true
    message?: true
    messagngerType?: true
    messenger?: true
    totalPrice?: true
    orderStatus?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    isPaid: boolean
    firstName: string
    lastName: string
    phone: string
    email: string
    orderNumber: string
    message: string
    messagngerType: string
    messenger: string
    totalPrice: number
    orderStatus: $Enums.OrderTypes
    createdAt: Date
    updatedAt: Date
    userId: string
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isPaid?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    orderNumber?: boolean
    message?: boolean
    messagngerType?: boolean
    messenger?: boolean
    totalPrice?: boolean
    orderStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isPaid?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    orderNumber?: boolean
    message?: boolean
    messagngerType?: boolean
    messenger?: boolean
    totalPrice?: boolean
    orderStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    isPaid?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    orderNumber?: boolean
    message?: boolean
    messagngerType?: boolean
    messenger?: boolean
    totalPrice?: boolean
    orderStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isPaid: boolean
      firstName: string
      lastName: string
      phone: string
      email: string
      orderNumber: string
      message: string
      messagngerType: string
      messenger: string
      totalPrice: number
      orderStatus: $Enums.OrderTypes
      createdAt: Date
      updatedAt: Date
      userId: string
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly isPaid: FieldRef<"Order", 'Boolean'>
    readonly firstName: FieldRef<"Order", 'String'>
    readonly lastName: FieldRef<"Order", 'String'>
    readonly phone: FieldRef<"Order", 'String'>
    readonly email: FieldRef<"Order", 'String'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly message: FieldRef<"Order", 'String'>
    readonly messagngerType: FieldRef<"Order", 'String'>
    readonly messenger: FieldRef<"Order", 'String'>
    readonly totalPrice: FieldRef<"Order", 'Int'>
    readonly orderStatus: FieldRef<"Order", 'OrderTypes'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly userId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    orderId: string | null
    price: string | null
    productId: string | null
    quantity: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    orderId: string | null
    price: string | null
    productId: string | null
    quantity: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    orderId: number
    price: number
    productId: number
    quantity: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderId?: true
    price?: true
    productId?: true
    quantity?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderId?: true
    price?: true
    productId?: true
    quantity?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orderId?: true
    price?: true
    productId?: true
    quantity?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    orderId: string
    price: string
    productId: string
    quantity: number
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    price?: boolean
    productId?: boolean
    quantity?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    price?: boolean
    productId?: boolean
    quantity?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderId?: boolean
    price?: boolean
    productId?: boolean
    quantity?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      orderId: string
      price: string
      productId: string
      quantity: number
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly price: FieldRef<"OrderItem", 'String'>
    readonly productId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Characteristic
   */

  export type AggregateCharacteristic = {
    _count: CharacteristicCountAggregateOutputType | null
    _min: CharacteristicMinAggregateOutputType | null
    _max: CharacteristicMaxAggregateOutputType | null
  }

  export type CharacteristicMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
  }

  export type CharacteristicMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    description: string | null
  }

  export type CharacteristicCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    description: number
    _all: number
  }


  export type CharacteristicMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
  }

  export type CharacteristicMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
  }

  export type CharacteristicCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    description?: true
    _all?: true
  }

  export type CharacteristicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characteristic to aggregate.
     */
    where?: CharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicOrderByWithRelationInput | CharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characteristics
    **/
    _count?: true | CharacteristicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacteristicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacteristicMaxAggregateInputType
  }

  export type GetCharacteristicAggregateType<T extends CharacteristicAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacteristic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacteristic[P]>
      : GetScalarType<T[P], AggregateCharacteristic[P]>
  }




  export type CharacteristicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicWhereInput
    orderBy?: CharacteristicOrderByWithAggregationInput | CharacteristicOrderByWithAggregationInput[]
    by: CharacteristicScalarFieldEnum[] | CharacteristicScalarFieldEnum
    having?: CharacteristicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacteristicCountAggregateInputType | true
    _min?: CharacteristicMinAggregateInputType
    _max?: CharacteristicMaxAggregateInputType
  }

  export type CharacteristicGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    description: string | null
    _count: CharacteristicCountAggregateOutputType | null
    _min: CharacteristicMinAggregateOutputType | null
    _max: CharacteristicMaxAggregateOutputType | null
  }

  type GetCharacteristicGroupByPayload<T extends CharacteristicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacteristicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacteristicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacteristicGroupByOutputType[P]>
            : GetScalarType<T[P], CharacteristicGroupByOutputType[P]>
        }
      >
    >


  export type CharacteristicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
    productCharacteristics?: boolean | Characteristic$productCharacteristicsArgs<ExtArgs>
    translations?: boolean | Characteristic$translationsArgs<ExtArgs>
    _count?: boolean | CharacteristicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristic"]>

  export type CharacteristicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["characteristic"]>

  export type CharacteristicSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    description?: boolean
  }

  export type CharacteristicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productCharacteristics?: boolean | Characteristic$productCharacteristicsArgs<ExtArgs>
    translations?: boolean | Characteristic$translationsArgs<ExtArgs>
    _count?: boolean | CharacteristicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacteristicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CharacteristicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Characteristic"
    objects: {
      productCharacteristics: Prisma.$ProductCharacteristicPayload<ExtArgs>[]
      translations: Prisma.$CharacteristicTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      description: string | null
    }, ExtArgs["result"]["characteristic"]>
    composites: {}
  }

  type CharacteristicGetPayload<S extends boolean | null | undefined | CharacteristicDefaultArgs> = $Result.GetResult<Prisma.$CharacteristicPayload, S>

  type CharacteristicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacteristicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacteristicCountAggregateInputType | true
    }

  export interface CharacteristicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Characteristic'], meta: { name: 'Characteristic' } }
    /**
     * Find zero or one Characteristic that matches the filter.
     * @param {CharacteristicFindUniqueArgs} args - Arguments to find a Characteristic
     * @example
     * // Get one Characteristic
     * const characteristic = await prisma.characteristic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacteristicFindUniqueArgs>(args: SelectSubset<T, CharacteristicFindUniqueArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Characteristic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacteristicFindUniqueOrThrowArgs} args - Arguments to find a Characteristic
     * @example
     * // Get one Characteristic
     * const characteristic = await prisma.characteristic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacteristicFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacteristicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Characteristic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicFindFirstArgs} args - Arguments to find a Characteristic
     * @example
     * // Get one Characteristic
     * const characteristic = await prisma.characteristic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacteristicFindFirstArgs>(args?: SelectSubset<T, CharacteristicFindFirstArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Characteristic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicFindFirstOrThrowArgs} args - Arguments to find a Characteristic
     * @example
     * // Get one Characteristic
     * const characteristic = await prisma.characteristic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacteristicFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacteristicFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Characteristics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characteristics
     * const characteristics = await prisma.characteristic.findMany()
     * 
     * // Get first 10 Characteristics
     * const characteristics = await prisma.characteristic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characteristicWithIdOnly = await prisma.characteristic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacteristicFindManyArgs>(args?: SelectSubset<T, CharacteristicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Characteristic.
     * @param {CharacteristicCreateArgs} args - Arguments to create a Characteristic.
     * @example
     * // Create one Characteristic
     * const Characteristic = await prisma.characteristic.create({
     *   data: {
     *     // ... data to create a Characteristic
     *   }
     * })
     * 
     */
    create<T extends CharacteristicCreateArgs>(args: SelectSubset<T, CharacteristicCreateArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Characteristics.
     * @param {CharacteristicCreateManyArgs} args - Arguments to create many Characteristics.
     * @example
     * // Create many Characteristics
     * const characteristic = await prisma.characteristic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacteristicCreateManyArgs>(args?: SelectSubset<T, CharacteristicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characteristics and returns the data saved in the database.
     * @param {CharacteristicCreateManyAndReturnArgs} args - Arguments to create many Characteristics.
     * @example
     * // Create many Characteristics
     * const characteristic = await prisma.characteristic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characteristics and only return the `id`
     * const characteristicWithIdOnly = await prisma.characteristic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacteristicCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacteristicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Characteristic.
     * @param {CharacteristicDeleteArgs} args - Arguments to delete one Characteristic.
     * @example
     * // Delete one Characteristic
     * const Characteristic = await prisma.characteristic.delete({
     *   where: {
     *     // ... filter to delete one Characteristic
     *   }
     * })
     * 
     */
    delete<T extends CharacteristicDeleteArgs>(args: SelectSubset<T, CharacteristicDeleteArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Characteristic.
     * @param {CharacteristicUpdateArgs} args - Arguments to update one Characteristic.
     * @example
     * // Update one Characteristic
     * const characteristic = await prisma.characteristic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacteristicUpdateArgs>(args: SelectSubset<T, CharacteristicUpdateArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Characteristics.
     * @param {CharacteristicDeleteManyArgs} args - Arguments to filter Characteristics to delete.
     * @example
     * // Delete a few Characteristics
     * const { count } = await prisma.characteristic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacteristicDeleteManyArgs>(args?: SelectSubset<T, CharacteristicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characteristics
     * const characteristic = await prisma.characteristic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacteristicUpdateManyArgs>(args: SelectSubset<T, CharacteristicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Characteristic.
     * @param {CharacteristicUpsertArgs} args - Arguments to update or create a Characteristic.
     * @example
     * // Update or create a Characteristic
     * const characteristic = await prisma.characteristic.upsert({
     *   create: {
     *     // ... data to create a Characteristic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Characteristic we want to update
     *   }
     * })
     */
    upsert<T extends CharacteristicUpsertArgs>(args: SelectSubset<T, CharacteristicUpsertArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Characteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicCountArgs} args - Arguments to filter Characteristics to count.
     * @example
     * // Count the number of Characteristics
     * const count = await prisma.characteristic.count({
     *   where: {
     *     // ... the filter for the Characteristics we want to count
     *   }
     * })
    **/
    count<T extends CharacteristicCountArgs>(
      args?: Subset<T, CharacteristicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacteristicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Characteristic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacteristicAggregateArgs>(args: Subset<T, CharacteristicAggregateArgs>): Prisma.PrismaPromise<GetCharacteristicAggregateType<T>>

    /**
     * Group by Characteristic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacteristicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacteristicGroupByArgs['orderBy'] }
        : { orderBy?: CharacteristicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacteristicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacteristicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Characteristic model
   */
  readonly fields: CharacteristicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Characteristic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacteristicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productCharacteristics<T extends Characteristic$productCharacteristicsArgs<ExtArgs> = {}>(args?: Subset<T, Characteristic$productCharacteristicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findMany"> | Null>
    translations<T extends Characteristic$translationsArgs<ExtArgs> = {}>(args?: Subset<T, Characteristic$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Characteristic model
   */ 
  interface CharacteristicFieldRefs {
    readonly id: FieldRef<"Characteristic", 'String'>
    readonly createdAt: FieldRef<"Characteristic", 'DateTime'>
    readonly updatedAt: FieldRef<"Characteristic", 'DateTime'>
    readonly name: FieldRef<"Characteristic", 'String'>
    readonly description: FieldRef<"Characteristic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Characteristic findUnique
   */
  export type CharacteristicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristic to fetch.
     */
    where: CharacteristicWhereUniqueInput
  }

  /**
   * Characteristic findUniqueOrThrow
   */
  export type CharacteristicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristic to fetch.
     */
    where: CharacteristicWhereUniqueInput
  }

  /**
   * Characteristic findFirst
   */
  export type CharacteristicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristic to fetch.
     */
    where?: CharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicOrderByWithRelationInput | CharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characteristics.
     */
    cursor?: CharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characteristics.
     */
    distinct?: CharacteristicScalarFieldEnum | CharacteristicScalarFieldEnum[]
  }

  /**
   * Characteristic findFirstOrThrow
   */
  export type CharacteristicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristic to fetch.
     */
    where?: CharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicOrderByWithRelationInput | CharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characteristics.
     */
    cursor?: CharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characteristics.
     */
    distinct?: CharacteristicScalarFieldEnum | CharacteristicScalarFieldEnum[]
  }

  /**
   * Characteristic findMany
   */
  export type CharacteristicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which Characteristics to fetch.
     */
    where?: CharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characteristics to fetch.
     */
    orderBy?: CharacteristicOrderByWithRelationInput | CharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characteristics.
     */
    cursor?: CharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characteristics.
     */
    skip?: number
    distinct?: CharacteristicScalarFieldEnum | CharacteristicScalarFieldEnum[]
  }

  /**
   * Characteristic create
   */
  export type CharacteristicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * The data needed to create a Characteristic.
     */
    data: XOR<CharacteristicCreateInput, CharacteristicUncheckedCreateInput>
  }

  /**
   * Characteristic createMany
   */
  export type CharacteristicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characteristics.
     */
    data: CharacteristicCreateManyInput | CharacteristicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Characteristic createManyAndReturn
   */
  export type CharacteristicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Characteristics.
     */
    data: CharacteristicCreateManyInput | CharacteristicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Characteristic update
   */
  export type CharacteristicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * The data needed to update a Characteristic.
     */
    data: XOR<CharacteristicUpdateInput, CharacteristicUncheckedUpdateInput>
    /**
     * Choose, which Characteristic to update.
     */
    where: CharacteristicWhereUniqueInput
  }

  /**
   * Characteristic updateMany
   */
  export type CharacteristicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characteristics.
     */
    data: XOR<CharacteristicUpdateManyMutationInput, CharacteristicUncheckedUpdateManyInput>
    /**
     * Filter which Characteristics to update
     */
    where?: CharacteristicWhereInput
  }

  /**
   * Characteristic upsert
   */
  export type CharacteristicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * The filter to search for the Characteristic to update in case it exists.
     */
    where: CharacteristicWhereUniqueInput
    /**
     * In case the Characteristic found by the `where` argument doesn't exist, create a new Characteristic with this data.
     */
    create: XOR<CharacteristicCreateInput, CharacteristicUncheckedCreateInput>
    /**
     * In case the Characteristic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacteristicUpdateInput, CharacteristicUncheckedUpdateInput>
  }

  /**
   * Characteristic delete
   */
  export type CharacteristicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
    /**
     * Filter which Characteristic to delete.
     */
    where: CharacteristicWhereUniqueInput
  }

  /**
   * Characteristic deleteMany
   */
  export type CharacteristicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characteristics to delete
     */
    where?: CharacteristicWhereInput
  }

  /**
   * Characteristic.productCharacteristics
   */
  export type Characteristic$productCharacteristicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    where?: ProductCharacteristicWhereInput
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    cursor?: ProductCharacteristicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * Characteristic.translations
   */
  export type Characteristic$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    where?: CharacteristicTranslationWhereInput
    orderBy?: CharacteristicTranslationOrderByWithRelationInput | CharacteristicTranslationOrderByWithRelationInput[]
    cursor?: CharacteristicTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacteristicTranslationScalarFieldEnum | CharacteristicTranslationScalarFieldEnum[]
  }

  /**
   * Characteristic without action
   */
  export type CharacteristicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Characteristic
     */
    select?: CharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicInclude<ExtArgs> | null
  }


  /**
   * Model CharacteristicTranslation
   */

  export type AggregateCharacteristicTranslation = {
    _count: CharacteristicTranslationCountAggregateOutputType | null
    _min: CharacteristicTranslationMinAggregateOutputType | null
    _max: CharacteristicTranslationMaxAggregateOutputType | null
  }

  export type CharacteristicTranslationMinAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    languageCode: string | null
    name: string | null
    characteristicId: string | null
  }

  export type CharacteristicTranslationMaxAggregateOutputType = {
    id: string | null
    createAt: Date | null
    updateAt: Date | null
    languageCode: string | null
    name: string | null
    characteristicId: string | null
  }

  export type CharacteristicTranslationCountAggregateOutputType = {
    id: number
    createAt: number
    updateAt: number
    languageCode: number
    name: number
    characteristicId: number
    _all: number
  }


  export type CharacteristicTranslationMinAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    languageCode?: true
    name?: true
    characteristicId?: true
  }

  export type CharacteristicTranslationMaxAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    languageCode?: true
    name?: true
    characteristicId?: true
  }

  export type CharacteristicTranslationCountAggregateInputType = {
    id?: true
    createAt?: true
    updateAt?: true
    languageCode?: true
    name?: true
    characteristicId?: true
    _all?: true
  }

  export type CharacteristicTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacteristicTranslation to aggregate.
     */
    where?: CharacteristicTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicTranslations to fetch.
     */
    orderBy?: CharacteristicTranslationOrderByWithRelationInput | CharacteristicTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacteristicTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacteristicTranslations
    **/
    _count?: true | CharacteristicTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacteristicTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacteristicTranslationMaxAggregateInputType
  }

  export type GetCharacteristicTranslationAggregateType<T extends CharacteristicTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacteristicTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacteristicTranslation[P]>
      : GetScalarType<T[P], AggregateCharacteristicTranslation[P]>
  }




  export type CharacteristicTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacteristicTranslationWhereInput
    orderBy?: CharacteristicTranslationOrderByWithAggregationInput | CharacteristicTranslationOrderByWithAggregationInput[]
    by: CharacteristicTranslationScalarFieldEnum[] | CharacteristicTranslationScalarFieldEnum
    having?: CharacteristicTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacteristicTranslationCountAggregateInputType | true
    _min?: CharacteristicTranslationMinAggregateInputType
    _max?: CharacteristicTranslationMaxAggregateInputType
  }

  export type CharacteristicTranslationGroupByOutputType = {
    id: string
    createAt: Date
    updateAt: Date
    languageCode: string
    name: string
    characteristicId: string
    _count: CharacteristicTranslationCountAggregateOutputType | null
    _min: CharacteristicTranslationMinAggregateOutputType | null
    _max: CharacteristicTranslationMaxAggregateOutputType | null
  }

  type GetCharacteristicTranslationGroupByPayload<T extends CharacteristicTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacteristicTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacteristicTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacteristicTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], CharacteristicTranslationGroupByOutputType[P]>
        }
      >
    >


  export type CharacteristicTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    languageCode?: boolean
    name?: boolean
    characteristicId?: boolean
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristicTranslation"]>

  export type CharacteristicTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    languageCode?: boolean
    name?: boolean
    characteristicId?: boolean
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characteristicTranslation"]>

  export type CharacteristicTranslationSelectScalar = {
    id?: boolean
    createAt?: boolean
    updateAt?: boolean
    languageCode?: boolean
    name?: boolean
    characteristicId?: boolean
  }

  export type CharacteristicTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }
  export type CharacteristicTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }

  export type $CharacteristicTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacteristicTranslation"
    objects: {
      characteristic: Prisma.$CharacteristicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createAt: Date
      updateAt: Date
      languageCode: string
      name: string
      characteristicId: string
    }, ExtArgs["result"]["characteristicTranslation"]>
    composites: {}
  }

  type CharacteristicTranslationGetPayload<S extends boolean | null | undefined | CharacteristicTranslationDefaultArgs> = $Result.GetResult<Prisma.$CharacteristicTranslationPayload, S>

  type CharacteristicTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacteristicTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacteristicTranslationCountAggregateInputType | true
    }

  export interface CharacteristicTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacteristicTranslation'], meta: { name: 'CharacteristicTranslation' } }
    /**
     * Find zero or one CharacteristicTranslation that matches the filter.
     * @param {CharacteristicTranslationFindUniqueArgs} args - Arguments to find a CharacteristicTranslation
     * @example
     * // Get one CharacteristicTranslation
     * const characteristicTranslation = await prisma.characteristicTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacteristicTranslationFindUniqueArgs>(args: SelectSubset<T, CharacteristicTranslationFindUniqueArgs<ExtArgs>>): Prisma__CharacteristicTranslationClient<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CharacteristicTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacteristicTranslationFindUniqueOrThrowArgs} args - Arguments to find a CharacteristicTranslation
     * @example
     * // Get one CharacteristicTranslation
     * const characteristicTranslation = await prisma.characteristicTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacteristicTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacteristicTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacteristicTranslationClient<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CharacteristicTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicTranslationFindFirstArgs} args - Arguments to find a CharacteristicTranslation
     * @example
     * // Get one CharacteristicTranslation
     * const characteristicTranslation = await prisma.characteristicTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacteristicTranslationFindFirstArgs>(args?: SelectSubset<T, CharacteristicTranslationFindFirstArgs<ExtArgs>>): Prisma__CharacteristicTranslationClient<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CharacteristicTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicTranslationFindFirstOrThrowArgs} args - Arguments to find a CharacteristicTranslation
     * @example
     * // Get one CharacteristicTranslation
     * const characteristicTranslation = await prisma.characteristicTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacteristicTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacteristicTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacteristicTranslationClient<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CharacteristicTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacteristicTranslations
     * const characteristicTranslations = await prisma.characteristicTranslation.findMany()
     * 
     * // Get first 10 CharacteristicTranslations
     * const characteristicTranslations = await prisma.characteristicTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characteristicTranslationWithIdOnly = await prisma.characteristicTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacteristicTranslationFindManyArgs>(args?: SelectSubset<T, CharacteristicTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CharacteristicTranslation.
     * @param {CharacteristicTranslationCreateArgs} args - Arguments to create a CharacteristicTranslation.
     * @example
     * // Create one CharacteristicTranslation
     * const CharacteristicTranslation = await prisma.characteristicTranslation.create({
     *   data: {
     *     // ... data to create a CharacteristicTranslation
     *   }
     * })
     * 
     */
    create<T extends CharacteristicTranslationCreateArgs>(args: SelectSubset<T, CharacteristicTranslationCreateArgs<ExtArgs>>): Prisma__CharacteristicTranslationClient<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CharacteristicTranslations.
     * @param {CharacteristicTranslationCreateManyArgs} args - Arguments to create many CharacteristicTranslations.
     * @example
     * // Create many CharacteristicTranslations
     * const characteristicTranslation = await prisma.characteristicTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacteristicTranslationCreateManyArgs>(args?: SelectSubset<T, CharacteristicTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacteristicTranslations and returns the data saved in the database.
     * @param {CharacteristicTranslationCreateManyAndReturnArgs} args - Arguments to create many CharacteristicTranslations.
     * @example
     * // Create many CharacteristicTranslations
     * const characteristicTranslation = await prisma.characteristicTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacteristicTranslations and only return the `id`
     * const characteristicTranslationWithIdOnly = await prisma.characteristicTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacteristicTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacteristicTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CharacteristicTranslation.
     * @param {CharacteristicTranslationDeleteArgs} args - Arguments to delete one CharacteristicTranslation.
     * @example
     * // Delete one CharacteristicTranslation
     * const CharacteristicTranslation = await prisma.characteristicTranslation.delete({
     *   where: {
     *     // ... filter to delete one CharacteristicTranslation
     *   }
     * })
     * 
     */
    delete<T extends CharacteristicTranslationDeleteArgs>(args: SelectSubset<T, CharacteristicTranslationDeleteArgs<ExtArgs>>): Prisma__CharacteristicTranslationClient<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CharacteristicTranslation.
     * @param {CharacteristicTranslationUpdateArgs} args - Arguments to update one CharacteristicTranslation.
     * @example
     * // Update one CharacteristicTranslation
     * const characteristicTranslation = await prisma.characteristicTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacteristicTranslationUpdateArgs>(args: SelectSubset<T, CharacteristicTranslationUpdateArgs<ExtArgs>>): Prisma__CharacteristicTranslationClient<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CharacteristicTranslations.
     * @param {CharacteristicTranslationDeleteManyArgs} args - Arguments to filter CharacteristicTranslations to delete.
     * @example
     * // Delete a few CharacteristicTranslations
     * const { count } = await prisma.characteristicTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacteristicTranslationDeleteManyArgs>(args?: SelectSubset<T, CharacteristicTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacteristicTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacteristicTranslations
     * const characteristicTranslation = await prisma.characteristicTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacteristicTranslationUpdateManyArgs>(args: SelectSubset<T, CharacteristicTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CharacteristicTranslation.
     * @param {CharacteristicTranslationUpsertArgs} args - Arguments to update or create a CharacteristicTranslation.
     * @example
     * // Update or create a CharacteristicTranslation
     * const characteristicTranslation = await prisma.characteristicTranslation.upsert({
     *   create: {
     *     // ... data to create a CharacteristicTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacteristicTranslation we want to update
     *   }
     * })
     */
    upsert<T extends CharacteristicTranslationUpsertArgs>(args: SelectSubset<T, CharacteristicTranslationUpsertArgs<ExtArgs>>): Prisma__CharacteristicTranslationClient<$Result.GetResult<Prisma.$CharacteristicTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CharacteristicTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicTranslationCountArgs} args - Arguments to filter CharacteristicTranslations to count.
     * @example
     * // Count the number of CharacteristicTranslations
     * const count = await prisma.characteristicTranslation.count({
     *   where: {
     *     // ... the filter for the CharacteristicTranslations we want to count
     *   }
     * })
    **/
    count<T extends CharacteristicTranslationCountArgs>(
      args?: Subset<T, CharacteristicTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacteristicTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacteristicTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacteristicTranslationAggregateArgs>(args: Subset<T, CharacteristicTranslationAggregateArgs>): Prisma.PrismaPromise<GetCharacteristicTranslationAggregateType<T>>

    /**
     * Group by CharacteristicTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacteristicTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacteristicTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacteristicTranslationGroupByArgs['orderBy'] }
        : { orderBy?: CharacteristicTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacteristicTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacteristicTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacteristicTranslation model
   */
  readonly fields: CharacteristicTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacteristicTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacteristicTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characteristic<T extends CharacteristicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacteristicDefaultArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacteristicTranslation model
   */ 
  interface CharacteristicTranslationFieldRefs {
    readonly id: FieldRef<"CharacteristicTranslation", 'String'>
    readonly createAt: FieldRef<"CharacteristicTranslation", 'DateTime'>
    readonly updateAt: FieldRef<"CharacteristicTranslation", 'DateTime'>
    readonly languageCode: FieldRef<"CharacteristicTranslation", 'String'>
    readonly name: FieldRef<"CharacteristicTranslation", 'String'>
    readonly characteristicId: FieldRef<"CharacteristicTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CharacteristicTranslation findUnique
   */
  export type CharacteristicTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicTranslation to fetch.
     */
    where: CharacteristicTranslationWhereUniqueInput
  }

  /**
   * CharacteristicTranslation findUniqueOrThrow
   */
  export type CharacteristicTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicTranslation to fetch.
     */
    where: CharacteristicTranslationWhereUniqueInput
  }

  /**
   * CharacteristicTranslation findFirst
   */
  export type CharacteristicTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicTranslation to fetch.
     */
    where?: CharacteristicTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicTranslations to fetch.
     */
    orderBy?: CharacteristicTranslationOrderByWithRelationInput | CharacteristicTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacteristicTranslations.
     */
    cursor?: CharacteristicTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacteristicTranslations.
     */
    distinct?: CharacteristicTranslationScalarFieldEnum | CharacteristicTranslationScalarFieldEnum[]
  }

  /**
   * CharacteristicTranslation findFirstOrThrow
   */
  export type CharacteristicTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicTranslation to fetch.
     */
    where?: CharacteristicTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicTranslations to fetch.
     */
    orderBy?: CharacteristicTranslationOrderByWithRelationInput | CharacteristicTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacteristicTranslations.
     */
    cursor?: CharacteristicTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacteristicTranslations.
     */
    distinct?: CharacteristicTranslationScalarFieldEnum | CharacteristicTranslationScalarFieldEnum[]
  }

  /**
   * CharacteristicTranslation findMany
   */
  export type CharacteristicTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which CharacteristicTranslations to fetch.
     */
    where?: CharacteristicTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacteristicTranslations to fetch.
     */
    orderBy?: CharacteristicTranslationOrderByWithRelationInput | CharacteristicTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacteristicTranslations.
     */
    cursor?: CharacteristicTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacteristicTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacteristicTranslations.
     */
    skip?: number
    distinct?: CharacteristicTranslationScalarFieldEnum | CharacteristicTranslationScalarFieldEnum[]
  }

  /**
   * CharacteristicTranslation create
   */
  export type CharacteristicTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacteristicTranslation.
     */
    data: XOR<CharacteristicTranslationCreateInput, CharacteristicTranslationUncheckedCreateInput>
  }

  /**
   * CharacteristicTranslation createMany
   */
  export type CharacteristicTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacteristicTranslations.
     */
    data: CharacteristicTranslationCreateManyInput | CharacteristicTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharacteristicTranslation createManyAndReturn
   */
  export type CharacteristicTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CharacteristicTranslations.
     */
    data: CharacteristicTranslationCreateManyInput | CharacteristicTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacteristicTranslation update
   */
  export type CharacteristicTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacteristicTranslation.
     */
    data: XOR<CharacteristicTranslationUpdateInput, CharacteristicTranslationUncheckedUpdateInput>
    /**
     * Choose, which CharacteristicTranslation to update.
     */
    where: CharacteristicTranslationWhereUniqueInput
  }

  /**
   * CharacteristicTranslation updateMany
   */
  export type CharacteristicTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacteristicTranslations.
     */
    data: XOR<CharacteristicTranslationUpdateManyMutationInput, CharacteristicTranslationUncheckedUpdateManyInput>
    /**
     * Filter which CharacteristicTranslations to update
     */
    where?: CharacteristicTranslationWhereInput
  }

  /**
   * CharacteristicTranslation upsert
   */
  export type CharacteristicTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacteristicTranslation to update in case it exists.
     */
    where: CharacteristicTranslationWhereUniqueInput
    /**
     * In case the CharacteristicTranslation found by the `where` argument doesn't exist, create a new CharacteristicTranslation with this data.
     */
    create: XOR<CharacteristicTranslationCreateInput, CharacteristicTranslationUncheckedCreateInput>
    /**
     * In case the CharacteristicTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacteristicTranslationUpdateInput, CharacteristicTranslationUncheckedUpdateInput>
  }

  /**
   * CharacteristicTranslation delete
   */
  export type CharacteristicTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter which CharacteristicTranslation to delete.
     */
    where: CharacteristicTranslationWhereUniqueInput
  }

  /**
   * CharacteristicTranslation deleteMany
   */
  export type CharacteristicTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacteristicTranslations to delete
     */
    where?: CharacteristicTranslationWhereInput
  }

  /**
   * CharacteristicTranslation without action
   */
  export type CharacteristicTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacteristicTranslation
     */
    select?: CharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacteristicTranslationInclude<ExtArgs> | null
  }


  /**
   * Model ProductCharacteristic
   */

  export type AggregateProductCharacteristic = {
    _count: ProductCharacteristicCountAggregateOutputType | null
    _min: ProductCharacteristicMinAggregateOutputType | null
    _max: ProductCharacteristicMaxAggregateOutputType | null
  }

  export type ProductCharacteristicMinAggregateOutputType = {
    id: string | null
    productId: string | null
    characteristicId: string | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type ProductCharacteristicMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    characteristicId: string | null
    name: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type ProductCharacteristicCountAggregateOutputType = {
    id: number
    productId: number
    characteristicId: number
    name: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type ProductCharacteristicMinAggregateInputType = {
    id?: true
    productId?: true
    characteristicId?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type ProductCharacteristicMaxAggregateInputType = {
    id?: true
    productId?: true
    characteristicId?: true
    name?: true
    createAt?: true
    updateAt?: true
  }

  export type ProductCharacteristicCountAggregateInputType = {
    id?: true
    productId?: true
    characteristicId?: true
    name?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type ProductCharacteristicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCharacteristic to aggregate.
     */
    where?: ProductCharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristics to fetch.
     */
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCharacteristics
    **/
    _count?: true | ProductCharacteristicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCharacteristicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCharacteristicMaxAggregateInputType
  }

  export type GetProductCharacteristicAggregateType<T extends ProductCharacteristicAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCharacteristic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCharacteristic[P]>
      : GetScalarType<T[P], AggregateProductCharacteristic[P]>
  }




  export type ProductCharacteristicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCharacteristicWhereInput
    orderBy?: ProductCharacteristicOrderByWithAggregationInput | ProductCharacteristicOrderByWithAggregationInput[]
    by: ProductCharacteristicScalarFieldEnum[] | ProductCharacteristicScalarFieldEnum
    having?: ProductCharacteristicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCharacteristicCountAggregateInputType | true
    _min?: ProductCharacteristicMinAggregateInputType
    _max?: ProductCharacteristicMaxAggregateInputType
  }

  export type ProductCharacteristicGroupByOutputType = {
    id: string
    productId: string
    characteristicId: string
    name: string
    createAt: Date
    updateAt: Date
    _count: ProductCharacteristicCountAggregateOutputType | null
    _min: ProductCharacteristicMinAggregateOutputType | null
    _max: ProductCharacteristicMaxAggregateOutputType | null
  }

  type GetProductCharacteristicGroupByPayload<T extends ProductCharacteristicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCharacteristicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCharacteristicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCharacteristicGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCharacteristicGroupByOutputType[P]>
        }
      >
    >


  export type ProductCharacteristicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    characteristicId?: boolean
    name?: boolean
    createAt?: boolean
    updateAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    translations?: boolean | ProductCharacteristic$translationsArgs<ExtArgs>
    _count?: boolean | ProductCharacteristicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCharacteristic"]>

  export type ProductCharacteristicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    characteristicId?: boolean
    name?: boolean
    createAt?: boolean
    updateAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCharacteristic"]>

  export type ProductCharacteristicSelectScalar = {
    id?: boolean
    productId?: boolean
    characteristicId?: boolean
    name?: boolean
    createAt?: boolean
    updateAt?: boolean
  }

  export type ProductCharacteristicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
    translations?: boolean | ProductCharacteristic$translationsArgs<ExtArgs>
    _count?: boolean | ProductCharacteristicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductCharacteristicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    characteristic?: boolean | CharacteristicDefaultArgs<ExtArgs>
  }

  export type $ProductCharacteristicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCharacteristic"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      characteristic: Prisma.$CharacteristicPayload<ExtArgs>
      translations: Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      characteristicId: string
      name: string
      createAt: Date
      updateAt: Date
    }, ExtArgs["result"]["productCharacteristic"]>
    composites: {}
  }

  type ProductCharacteristicGetPayload<S extends boolean | null | undefined | ProductCharacteristicDefaultArgs> = $Result.GetResult<Prisma.$ProductCharacteristicPayload, S>

  type ProductCharacteristicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductCharacteristicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCharacteristicCountAggregateInputType | true
    }

  export interface ProductCharacteristicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCharacteristic'], meta: { name: 'ProductCharacteristic' } }
    /**
     * Find zero or one ProductCharacteristic that matches the filter.
     * @param {ProductCharacteristicFindUniqueArgs} args - Arguments to find a ProductCharacteristic
     * @example
     * // Get one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCharacteristicFindUniqueArgs>(args: SelectSubset<T, ProductCharacteristicFindUniqueArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductCharacteristic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductCharacteristicFindUniqueOrThrowArgs} args - Arguments to find a ProductCharacteristic
     * @example
     * // Get one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCharacteristicFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCharacteristicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductCharacteristic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicFindFirstArgs} args - Arguments to find a ProductCharacteristic
     * @example
     * // Get one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCharacteristicFindFirstArgs>(args?: SelectSubset<T, ProductCharacteristicFindFirstArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductCharacteristic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicFindFirstOrThrowArgs} args - Arguments to find a ProductCharacteristic
     * @example
     * // Get one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCharacteristicFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCharacteristicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductCharacteristics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCharacteristics
     * const productCharacteristics = await prisma.productCharacteristic.findMany()
     * 
     * // Get first 10 ProductCharacteristics
     * const productCharacteristics = await prisma.productCharacteristic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCharacteristicWithIdOnly = await prisma.productCharacteristic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCharacteristicFindManyArgs>(args?: SelectSubset<T, ProductCharacteristicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductCharacteristic.
     * @param {ProductCharacteristicCreateArgs} args - Arguments to create a ProductCharacteristic.
     * @example
     * // Create one ProductCharacteristic
     * const ProductCharacteristic = await prisma.productCharacteristic.create({
     *   data: {
     *     // ... data to create a ProductCharacteristic
     *   }
     * })
     * 
     */
    create<T extends ProductCharacteristicCreateArgs>(args: SelectSubset<T, ProductCharacteristicCreateArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductCharacteristics.
     * @param {ProductCharacteristicCreateManyArgs} args - Arguments to create many ProductCharacteristics.
     * @example
     * // Create many ProductCharacteristics
     * const productCharacteristic = await prisma.productCharacteristic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCharacteristicCreateManyArgs>(args?: SelectSubset<T, ProductCharacteristicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCharacteristics and returns the data saved in the database.
     * @param {ProductCharacteristicCreateManyAndReturnArgs} args - Arguments to create many ProductCharacteristics.
     * @example
     * // Create many ProductCharacteristics
     * const productCharacteristic = await prisma.productCharacteristic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCharacteristics and only return the `id`
     * const productCharacteristicWithIdOnly = await prisma.productCharacteristic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCharacteristicCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCharacteristicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductCharacteristic.
     * @param {ProductCharacteristicDeleteArgs} args - Arguments to delete one ProductCharacteristic.
     * @example
     * // Delete one ProductCharacteristic
     * const ProductCharacteristic = await prisma.productCharacteristic.delete({
     *   where: {
     *     // ... filter to delete one ProductCharacteristic
     *   }
     * })
     * 
     */
    delete<T extends ProductCharacteristicDeleteArgs>(args: SelectSubset<T, ProductCharacteristicDeleteArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductCharacteristic.
     * @param {ProductCharacteristicUpdateArgs} args - Arguments to update one ProductCharacteristic.
     * @example
     * // Update one ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCharacteristicUpdateArgs>(args: SelectSubset<T, ProductCharacteristicUpdateArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductCharacteristics.
     * @param {ProductCharacteristicDeleteManyArgs} args - Arguments to filter ProductCharacteristics to delete.
     * @example
     * // Delete a few ProductCharacteristics
     * const { count } = await prisma.productCharacteristic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCharacteristicDeleteManyArgs>(args?: SelectSubset<T, ProductCharacteristicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCharacteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCharacteristics
     * const productCharacteristic = await prisma.productCharacteristic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCharacteristicUpdateManyArgs>(args: SelectSubset<T, ProductCharacteristicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCharacteristic.
     * @param {ProductCharacteristicUpsertArgs} args - Arguments to update or create a ProductCharacteristic.
     * @example
     * // Update or create a ProductCharacteristic
     * const productCharacteristic = await prisma.productCharacteristic.upsert({
     *   create: {
     *     // ... data to create a ProductCharacteristic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCharacteristic we want to update
     *   }
     * })
     */
    upsert<T extends ProductCharacteristicUpsertArgs>(args: SelectSubset<T, ProductCharacteristicUpsertArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductCharacteristics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicCountArgs} args - Arguments to filter ProductCharacteristics to count.
     * @example
     * // Count the number of ProductCharacteristics
     * const count = await prisma.productCharacteristic.count({
     *   where: {
     *     // ... the filter for the ProductCharacteristics we want to count
     *   }
     * })
    **/
    count<T extends ProductCharacteristicCountArgs>(
      args?: Subset<T, ProductCharacteristicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCharacteristicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCharacteristic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCharacteristicAggregateArgs>(args: Subset<T, ProductCharacteristicAggregateArgs>): Prisma.PrismaPromise<GetProductCharacteristicAggregateType<T>>

    /**
     * Group by ProductCharacteristic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCharacteristicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCharacteristicGroupByArgs['orderBy'] }
        : { orderBy?: ProductCharacteristicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCharacteristicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCharacteristicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCharacteristic model
   */
  readonly fields: ProductCharacteristicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCharacteristic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCharacteristicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    characteristic<T extends CharacteristicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacteristicDefaultArgs<ExtArgs>>): Prisma__CharacteristicClient<$Result.GetResult<Prisma.$CharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    translations<T extends ProductCharacteristic$translationsArgs<ExtArgs> = {}>(args?: Subset<T, ProductCharacteristic$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCharacteristic model
   */ 
  interface ProductCharacteristicFieldRefs {
    readonly id: FieldRef<"ProductCharacteristic", 'String'>
    readonly productId: FieldRef<"ProductCharacteristic", 'String'>
    readonly characteristicId: FieldRef<"ProductCharacteristic", 'String'>
    readonly name: FieldRef<"ProductCharacteristic", 'String'>
    readonly createAt: FieldRef<"ProductCharacteristic", 'DateTime'>
    readonly updateAt: FieldRef<"ProductCharacteristic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductCharacteristic findUnique
   */
  export type ProductCharacteristicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristic to fetch.
     */
    where: ProductCharacteristicWhereUniqueInput
  }

  /**
   * ProductCharacteristic findUniqueOrThrow
   */
  export type ProductCharacteristicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristic to fetch.
     */
    where: ProductCharacteristicWhereUniqueInput
  }

  /**
   * ProductCharacteristic findFirst
   */
  export type ProductCharacteristicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristic to fetch.
     */
    where?: ProductCharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristics to fetch.
     */
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCharacteristics.
     */
    cursor?: ProductCharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCharacteristics.
     */
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * ProductCharacteristic findFirstOrThrow
   */
  export type ProductCharacteristicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristic to fetch.
     */
    where?: ProductCharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristics to fetch.
     */
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCharacteristics.
     */
    cursor?: ProductCharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCharacteristics.
     */
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * ProductCharacteristic findMany
   */
  export type ProductCharacteristicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristics to fetch.
     */
    where?: ProductCharacteristicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristics to fetch.
     */
    orderBy?: ProductCharacteristicOrderByWithRelationInput | ProductCharacteristicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCharacteristics.
     */
    cursor?: ProductCharacteristicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristics.
     */
    skip?: number
    distinct?: ProductCharacteristicScalarFieldEnum | ProductCharacteristicScalarFieldEnum[]
  }

  /**
   * ProductCharacteristic create
   */
  export type ProductCharacteristicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCharacteristic.
     */
    data: XOR<ProductCharacteristicCreateInput, ProductCharacteristicUncheckedCreateInput>
  }

  /**
   * ProductCharacteristic createMany
   */
  export type ProductCharacteristicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCharacteristics.
     */
    data: ProductCharacteristicCreateManyInput | ProductCharacteristicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCharacteristic createManyAndReturn
   */
  export type ProductCharacteristicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductCharacteristics.
     */
    data: ProductCharacteristicCreateManyInput | ProductCharacteristicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCharacteristic update
   */
  export type ProductCharacteristicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCharacteristic.
     */
    data: XOR<ProductCharacteristicUpdateInput, ProductCharacteristicUncheckedUpdateInput>
    /**
     * Choose, which ProductCharacteristic to update.
     */
    where: ProductCharacteristicWhereUniqueInput
  }

  /**
   * ProductCharacteristic updateMany
   */
  export type ProductCharacteristicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCharacteristics.
     */
    data: XOR<ProductCharacteristicUpdateManyMutationInput, ProductCharacteristicUncheckedUpdateManyInput>
    /**
     * Filter which ProductCharacteristics to update
     */
    where?: ProductCharacteristicWhereInput
  }

  /**
   * ProductCharacteristic upsert
   */
  export type ProductCharacteristicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCharacteristic to update in case it exists.
     */
    where: ProductCharacteristicWhereUniqueInput
    /**
     * In case the ProductCharacteristic found by the `where` argument doesn't exist, create a new ProductCharacteristic with this data.
     */
    create: XOR<ProductCharacteristicCreateInput, ProductCharacteristicUncheckedCreateInput>
    /**
     * In case the ProductCharacteristic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCharacteristicUpdateInput, ProductCharacteristicUncheckedUpdateInput>
  }

  /**
   * ProductCharacteristic delete
   */
  export type ProductCharacteristicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
    /**
     * Filter which ProductCharacteristic to delete.
     */
    where: ProductCharacteristicWhereUniqueInput
  }

  /**
   * ProductCharacteristic deleteMany
   */
  export type ProductCharacteristicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCharacteristics to delete
     */
    where?: ProductCharacteristicWhereInput
  }

  /**
   * ProductCharacteristic.translations
   */
  export type ProductCharacteristic$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    where?: ProductCharacteristicTranslationWhereInput
    orderBy?: ProductCharacteristicTranslationOrderByWithRelationInput | ProductCharacteristicTranslationOrderByWithRelationInput[]
    cursor?: ProductCharacteristicTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductCharacteristicTranslationScalarFieldEnum | ProductCharacteristicTranslationScalarFieldEnum[]
  }

  /**
   * ProductCharacteristic without action
   */
  export type ProductCharacteristicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristic
     */
    select?: ProductCharacteristicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicInclude<ExtArgs> | null
  }


  /**
   * Model ProductCharacteristicTranslation
   */

  export type AggregateProductCharacteristicTranslation = {
    _count: ProductCharacteristicTranslationCountAggregateOutputType | null
    _min: ProductCharacteristicTranslationMinAggregateOutputType | null
    _max: ProductCharacteristicTranslationMaxAggregateOutputType | null
  }

  export type ProductCharacteristicTranslationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    languageCode: string | null
    description: string | null
    productCharacteristicId: string | null
  }

  export type ProductCharacteristicTranslationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    languageCode: string | null
    description: string | null
    productCharacteristicId: string | null
  }

  export type ProductCharacteristicTranslationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    languageCode: number
    description: number
    productCharacteristicId: number
    _all: number
  }


  export type ProductCharacteristicTranslationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    languageCode?: true
    description?: true
    productCharacteristicId?: true
  }

  export type ProductCharacteristicTranslationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    languageCode?: true
    description?: true
    productCharacteristicId?: true
  }

  export type ProductCharacteristicTranslationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    languageCode?: true
    description?: true
    productCharacteristicId?: true
    _all?: true
  }

  export type ProductCharacteristicTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCharacteristicTranslation to aggregate.
     */
    where?: ProductCharacteristicTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristicTranslations to fetch.
     */
    orderBy?: ProductCharacteristicTranslationOrderByWithRelationInput | ProductCharacteristicTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductCharacteristicTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristicTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristicTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductCharacteristicTranslations
    **/
    _count?: true | ProductCharacteristicTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductCharacteristicTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductCharacteristicTranslationMaxAggregateInputType
  }

  export type GetProductCharacteristicTranslationAggregateType<T extends ProductCharacteristicTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateProductCharacteristicTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductCharacteristicTranslation[P]>
      : GetScalarType<T[P], AggregateProductCharacteristicTranslation[P]>
  }




  export type ProductCharacteristicTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductCharacteristicTranslationWhereInput
    orderBy?: ProductCharacteristicTranslationOrderByWithAggregationInput | ProductCharacteristicTranslationOrderByWithAggregationInput[]
    by: ProductCharacteristicTranslationScalarFieldEnum[] | ProductCharacteristicTranslationScalarFieldEnum
    having?: ProductCharacteristicTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCharacteristicTranslationCountAggregateInputType | true
    _min?: ProductCharacteristicTranslationMinAggregateInputType
    _max?: ProductCharacteristicTranslationMaxAggregateInputType
  }

  export type ProductCharacteristicTranslationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    languageCode: string
    description: string
    productCharacteristicId: string
    _count: ProductCharacteristicTranslationCountAggregateOutputType | null
    _min: ProductCharacteristicTranslationMinAggregateOutputType | null
    _max: ProductCharacteristicTranslationMaxAggregateOutputType | null
  }

  type GetProductCharacteristicTranslationGroupByPayload<T extends ProductCharacteristicTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductCharacteristicTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductCharacteristicTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductCharacteristicTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ProductCharacteristicTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ProductCharacteristicTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    languageCode?: boolean
    description?: boolean
    productCharacteristicId?: boolean
    productCharacteristic?: boolean | ProductCharacteristicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCharacteristicTranslation"]>

  export type ProductCharacteristicTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    languageCode?: boolean
    description?: boolean
    productCharacteristicId?: boolean
    productCharacteristic?: boolean | ProductCharacteristicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productCharacteristicTranslation"]>

  export type ProductCharacteristicTranslationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    languageCode?: boolean
    description?: boolean
    productCharacteristicId?: boolean
  }

  export type ProductCharacteristicTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productCharacteristic?: boolean | ProductCharacteristicDefaultArgs<ExtArgs>
  }
  export type ProductCharacteristicTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productCharacteristic?: boolean | ProductCharacteristicDefaultArgs<ExtArgs>
  }

  export type $ProductCharacteristicTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductCharacteristicTranslation"
    objects: {
      productCharacteristic: Prisma.$ProductCharacteristicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      languageCode: string
      description: string
      productCharacteristicId: string
    }, ExtArgs["result"]["productCharacteristicTranslation"]>
    composites: {}
  }

  type ProductCharacteristicTranslationGetPayload<S extends boolean | null | undefined | ProductCharacteristicTranslationDefaultArgs> = $Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload, S>

  type ProductCharacteristicTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductCharacteristicTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCharacteristicTranslationCountAggregateInputType | true
    }

  export interface ProductCharacteristicTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductCharacteristicTranslation'], meta: { name: 'ProductCharacteristicTranslation' } }
    /**
     * Find zero or one ProductCharacteristicTranslation that matches the filter.
     * @param {ProductCharacteristicTranslationFindUniqueArgs} args - Arguments to find a ProductCharacteristicTranslation
     * @example
     * // Get one ProductCharacteristicTranslation
     * const productCharacteristicTranslation = await prisma.productCharacteristicTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductCharacteristicTranslationFindUniqueArgs>(args: SelectSubset<T, ProductCharacteristicTranslationFindUniqueArgs<ExtArgs>>): Prisma__ProductCharacteristicTranslationClient<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductCharacteristicTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductCharacteristicTranslationFindUniqueOrThrowArgs} args - Arguments to find a ProductCharacteristicTranslation
     * @example
     * // Get one ProductCharacteristicTranslation
     * const productCharacteristicTranslation = await prisma.productCharacteristicTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductCharacteristicTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductCharacteristicTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductCharacteristicTranslationClient<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductCharacteristicTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicTranslationFindFirstArgs} args - Arguments to find a ProductCharacteristicTranslation
     * @example
     * // Get one ProductCharacteristicTranslation
     * const productCharacteristicTranslation = await prisma.productCharacteristicTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductCharacteristicTranslationFindFirstArgs>(args?: SelectSubset<T, ProductCharacteristicTranslationFindFirstArgs<ExtArgs>>): Prisma__ProductCharacteristicTranslationClient<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductCharacteristicTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicTranslationFindFirstOrThrowArgs} args - Arguments to find a ProductCharacteristicTranslation
     * @example
     * // Get one ProductCharacteristicTranslation
     * const productCharacteristicTranslation = await prisma.productCharacteristicTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductCharacteristicTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductCharacteristicTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductCharacteristicTranslationClient<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductCharacteristicTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductCharacteristicTranslations
     * const productCharacteristicTranslations = await prisma.productCharacteristicTranslation.findMany()
     * 
     * // Get first 10 ProductCharacteristicTranslations
     * const productCharacteristicTranslations = await prisma.productCharacteristicTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productCharacteristicTranslationWithIdOnly = await prisma.productCharacteristicTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductCharacteristicTranslationFindManyArgs>(args?: SelectSubset<T, ProductCharacteristicTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductCharacteristicTranslation.
     * @param {ProductCharacteristicTranslationCreateArgs} args - Arguments to create a ProductCharacteristicTranslation.
     * @example
     * // Create one ProductCharacteristicTranslation
     * const ProductCharacteristicTranslation = await prisma.productCharacteristicTranslation.create({
     *   data: {
     *     // ... data to create a ProductCharacteristicTranslation
     *   }
     * })
     * 
     */
    create<T extends ProductCharacteristicTranslationCreateArgs>(args: SelectSubset<T, ProductCharacteristicTranslationCreateArgs<ExtArgs>>): Prisma__ProductCharacteristicTranslationClient<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductCharacteristicTranslations.
     * @param {ProductCharacteristicTranslationCreateManyArgs} args - Arguments to create many ProductCharacteristicTranslations.
     * @example
     * // Create many ProductCharacteristicTranslations
     * const productCharacteristicTranslation = await prisma.productCharacteristicTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCharacteristicTranslationCreateManyArgs>(args?: SelectSubset<T, ProductCharacteristicTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductCharacteristicTranslations and returns the data saved in the database.
     * @param {ProductCharacteristicTranslationCreateManyAndReturnArgs} args - Arguments to create many ProductCharacteristicTranslations.
     * @example
     * // Create many ProductCharacteristicTranslations
     * const productCharacteristicTranslation = await prisma.productCharacteristicTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductCharacteristicTranslations and only return the `id`
     * const productCharacteristicTranslationWithIdOnly = await prisma.productCharacteristicTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCharacteristicTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCharacteristicTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductCharacteristicTranslation.
     * @param {ProductCharacteristicTranslationDeleteArgs} args - Arguments to delete one ProductCharacteristicTranslation.
     * @example
     * // Delete one ProductCharacteristicTranslation
     * const ProductCharacteristicTranslation = await prisma.productCharacteristicTranslation.delete({
     *   where: {
     *     // ... filter to delete one ProductCharacteristicTranslation
     *   }
     * })
     * 
     */
    delete<T extends ProductCharacteristicTranslationDeleteArgs>(args: SelectSubset<T, ProductCharacteristicTranslationDeleteArgs<ExtArgs>>): Prisma__ProductCharacteristicTranslationClient<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductCharacteristicTranslation.
     * @param {ProductCharacteristicTranslationUpdateArgs} args - Arguments to update one ProductCharacteristicTranslation.
     * @example
     * // Update one ProductCharacteristicTranslation
     * const productCharacteristicTranslation = await prisma.productCharacteristicTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductCharacteristicTranslationUpdateArgs>(args: SelectSubset<T, ProductCharacteristicTranslationUpdateArgs<ExtArgs>>): Prisma__ProductCharacteristicTranslationClient<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductCharacteristicTranslations.
     * @param {ProductCharacteristicTranslationDeleteManyArgs} args - Arguments to filter ProductCharacteristicTranslations to delete.
     * @example
     * // Delete a few ProductCharacteristicTranslations
     * const { count } = await prisma.productCharacteristicTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductCharacteristicTranslationDeleteManyArgs>(args?: SelectSubset<T, ProductCharacteristicTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductCharacteristicTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductCharacteristicTranslations
     * const productCharacteristicTranslation = await prisma.productCharacteristicTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductCharacteristicTranslationUpdateManyArgs>(args: SelectSubset<T, ProductCharacteristicTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductCharacteristicTranslation.
     * @param {ProductCharacteristicTranslationUpsertArgs} args - Arguments to update or create a ProductCharacteristicTranslation.
     * @example
     * // Update or create a ProductCharacteristicTranslation
     * const productCharacteristicTranslation = await prisma.productCharacteristicTranslation.upsert({
     *   create: {
     *     // ... data to create a ProductCharacteristicTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductCharacteristicTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ProductCharacteristicTranslationUpsertArgs>(args: SelectSubset<T, ProductCharacteristicTranslationUpsertArgs<ExtArgs>>): Prisma__ProductCharacteristicTranslationClient<$Result.GetResult<Prisma.$ProductCharacteristicTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductCharacteristicTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicTranslationCountArgs} args - Arguments to filter ProductCharacteristicTranslations to count.
     * @example
     * // Count the number of ProductCharacteristicTranslations
     * const count = await prisma.productCharacteristicTranslation.count({
     *   where: {
     *     // ... the filter for the ProductCharacteristicTranslations we want to count
     *   }
     * })
    **/
    count<T extends ProductCharacteristicTranslationCountArgs>(
      args?: Subset<T, ProductCharacteristicTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCharacteristicTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductCharacteristicTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductCharacteristicTranslationAggregateArgs>(args: Subset<T, ProductCharacteristicTranslationAggregateArgs>): Prisma.PrismaPromise<GetProductCharacteristicTranslationAggregateType<T>>

    /**
     * Group by ProductCharacteristicTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCharacteristicTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductCharacteristicTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductCharacteristicTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ProductCharacteristicTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductCharacteristicTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductCharacteristicTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductCharacteristicTranslation model
   */
  readonly fields: ProductCharacteristicTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductCharacteristicTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductCharacteristicTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productCharacteristic<T extends ProductCharacteristicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductCharacteristicDefaultArgs<ExtArgs>>): Prisma__ProductCharacteristicClient<$Result.GetResult<Prisma.$ProductCharacteristicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductCharacteristicTranslation model
   */ 
  interface ProductCharacteristicTranslationFieldRefs {
    readonly id: FieldRef<"ProductCharacteristicTranslation", 'String'>
    readonly createdAt: FieldRef<"ProductCharacteristicTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductCharacteristicTranslation", 'DateTime'>
    readonly languageCode: FieldRef<"ProductCharacteristicTranslation", 'String'>
    readonly description: FieldRef<"ProductCharacteristicTranslation", 'String'>
    readonly productCharacteristicId: FieldRef<"ProductCharacteristicTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProductCharacteristicTranslation findUnique
   */
  export type ProductCharacteristicTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristicTranslation to fetch.
     */
    where: ProductCharacteristicTranslationWhereUniqueInput
  }

  /**
   * ProductCharacteristicTranslation findUniqueOrThrow
   */
  export type ProductCharacteristicTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristicTranslation to fetch.
     */
    where: ProductCharacteristicTranslationWhereUniqueInput
  }

  /**
   * ProductCharacteristicTranslation findFirst
   */
  export type ProductCharacteristicTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristicTranslation to fetch.
     */
    where?: ProductCharacteristicTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristicTranslations to fetch.
     */
    orderBy?: ProductCharacteristicTranslationOrderByWithRelationInput | ProductCharacteristicTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCharacteristicTranslations.
     */
    cursor?: ProductCharacteristicTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristicTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristicTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCharacteristicTranslations.
     */
    distinct?: ProductCharacteristicTranslationScalarFieldEnum | ProductCharacteristicTranslationScalarFieldEnum[]
  }

  /**
   * ProductCharacteristicTranslation findFirstOrThrow
   */
  export type ProductCharacteristicTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristicTranslation to fetch.
     */
    where?: ProductCharacteristicTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristicTranslations to fetch.
     */
    orderBy?: ProductCharacteristicTranslationOrderByWithRelationInput | ProductCharacteristicTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductCharacteristicTranslations.
     */
    cursor?: ProductCharacteristicTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristicTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristicTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductCharacteristicTranslations.
     */
    distinct?: ProductCharacteristicTranslationScalarFieldEnum | ProductCharacteristicTranslationScalarFieldEnum[]
  }

  /**
   * ProductCharacteristicTranslation findMany
   */
  export type ProductCharacteristicTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ProductCharacteristicTranslations to fetch.
     */
    where?: ProductCharacteristicTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductCharacteristicTranslations to fetch.
     */
    orderBy?: ProductCharacteristicTranslationOrderByWithRelationInput | ProductCharacteristicTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductCharacteristicTranslations.
     */
    cursor?: ProductCharacteristicTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductCharacteristicTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductCharacteristicTranslations.
     */
    skip?: number
    distinct?: ProductCharacteristicTranslationScalarFieldEnum | ProductCharacteristicTranslationScalarFieldEnum[]
  }

  /**
   * ProductCharacteristicTranslation create
   */
  export type ProductCharacteristicTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductCharacteristicTranslation.
     */
    data: XOR<ProductCharacteristicTranslationCreateInput, ProductCharacteristicTranslationUncheckedCreateInput>
  }

  /**
   * ProductCharacteristicTranslation createMany
   */
  export type ProductCharacteristicTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductCharacteristicTranslations.
     */
    data: ProductCharacteristicTranslationCreateManyInput | ProductCharacteristicTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductCharacteristicTranslation createManyAndReturn
   */
  export type ProductCharacteristicTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductCharacteristicTranslations.
     */
    data: ProductCharacteristicTranslationCreateManyInput | ProductCharacteristicTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductCharacteristicTranslation update
   */
  export type ProductCharacteristicTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductCharacteristicTranslation.
     */
    data: XOR<ProductCharacteristicTranslationUpdateInput, ProductCharacteristicTranslationUncheckedUpdateInput>
    /**
     * Choose, which ProductCharacteristicTranslation to update.
     */
    where: ProductCharacteristicTranslationWhereUniqueInput
  }

  /**
   * ProductCharacteristicTranslation updateMany
   */
  export type ProductCharacteristicTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductCharacteristicTranslations.
     */
    data: XOR<ProductCharacteristicTranslationUpdateManyMutationInput, ProductCharacteristicTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ProductCharacteristicTranslations to update
     */
    where?: ProductCharacteristicTranslationWhereInput
  }

  /**
   * ProductCharacteristicTranslation upsert
   */
  export type ProductCharacteristicTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductCharacteristicTranslation to update in case it exists.
     */
    where: ProductCharacteristicTranslationWhereUniqueInput
    /**
     * In case the ProductCharacteristicTranslation found by the `where` argument doesn't exist, create a new ProductCharacteristicTranslation with this data.
     */
    create: XOR<ProductCharacteristicTranslationCreateInput, ProductCharacteristicTranslationUncheckedCreateInput>
    /**
     * In case the ProductCharacteristicTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductCharacteristicTranslationUpdateInput, ProductCharacteristicTranslationUncheckedUpdateInput>
  }

  /**
   * ProductCharacteristicTranslation delete
   */
  export type ProductCharacteristicTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
    /**
     * Filter which ProductCharacteristicTranslation to delete.
     */
    where: ProductCharacteristicTranslationWhereUniqueInput
  }

  /**
   * ProductCharacteristicTranslation deleteMany
   */
  export type ProductCharacteristicTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductCharacteristicTranslations to delete
     */
    where?: ProductCharacteristicTranslationWhereInput
  }

  /**
   * ProductCharacteristicTranslation without action
   */
  export type ProductCharacteristicTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCharacteristicTranslation
     */
    select?: ProductCharacteristicTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductCharacteristicTranslationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    address: string | null
    avatar: string | null
    role: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    address: string | null
    avatar: string | null
    role: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    firstName: number
    lastName: number
    email: number
    phoneNumber: number
    address: number
    avatar: number
    role: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    address?: true
    avatar?: true
    role?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    address?: true
    avatar?: true
    role?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    address?: true
    avatar?: true
    role?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    firstName: string
    lastName: string
    email: string
    phoneNumber: string
    address: string
    avatar: string
    role: string
    password: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    address?: boolean
    avatar?: boolean
    role?: boolean
    password?: boolean
    orders?: boolean | User$ordersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    address?: boolean
    avatar?: boolean
    role?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    address?: boolean
    avatar?: boolean
    role?: boolean
    password?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | User$ordersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      firstName: string
      lastName: string
      email: string
      phoneNumber: string
      address: string
      avatar: string
      role: string
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    desc: string | null
    avtor: string | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    desc: string | null
    avtor: string | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    desc: number
    avtor: number
    _all: number
  }


  export type ReviewMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    desc?: true
    avtor?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    desc?: true
    avtor?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    desc?: true
    avtor?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    desc: string
    avtor: string
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    desc?: boolean
    avtor?: boolean
    photo?: boolean | Review$photoArgs<ExtArgs>
    translation?: boolean | Review$translationArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    desc?: boolean
    avtor?: boolean
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    desc?: boolean
    avtor?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photo?: boolean | Review$photoArgs<ExtArgs>
    translation?: boolean | Review$translationArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      photo: Prisma.$ReviewPhotoPayload<ExtArgs>[]
      translation: Prisma.$ReviewTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      desc: string
      avtor: string
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photo<T extends Review$photoArgs<ExtArgs> = {}>(args?: Subset<T, Review$photoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "findMany"> | Null>
    translation<T extends Review$translationArgs<ExtArgs> = {}>(args?: Subset<T, Review$translationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
    readonly desc: FieldRef<"Review", 'String'>
    readonly avtor: FieldRef<"Review", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review.photo
   */
  export type Review$photoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    where?: ReviewPhotoWhereInput
    orderBy?: ReviewPhotoOrderByWithRelationInput | ReviewPhotoOrderByWithRelationInput[]
    cursor?: ReviewPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewPhotoScalarFieldEnum | ReviewPhotoScalarFieldEnum[]
  }

  /**
   * Review.translation
   */
  export type Review$translationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    where?: ReviewTranslationWhereInput
    orderBy?: ReviewTranslationOrderByWithRelationInput | ReviewTranslationOrderByWithRelationInput[]
    cursor?: ReviewTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewTranslationScalarFieldEnum | ReviewTranslationScalarFieldEnum[]
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ReviewPhoto
   */

  export type AggregateReviewPhoto = {
    _count: ReviewPhotoCountAggregateOutputType | null
    _min: ReviewPhotoMinAggregateOutputType | null
    _max: ReviewPhotoMaxAggregateOutputType | null
  }

  export type ReviewPhotoMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    url: string | null
    reviewId: string | null
  }

  export type ReviewPhotoMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    url: string | null
    reviewId: string | null
  }

  export type ReviewPhotoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    url: number
    reviewId: number
    _all: number
  }


  export type ReviewPhotoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    url?: true
    reviewId?: true
  }

  export type ReviewPhotoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    url?: true
    reviewId?: true
  }

  export type ReviewPhotoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    url?: true
    reviewId?: true
    _all?: true
  }

  export type ReviewPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewPhoto to aggregate.
     */
    where?: ReviewPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewPhotos to fetch.
     */
    orderBy?: ReviewPhotoOrderByWithRelationInput | ReviewPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewPhotos
    **/
    _count?: true | ReviewPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewPhotoMaxAggregateInputType
  }

  export type GetReviewPhotoAggregateType<T extends ReviewPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewPhoto[P]>
      : GetScalarType<T[P], AggregateReviewPhoto[P]>
  }




  export type ReviewPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewPhotoWhereInput
    orderBy?: ReviewPhotoOrderByWithAggregationInput | ReviewPhotoOrderByWithAggregationInput[]
    by: ReviewPhotoScalarFieldEnum[] | ReviewPhotoScalarFieldEnum
    having?: ReviewPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewPhotoCountAggregateInputType | true
    _min?: ReviewPhotoMinAggregateInputType
    _max?: ReviewPhotoMaxAggregateInputType
  }

  export type ReviewPhotoGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    url: string
    reviewId: string
    _count: ReviewPhotoCountAggregateOutputType | null
    _min: ReviewPhotoMinAggregateOutputType | null
    _max: ReviewPhotoMaxAggregateOutputType | null
  }

  type GetReviewPhotoGroupByPayload<T extends ReviewPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewPhotoGroupByOutputType[P]>
        }
      >
    >


  export type ReviewPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    url?: boolean
    reviewId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewPhoto"]>

  export type ReviewPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    url?: boolean
    reviewId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewPhoto"]>

  export type ReviewPhotoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    url?: boolean
    reviewId?: boolean
  }

  export type ReviewPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }
  export type ReviewPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }

  export type $ReviewPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewPhoto"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      url: string
      reviewId: string
    }, ExtArgs["result"]["reviewPhoto"]>
    composites: {}
  }

  type ReviewPhotoGetPayload<S extends boolean | null | undefined | ReviewPhotoDefaultArgs> = $Result.GetResult<Prisma.$ReviewPhotoPayload, S>

  type ReviewPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewPhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewPhotoCountAggregateInputType | true
    }

  export interface ReviewPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewPhoto'], meta: { name: 'ReviewPhoto' } }
    /**
     * Find zero or one ReviewPhoto that matches the filter.
     * @param {ReviewPhotoFindUniqueArgs} args - Arguments to find a ReviewPhoto
     * @example
     * // Get one ReviewPhoto
     * const reviewPhoto = await prisma.reviewPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewPhotoFindUniqueArgs>(args: SelectSubset<T, ReviewPhotoFindUniqueArgs<ExtArgs>>): Prisma__ReviewPhotoClient<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReviewPhoto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewPhotoFindUniqueOrThrowArgs} args - Arguments to find a ReviewPhoto
     * @example
     * // Get one ReviewPhoto
     * const reviewPhoto = await prisma.reviewPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewPhotoClient<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReviewPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewPhotoFindFirstArgs} args - Arguments to find a ReviewPhoto
     * @example
     * // Get one ReviewPhoto
     * const reviewPhoto = await prisma.reviewPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewPhotoFindFirstArgs>(args?: SelectSubset<T, ReviewPhotoFindFirstArgs<ExtArgs>>): Prisma__ReviewPhotoClient<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReviewPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewPhotoFindFirstOrThrowArgs} args - Arguments to find a ReviewPhoto
     * @example
     * // Get one ReviewPhoto
     * const reviewPhoto = await prisma.reviewPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewPhotoClient<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReviewPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewPhotos
     * const reviewPhotos = await prisma.reviewPhoto.findMany()
     * 
     * // Get first 10 ReviewPhotos
     * const reviewPhotos = await prisma.reviewPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewPhotoWithIdOnly = await prisma.reviewPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewPhotoFindManyArgs>(args?: SelectSubset<T, ReviewPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReviewPhoto.
     * @param {ReviewPhotoCreateArgs} args - Arguments to create a ReviewPhoto.
     * @example
     * // Create one ReviewPhoto
     * const ReviewPhoto = await prisma.reviewPhoto.create({
     *   data: {
     *     // ... data to create a ReviewPhoto
     *   }
     * })
     * 
     */
    create<T extends ReviewPhotoCreateArgs>(args: SelectSubset<T, ReviewPhotoCreateArgs<ExtArgs>>): Prisma__ReviewPhotoClient<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReviewPhotos.
     * @param {ReviewPhotoCreateManyArgs} args - Arguments to create many ReviewPhotos.
     * @example
     * // Create many ReviewPhotos
     * const reviewPhoto = await prisma.reviewPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewPhotoCreateManyArgs>(args?: SelectSubset<T, ReviewPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewPhotos and returns the data saved in the database.
     * @param {ReviewPhotoCreateManyAndReturnArgs} args - Arguments to create many ReviewPhotos.
     * @example
     * // Create many ReviewPhotos
     * const reviewPhoto = await prisma.reviewPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewPhotos and only return the `id`
     * const reviewPhotoWithIdOnly = await prisma.reviewPhoto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReviewPhoto.
     * @param {ReviewPhotoDeleteArgs} args - Arguments to delete one ReviewPhoto.
     * @example
     * // Delete one ReviewPhoto
     * const ReviewPhoto = await prisma.reviewPhoto.delete({
     *   where: {
     *     // ... filter to delete one ReviewPhoto
     *   }
     * })
     * 
     */
    delete<T extends ReviewPhotoDeleteArgs>(args: SelectSubset<T, ReviewPhotoDeleteArgs<ExtArgs>>): Prisma__ReviewPhotoClient<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReviewPhoto.
     * @param {ReviewPhotoUpdateArgs} args - Arguments to update one ReviewPhoto.
     * @example
     * // Update one ReviewPhoto
     * const reviewPhoto = await prisma.reviewPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewPhotoUpdateArgs>(args: SelectSubset<T, ReviewPhotoUpdateArgs<ExtArgs>>): Prisma__ReviewPhotoClient<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReviewPhotos.
     * @param {ReviewPhotoDeleteManyArgs} args - Arguments to filter ReviewPhotos to delete.
     * @example
     * // Delete a few ReviewPhotos
     * const { count } = await prisma.reviewPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewPhotoDeleteManyArgs>(args?: SelectSubset<T, ReviewPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewPhotos
     * const reviewPhoto = await prisma.reviewPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewPhotoUpdateManyArgs>(args: SelectSubset<T, ReviewPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReviewPhoto.
     * @param {ReviewPhotoUpsertArgs} args - Arguments to update or create a ReviewPhoto.
     * @example
     * // Update or create a ReviewPhoto
     * const reviewPhoto = await prisma.reviewPhoto.upsert({
     *   create: {
     *     // ... data to create a ReviewPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewPhoto we want to update
     *   }
     * })
     */
    upsert<T extends ReviewPhotoUpsertArgs>(args: SelectSubset<T, ReviewPhotoUpsertArgs<ExtArgs>>): Prisma__ReviewPhotoClient<$Result.GetResult<Prisma.$ReviewPhotoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReviewPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewPhotoCountArgs} args - Arguments to filter ReviewPhotos to count.
     * @example
     * // Count the number of ReviewPhotos
     * const count = await prisma.reviewPhoto.count({
     *   where: {
     *     // ... the filter for the ReviewPhotos we want to count
     *   }
     * })
    **/
    count<T extends ReviewPhotoCountArgs>(
      args?: Subset<T, ReviewPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewPhotoAggregateArgs>(args: Subset<T, ReviewPhotoAggregateArgs>): Prisma.PrismaPromise<GetReviewPhotoAggregateType<T>>

    /**
     * Group by ReviewPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewPhotoGroupByArgs['orderBy'] }
        : { orderBy?: ReviewPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewPhoto model
   */
  readonly fields: ReviewPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewPhoto model
   */ 
  interface ReviewPhotoFieldRefs {
    readonly id: FieldRef<"ReviewPhoto", 'String'>
    readonly createdAt: FieldRef<"ReviewPhoto", 'DateTime'>
    readonly updatedAt: FieldRef<"ReviewPhoto", 'DateTime'>
    readonly url: FieldRef<"ReviewPhoto", 'String'>
    readonly reviewId: FieldRef<"ReviewPhoto", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReviewPhoto findUnique
   */
  export type ReviewPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReviewPhoto to fetch.
     */
    where: ReviewPhotoWhereUniqueInput
  }

  /**
   * ReviewPhoto findUniqueOrThrow
   */
  export type ReviewPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReviewPhoto to fetch.
     */
    where: ReviewPhotoWhereUniqueInput
  }

  /**
   * ReviewPhoto findFirst
   */
  export type ReviewPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReviewPhoto to fetch.
     */
    where?: ReviewPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewPhotos to fetch.
     */
    orderBy?: ReviewPhotoOrderByWithRelationInput | ReviewPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewPhotos.
     */
    cursor?: ReviewPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewPhotos.
     */
    distinct?: ReviewPhotoScalarFieldEnum | ReviewPhotoScalarFieldEnum[]
  }

  /**
   * ReviewPhoto findFirstOrThrow
   */
  export type ReviewPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReviewPhoto to fetch.
     */
    where?: ReviewPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewPhotos to fetch.
     */
    orderBy?: ReviewPhotoOrderByWithRelationInput | ReviewPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewPhotos.
     */
    cursor?: ReviewPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewPhotos.
     */
    distinct?: ReviewPhotoScalarFieldEnum | ReviewPhotoScalarFieldEnum[]
  }

  /**
   * ReviewPhoto findMany
   */
  export type ReviewPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReviewPhotos to fetch.
     */
    where?: ReviewPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewPhotos to fetch.
     */
    orderBy?: ReviewPhotoOrderByWithRelationInput | ReviewPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewPhotos.
     */
    cursor?: ReviewPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewPhotos.
     */
    skip?: number
    distinct?: ReviewPhotoScalarFieldEnum | ReviewPhotoScalarFieldEnum[]
  }

  /**
   * ReviewPhoto create
   */
  export type ReviewPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewPhoto.
     */
    data: XOR<ReviewPhotoCreateInput, ReviewPhotoUncheckedCreateInput>
  }

  /**
   * ReviewPhoto createMany
   */
  export type ReviewPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewPhotos.
     */
    data: ReviewPhotoCreateManyInput | ReviewPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewPhoto createManyAndReturn
   */
  export type ReviewPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReviewPhotos.
     */
    data: ReviewPhotoCreateManyInput | ReviewPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewPhoto update
   */
  export type ReviewPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewPhoto.
     */
    data: XOR<ReviewPhotoUpdateInput, ReviewPhotoUncheckedUpdateInput>
    /**
     * Choose, which ReviewPhoto to update.
     */
    where: ReviewPhotoWhereUniqueInput
  }

  /**
   * ReviewPhoto updateMany
   */
  export type ReviewPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewPhotos.
     */
    data: XOR<ReviewPhotoUpdateManyMutationInput, ReviewPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ReviewPhotos to update
     */
    where?: ReviewPhotoWhereInput
  }

  /**
   * ReviewPhoto upsert
   */
  export type ReviewPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewPhoto to update in case it exists.
     */
    where: ReviewPhotoWhereUniqueInput
    /**
     * In case the ReviewPhoto found by the `where` argument doesn't exist, create a new ReviewPhoto with this data.
     */
    create: XOR<ReviewPhotoCreateInput, ReviewPhotoUncheckedCreateInput>
    /**
     * In case the ReviewPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewPhotoUpdateInput, ReviewPhotoUncheckedUpdateInput>
  }

  /**
   * ReviewPhoto delete
   */
  export type ReviewPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
    /**
     * Filter which ReviewPhoto to delete.
     */
    where: ReviewPhotoWhereUniqueInput
  }

  /**
   * ReviewPhoto deleteMany
   */
  export type ReviewPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewPhotos to delete
     */
    where?: ReviewPhotoWhereInput
  }

  /**
   * ReviewPhoto without action
   */
  export type ReviewPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewPhoto
     */
    select?: ReviewPhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewPhotoInclude<ExtArgs> | null
  }


  /**
   * Model ReviewTranslation
   */

  export type AggregateReviewTranslation = {
    _count: ReviewTranslationCountAggregateOutputType | null
    _min: ReviewTranslationMinAggregateOutputType | null
    _max: ReviewTranslationMaxAggregateOutputType | null
  }

  export type ReviewTranslationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    desc: string | null
    languageCode: string | null
    reviewId: string | null
  }

  export type ReviewTranslationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    desc: string | null
    languageCode: string | null
    reviewId: string | null
  }

  export type ReviewTranslationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    desc: number
    languageCode: number
    reviewId: number
    _all: number
  }


  export type ReviewTranslationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    desc?: true
    languageCode?: true
    reviewId?: true
  }

  export type ReviewTranslationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    desc?: true
    languageCode?: true
    reviewId?: true
  }

  export type ReviewTranslationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    desc?: true
    languageCode?: true
    reviewId?: true
    _all?: true
  }

  export type ReviewTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewTranslation to aggregate.
     */
    where?: ReviewTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTranslations to fetch.
     */
    orderBy?: ReviewTranslationOrderByWithRelationInput | ReviewTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewTranslations
    **/
    _count?: true | ReviewTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewTranslationMaxAggregateInputType
  }

  export type GetReviewTranslationAggregateType<T extends ReviewTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewTranslation[P]>
      : GetScalarType<T[P], AggregateReviewTranslation[P]>
  }




  export type ReviewTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewTranslationWhereInput
    orderBy?: ReviewTranslationOrderByWithAggregationInput | ReviewTranslationOrderByWithAggregationInput[]
    by: ReviewTranslationScalarFieldEnum[] | ReviewTranslationScalarFieldEnum
    having?: ReviewTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewTranslationCountAggregateInputType | true
    _min?: ReviewTranslationMinAggregateInputType
    _max?: ReviewTranslationMaxAggregateInputType
  }

  export type ReviewTranslationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    desc: string
    languageCode: string
    reviewId: string
    _count: ReviewTranslationCountAggregateOutputType | null
    _min: ReviewTranslationMinAggregateOutputType | null
    _max: ReviewTranslationMaxAggregateOutputType | null
  }

  type GetReviewTranslationGroupByPayload<T extends ReviewTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewTranslationGroupByOutputType[P]>
        }
      >
    >


  export type ReviewTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    desc?: boolean
    languageCode?: boolean
    reviewId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewTranslation"]>

  export type ReviewTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    desc?: boolean
    languageCode?: boolean
    reviewId?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewTranslation"]>

  export type ReviewTranslationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    desc?: boolean
    languageCode?: boolean
    reviewId?: boolean
  }

  export type ReviewTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }
  export type ReviewTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }

  export type $ReviewTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewTranslation"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      desc: string
      languageCode: string
      reviewId: string
    }, ExtArgs["result"]["reviewTranslation"]>
    composites: {}
  }

  type ReviewTranslationGetPayload<S extends boolean | null | undefined | ReviewTranslationDefaultArgs> = $Result.GetResult<Prisma.$ReviewTranslationPayload, S>

  type ReviewTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewTranslationCountAggregateInputType | true
    }

  export interface ReviewTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewTranslation'], meta: { name: 'ReviewTranslation' } }
    /**
     * Find zero or one ReviewTranslation that matches the filter.
     * @param {ReviewTranslationFindUniqueArgs} args - Arguments to find a ReviewTranslation
     * @example
     * // Get one ReviewTranslation
     * const reviewTranslation = await prisma.reviewTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewTranslationFindUniqueArgs>(args: SelectSubset<T, ReviewTranslationFindUniqueArgs<ExtArgs>>): Prisma__ReviewTranslationClient<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReviewTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewTranslationFindUniqueOrThrowArgs} args - Arguments to find a ReviewTranslation
     * @example
     * // Get one ReviewTranslation
     * const reviewTranslation = await prisma.reviewTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewTranslationClient<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReviewTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTranslationFindFirstArgs} args - Arguments to find a ReviewTranslation
     * @example
     * // Get one ReviewTranslation
     * const reviewTranslation = await prisma.reviewTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewTranslationFindFirstArgs>(args?: SelectSubset<T, ReviewTranslationFindFirstArgs<ExtArgs>>): Prisma__ReviewTranslationClient<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReviewTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTranslationFindFirstOrThrowArgs} args - Arguments to find a ReviewTranslation
     * @example
     * // Get one ReviewTranslation
     * const reviewTranslation = await prisma.reviewTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewTranslationClient<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReviewTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewTranslations
     * const reviewTranslations = await prisma.reviewTranslation.findMany()
     * 
     * // Get first 10 ReviewTranslations
     * const reviewTranslations = await prisma.reviewTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewTranslationWithIdOnly = await prisma.reviewTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewTranslationFindManyArgs>(args?: SelectSubset<T, ReviewTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReviewTranslation.
     * @param {ReviewTranslationCreateArgs} args - Arguments to create a ReviewTranslation.
     * @example
     * // Create one ReviewTranslation
     * const ReviewTranslation = await prisma.reviewTranslation.create({
     *   data: {
     *     // ... data to create a ReviewTranslation
     *   }
     * })
     * 
     */
    create<T extends ReviewTranslationCreateArgs>(args: SelectSubset<T, ReviewTranslationCreateArgs<ExtArgs>>): Prisma__ReviewTranslationClient<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReviewTranslations.
     * @param {ReviewTranslationCreateManyArgs} args - Arguments to create many ReviewTranslations.
     * @example
     * // Create many ReviewTranslations
     * const reviewTranslation = await prisma.reviewTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewTranslationCreateManyArgs>(args?: SelectSubset<T, ReviewTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewTranslations and returns the data saved in the database.
     * @param {ReviewTranslationCreateManyAndReturnArgs} args - Arguments to create many ReviewTranslations.
     * @example
     * // Create many ReviewTranslations
     * const reviewTranslation = await prisma.reviewTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewTranslations and only return the `id`
     * const reviewTranslationWithIdOnly = await prisma.reviewTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReviewTranslation.
     * @param {ReviewTranslationDeleteArgs} args - Arguments to delete one ReviewTranslation.
     * @example
     * // Delete one ReviewTranslation
     * const ReviewTranslation = await prisma.reviewTranslation.delete({
     *   where: {
     *     // ... filter to delete one ReviewTranslation
     *   }
     * })
     * 
     */
    delete<T extends ReviewTranslationDeleteArgs>(args: SelectSubset<T, ReviewTranslationDeleteArgs<ExtArgs>>): Prisma__ReviewTranslationClient<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReviewTranslation.
     * @param {ReviewTranslationUpdateArgs} args - Arguments to update one ReviewTranslation.
     * @example
     * // Update one ReviewTranslation
     * const reviewTranslation = await prisma.reviewTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewTranslationUpdateArgs>(args: SelectSubset<T, ReviewTranslationUpdateArgs<ExtArgs>>): Prisma__ReviewTranslationClient<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReviewTranslations.
     * @param {ReviewTranslationDeleteManyArgs} args - Arguments to filter ReviewTranslations to delete.
     * @example
     * // Delete a few ReviewTranslations
     * const { count } = await prisma.reviewTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewTranslationDeleteManyArgs>(args?: SelectSubset<T, ReviewTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewTranslations
     * const reviewTranslation = await prisma.reviewTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewTranslationUpdateManyArgs>(args: SelectSubset<T, ReviewTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReviewTranslation.
     * @param {ReviewTranslationUpsertArgs} args - Arguments to update or create a ReviewTranslation.
     * @example
     * // Update or create a ReviewTranslation
     * const reviewTranslation = await prisma.reviewTranslation.upsert({
     *   create: {
     *     // ... data to create a ReviewTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewTranslation we want to update
     *   }
     * })
     */
    upsert<T extends ReviewTranslationUpsertArgs>(args: SelectSubset<T, ReviewTranslationUpsertArgs<ExtArgs>>): Prisma__ReviewTranslationClient<$Result.GetResult<Prisma.$ReviewTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReviewTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTranslationCountArgs} args - Arguments to filter ReviewTranslations to count.
     * @example
     * // Count the number of ReviewTranslations
     * const count = await prisma.reviewTranslation.count({
     *   where: {
     *     // ... the filter for the ReviewTranslations we want to count
     *   }
     * })
    **/
    count<T extends ReviewTranslationCountArgs>(
      args?: Subset<T, ReviewTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewTranslationAggregateArgs>(args: Subset<T, ReviewTranslationAggregateArgs>): Prisma.PrismaPromise<GetReviewTranslationAggregateType<T>>

    /**
     * Group by ReviewTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewTranslationGroupByArgs['orderBy'] }
        : { orderBy?: ReviewTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewTranslation model
   */
  readonly fields: ReviewTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewTranslation model
   */ 
  interface ReviewTranslationFieldRefs {
    readonly id: FieldRef<"ReviewTranslation", 'String'>
    readonly createdAt: FieldRef<"ReviewTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"ReviewTranslation", 'DateTime'>
    readonly desc: FieldRef<"ReviewTranslation", 'String'>
    readonly languageCode: FieldRef<"ReviewTranslation", 'String'>
    readonly reviewId: FieldRef<"ReviewTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReviewTranslation findUnique
   */
  export type ReviewTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTranslation to fetch.
     */
    where: ReviewTranslationWhereUniqueInput
  }

  /**
   * ReviewTranslation findUniqueOrThrow
   */
  export type ReviewTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTranslation to fetch.
     */
    where: ReviewTranslationWhereUniqueInput
  }

  /**
   * ReviewTranslation findFirst
   */
  export type ReviewTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTranslation to fetch.
     */
    where?: ReviewTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTranslations to fetch.
     */
    orderBy?: ReviewTranslationOrderByWithRelationInput | ReviewTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewTranslations.
     */
    cursor?: ReviewTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewTranslations.
     */
    distinct?: ReviewTranslationScalarFieldEnum | ReviewTranslationScalarFieldEnum[]
  }

  /**
   * ReviewTranslation findFirstOrThrow
   */
  export type ReviewTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTranslation to fetch.
     */
    where?: ReviewTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTranslations to fetch.
     */
    orderBy?: ReviewTranslationOrderByWithRelationInput | ReviewTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewTranslations.
     */
    cursor?: ReviewTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewTranslations.
     */
    distinct?: ReviewTranslationScalarFieldEnum | ReviewTranslationScalarFieldEnum[]
  }

  /**
   * ReviewTranslation findMany
   */
  export type ReviewTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    /**
     * Filter, which ReviewTranslations to fetch.
     */
    where?: ReviewTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewTranslations to fetch.
     */
    orderBy?: ReviewTranslationOrderByWithRelationInput | ReviewTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewTranslations.
     */
    cursor?: ReviewTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewTranslations.
     */
    skip?: number
    distinct?: ReviewTranslationScalarFieldEnum | ReviewTranslationScalarFieldEnum[]
  }

  /**
   * ReviewTranslation create
   */
  export type ReviewTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewTranslation.
     */
    data: XOR<ReviewTranslationCreateInput, ReviewTranslationUncheckedCreateInput>
  }

  /**
   * ReviewTranslation createMany
   */
  export type ReviewTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewTranslations.
     */
    data: ReviewTranslationCreateManyInput | ReviewTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewTranslation createManyAndReturn
   */
  export type ReviewTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReviewTranslations.
     */
    data: ReviewTranslationCreateManyInput | ReviewTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewTranslation update
   */
  export type ReviewTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewTranslation.
     */
    data: XOR<ReviewTranslationUpdateInput, ReviewTranslationUncheckedUpdateInput>
    /**
     * Choose, which ReviewTranslation to update.
     */
    where: ReviewTranslationWhereUniqueInput
  }

  /**
   * ReviewTranslation updateMany
   */
  export type ReviewTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewTranslations.
     */
    data: XOR<ReviewTranslationUpdateManyMutationInput, ReviewTranslationUncheckedUpdateManyInput>
    /**
     * Filter which ReviewTranslations to update
     */
    where?: ReviewTranslationWhereInput
  }

  /**
   * ReviewTranslation upsert
   */
  export type ReviewTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewTranslation to update in case it exists.
     */
    where: ReviewTranslationWhereUniqueInput
    /**
     * In case the ReviewTranslation found by the `where` argument doesn't exist, create a new ReviewTranslation with this data.
     */
    create: XOR<ReviewTranslationCreateInput, ReviewTranslationUncheckedCreateInput>
    /**
     * In case the ReviewTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewTranslationUpdateInput, ReviewTranslationUncheckedUpdateInput>
  }

  /**
   * ReviewTranslation delete
   */
  export type ReviewTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
    /**
     * Filter which ReviewTranslation to delete.
     */
    where: ReviewTranslationWhereUniqueInput
  }

  /**
   * ReviewTranslation deleteMany
   */
  export type ReviewTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewTranslations to delete
     */
    where?: ReviewTranslationWhereInput
  }

  /**
   * ReviewTranslation without action
   */
  export type ReviewTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewTranslation
     */
    select?: ReviewTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewTranslationInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    firstName: string | null
    email: string | null
    messenger: string | null
    messagngerType: string | null
    message: string | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    firstName: string | null
    email: string | null
    messenger: string | null
    messagngerType: string | null
    message: string | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    firstName: number
    email: number
    messenger: number
    messagngerType: number
    message: number
    _all: number
  }


  export type FeedbackMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    email?: true
    messenger?: true
    messagngerType?: true
    message?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    email?: true
    messenger?: true
    messagngerType?: true
    message?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstName?: true
    email?: true
    messenger?: true
    messagngerType?: true
    message?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    firstName: string
    email: string
    messenger: string
    messagngerType: string
    message: string
    _count: FeedbackCountAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    email?: boolean
    messenger?: boolean
    messagngerType?: boolean
    message?: boolean
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    email?: boolean
    messenger?: boolean
    messagngerType?: boolean
    message?: boolean
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstName?: boolean
    email?: boolean
    messenger?: boolean
    messagngerType?: boolean
    message?: boolean
  }


  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      firstName: string
      email: string
      messenger: string
      messagngerType: string
      message: string
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {FeedbackCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `id`
     * const feedbackWithIdOnly = await prisma.feedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly updatedAt: FieldRef<"Feedback", 'DateTime'>
    readonly firstName: FieldRef<"Feedback", 'String'>
    readonly email: FieldRef<"Feedback", 'String'>
    readonly messenger: FieldRef<"Feedback", 'String'>
    readonly messagngerType: FieldRef<"Feedback", 'String'>
    readonly message: FieldRef<"Feedback", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback createManyAndReturn
   */
  export type FeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
  }


  /**
   * Model DeliveryInfo
   */

  export type AggregateDeliveryInfo = {
    _count: DeliveryInfoCountAggregateOutputType | null
    _min: DeliveryInfoMinAggregateOutputType | null
    _max: DeliveryInfoMaxAggregateOutputType | null
  }

  export type DeliveryInfoMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
  }

  export type DeliveryInfoMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
  }

  export type DeliveryInfoCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    description: number
    _all: number
  }


  export type DeliveryInfoMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
  }

  export type DeliveryInfoMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
  }

  export type DeliveryInfoCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    _all?: true
  }

  export type DeliveryInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryInfo to aggregate.
     */
    where?: DeliveryInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryInfos to fetch.
     */
    orderBy?: DeliveryInfoOrderByWithRelationInput | DeliveryInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryInfos
    **/
    _count?: true | DeliveryInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryInfoMaxAggregateInputType
  }

  export type GetDeliveryInfoAggregateType<T extends DeliveryInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryInfo[P]>
      : GetScalarType<T[P], AggregateDeliveryInfo[P]>
  }




  export type DeliveryInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryInfoWhereInput
    orderBy?: DeliveryInfoOrderByWithAggregationInput | DeliveryInfoOrderByWithAggregationInput[]
    by: DeliveryInfoScalarFieldEnum[] | DeliveryInfoScalarFieldEnum
    having?: DeliveryInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryInfoCountAggregateInputType | true
    _min?: DeliveryInfoMinAggregateInputType
    _max?: DeliveryInfoMaxAggregateInputType
  }

  export type DeliveryInfoGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    description: string
    _count: DeliveryInfoCountAggregateOutputType | null
    _min: DeliveryInfoMinAggregateOutputType | null
    _max: DeliveryInfoMaxAggregateOutputType | null
  }

  type GetDeliveryInfoGroupByPayload<T extends DeliveryInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryInfoGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryInfoGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    translation?: boolean | DeliveryInfo$translationArgs<ExtArgs>
    _count?: boolean | DeliveryInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryInfo"]>

  export type DeliveryInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
  }, ExtArgs["result"]["deliveryInfo"]>

  export type DeliveryInfoSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
  }

  export type DeliveryInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | DeliveryInfo$translationArgs<ExtArgs>
    _count?: boolean | DeliveryInfoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeliveryInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryInfo"
    objects: {
      translation: Prisma.$DeliveryInfoTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      description: string
    }, ExtArgs["result"]["deliveryInfo"]>
    composites: {}
  }

  type DeliveryInfoGetPayload<S extends boolean | null | undefined | DeliveryInfoDefaultArgs> = $Result.GetResult<Prisma.$DeliveryInfoPayload, S>

  type DeliveryInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliveryInfoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliveryInfoCountAggregateInputType | true
    }

  export interface DeliveryInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryInfo'], meta: { name: 'DeliveryInfo' } }
    /**
     * Find zero or one DeliveryInfo that matches the filter.
     * @param {DeliveryInfoFindUniqueArgs} args - Arguments to find a DeliveryInfo
     * @example
     * // Get one DeliveryInfo
     * const deliveryInfo = await prisma.deliveryInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryInfoFindUniqueArgs>(args: SelectSubset<T, DeliveryInfoFindUniqueArgs<ExtArgs>>): Prisma__DeliveryInfoClient<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeliveryInfo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliveryInfoFindUniqueOrThrowArgs} args - Arguments to find a DeliveryInfo
     * @example
     * // Get one DeliveryInfo
     * const deliveryInfo = await prisma.deliveryInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryInfoClient<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeliveryInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoFindFirstArgs} args - Arguments to find a DeliveryInfo
     * @example
     * // Get one DeliveryInfo
     * const deliveryInfo = await prisma.deliveryInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryInfoFindFirstArgs>(args?: SelectSubset<T, DeliveryInfoFindFirstArgs<ExtArgs>>): Prisma__DeliveryInfoClient<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeliveryInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoFindFirstOrThrowArgs} args - Arguments to find a DeliveryInfo
     * @example
     * // Get one DeliveryInfo
     * const deliveryInfo = await prisma.deliveryInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryInfoClient<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeliveryInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryInfos
     * const deliveryInfos = await prisma.deliveryInfo.findMany()
     * 
     * // Get first 10 DeliveryInfos
     * const deliveryInfos = await prisma.deliveryInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryInfoWithIdOnly = await prisma.deliveryInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryInfoFindManyArgs>(args?: SelectSubset<T, DeliveryInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeliveryInfo.
     * @param {DeliveryInfoCreateArgs} args - Arguments to create a DeliveryInfo.
     * @example
     * // Create one DeliveryInfo
     * const DeliveryInfo = await prisma.deliveryInfo.create({
     *   data: {
     *     // ... data to create a DeliveryInfo
     *   }
     * })
     * 
     */
    create<T extends DeliveryInfoCreateArgs>(args: SelectSubset<T, DeliveryInfoCreateArgs<ExtArgs>>): Prisma__DeliveryInfoClient<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeliveryInfos.
     * @param {DeliveryInfoCreateManyArgs} args - Arguments to create many DeliveryInfos.
     * @example
     * // Create many DeliveryInfos
     * const deliveryInfo = await prisma.deliveryInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryInfoCreateManyArgs>(args?: SelectSubset<T, DeliveryInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryInfos and returns the data saved in the database.
     * @param {DeliveryInfoCreateManyAndReturnArgs} args - Arguments to create many DeliveryInfos.
     * @example
     * // Create many DeliveryInfos
     * const deliveryInfo = await prisma.deliveryInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryInfos and only return the `id`
     * const deliveryInfoWithIdOnly = await prisma.deliveryInfo.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeliveryInfo.
     * @param {DeliveryInfoDeleteArgs} args - Arguments to delete one DeliveryInfo.
     * @example
     * // Delete one DeliveryInfo
     * const DeliveryInfo = await prisma.deliveryInfo.delete({
     *   where: {
     *     // ... filter to delete one DeliveryInfo
     *   }
     * })
     * 
     */
    delete<T extends DeliveryInfoDeleteArgs>(args: SelectSubset<T, DeliveryInfoDeleteArgs<ExtArgs>>): Prisma__DeliveryInfoClient<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeliveryInfo.
     * @param {DeliveryInfoUpdateArgs} args - Arguments to update one DeliveryInfo.
     * @example
     * // Update one DeliveryInfo
     * const deliveryInfo = await prisma.deliveryInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryInfoUpdateArgs>(args: SelectSubset<T, DeliveryInfoUpdateArgs<ExtArgs>>): Prisma__DeliveryInfoClient<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeliveryInfos.
     * @param {DeliveryInfoDeleteManyArgs} args - Arguments to filter DeliveryInfos to delete.
     * @example
     * // Delete a few DeliveryInfos
     * const { count } = await prisma.deliveryInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryInfoDeleteManyArgs>(args?: SelectSubset<T, DeliveryInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryInfos
     * const deliveryInfo = await prisma.deliveryInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryInfoUpdateManyArgs>(args: SelectSubset<T, DeliveryInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryInfo.
     * @param {DeliveryInfoUpsertArgs} args - Arguments to update or create a DeliveryInfo.
     * @example
     * // Update or create a DeliveryInfo
     * const deliveryInfo = await prisma.deliveryInfo.upsert({
     *   create: {
     *     // ... data to create a DeliveryInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryInfo we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryInfoUpsertArgs>(args: SelectSubset<T, DeliveryInfoUpsertArgs<ExtArgs>>): Prisma__DeliveryInfoClient<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeliveryInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoCountArgs} args - Arguments to filter DeliveryInfos to count.
     * @example
     * // Count the number of DeliveryInfos
     * const count = await prisma.deliveryInfo.count({
     *   where: {
     *     // ... the filter for the DeliveryInfos we want to count
     *   }
     * })
    **/
    count<T extends DeliveryInfoCountArgs>(
      args?: Subset<T, DeliveryInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryInfoAggregateArgs>(args: Subset<T, DeliveryInfoAggregateArgs>): Prisma.PrismaPromise<GetDeliveryInfoAggregateType<T>>

    /**
     * Group by DeliveryInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryInfoGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryInfo model
   */
  readonly fields: DeliveryInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translation<T extends DeliveryInfo$translationArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryInfo$translationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryInfo model
   */ 
  interface DeliveryInfoFieldRefs {
    readonly id: FieldRef<"DeliveryInfo", 'String'>
    readonly createdAt: FieldRef<"DeliveryInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryInfo", 'DateTime'>
    readonly description: FieldRef<"DeliveryInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryInfo findUnique
   */
  export type DeliveryInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfo to fetch.
     */
    where: DeliveryInfoWhereUniqueInput
  }

  /**
   * DeliveryInfo findUniqueOrThrow
   */
  export type DeliveryInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfo to fetch.
     */
    where: DeliveryInfoWhereUniqueInput
  }

  /**
   * DeliveryInfo findFirst
   */
  export type DeliveryInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfo to fetch.
     */
    where?: DeliveryInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryInfos to fetch.
     */
    orderBy?: DeliveryInfoOrderByWithRelationInput | DeliveryInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryInfos.
     */
    cursor?: DeliveryInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryInfos.
     */
    distinct?: DeliveryInfoScalarFieldEnum | DeliveryInfoScalarFieldEnum[]
  }

  /**
   * DeliveryInfo findFirstOrThrow
   */
  export type DeliveryInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfo to fetch.
     */
    where?: DeliveryInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryInfos to fetch.
     */
    orderBy?: DeliveryInfoOrderByWithRelationInput | DeliveryInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryInfos.
     */
    cursor?: DeliveryInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryInfos.
     */
    distinct?: DeliveryInfoScalarFieldEnum | DeliveryInfoScalarFieldEnum[]
  }

  /**
   * DeliveryInfo findMany
   */
  export type DeliveryInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfos to fetch.
     */
    where?: DeliveryInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryInfos to fetch.
     */
    orderBy?: DeliveryInfoOrderByWithRelationInput | DeliveryInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryInfos.
     */
    cursor?: DeliveryInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryInfos.
     */
    skip?: number
    distinct?: DeliveryInfoScalarFieldEnum | DeliveryInfoScalarFieldEnum[]
  }

  /**
   * DeliveryInfo create
   */
  export type DeliveryInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryInfo.
     */
    data: XOR<DeliveryInfoCreateInput, DeliveryInfoUncheckedCreateInput>
  }

  /**
   * DeliveryInfo createMany
   */
  export type DeliveryInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryInfos.
     */
    data: DeliveryInfoCreateManyInput | DeliveryInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryInfo createManyAndReturn
   */
  export type DeliveryInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeliveryInfos.
     */
    data: DeliveryInfoCreateManyInput | DeliveryInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryInfo update
   */
  export type DeliveryInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryInfo.
     */
    data: XOR<DeliveryInfoUpdateInput, DeliveryInfoUncheckedUpdateInput>
    /**
     * Choose, which DeliveryInfo to update.
     */
    where: DeliveryInfoWhereUniqueInput
  }

  /**
   * DeliveryInfo updateMany
   */
  export type DeliveryInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryInfos.
     */
    data: XOR<DeliveryInfoUpdateManyMutationInput, DeliveryInfoUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryInfos to update
     */
    where?: DeliveryInfoWhereInput
  }

  /**
   * DeliveryInfo upsert
   */
  export type DeliveryInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryInfo to update in case it exists.
     */
    where: DeliveryInfoWhereUniqueInput
    /**
     * In case the DeliveryInfo found by the `where` argument doesn't exist, create a new DeliveryInfo with this data.
     */
    create: XOR<DeliveryInfoCreateInput, DeliveryInfoUncheckedCreateInput>
    /**
     * In case the DeliveryInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryInfoUpdateInput, DeliveryInfoUncheckedUpdateInput>
  }

  /**
   * DeliveryInfo delete
   */
  export type DeliveryInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
    /**
     * Filter which DeliveryInfo to delete.
     */
    where: DeliveryInfoWhereUniqueInput
  }

  /**
   * DeliveryInfo deleteMany
   */
  export type DeliveryInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryInfos to delete
     */
    where?: DeliveryInfoWhereInput
  }

  /**
   * DeliveryInfo.translation
   */
  export type DeliveryInfo$translationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    where?: DeliveryInfoTranslationWhereInput
    orderBy?: DeliveryInfoTranslationOrderByWithRelationInput | DeliveryInfoTranslationOrderByWithRelationInput[]
    cursor?: DeliveryInfoTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryInfoTranslationScalarFieldEnum | DeliveryInfoTranslationScalarFieldEnum[]
  }

  /**
   * DeliveryInfo without action
   */
  export type DeliveryInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfo
     */
    select?: DeliveryInfoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryInfoTranslation
   */

  export type AggregateDeliveryInfoTranslation = {
    _count: DeliveryInfoTranslationCountAggregateOutputType | null
    _min: DeliveryInfoTranslationMinAggregateOutputType | null
    _max: DeliveryInfoTranslationMaxAggregateOutputType | null
  }

  export type DeliveryInfoTranslationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    languageCode: string | null
    deliveryId: string | null
  }

  export type DeliveryInfoTranslationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    languageCode: string | null
    deliveryId: string | null
  }

  export type DeliveryInfoTranslationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    description: number
    languageCode: number
    deliveryId: number
    _all: number
  }


  export type DeliveryInfoTranslationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    languageCode?: true
    deliveryId?: true
  }

  export type DeliveryInfoTranslationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    languageCode?: true
    deliveryId?: true
  }

  export type DeliveryInfoTranslationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    languageCode?: true
    deliveryId?: true
    _all?: true
  }

  export type DeliveryInfoTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryInfoTranslation to aggregate.
     */
    where?: DeliveryInfoTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryInfoTranslations to fetch.
     */
    orderBy?: DeliveryInfoTranslationOrderByWithRelationInput | DeliveryInfoTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryInfoTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryInfoTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryInfoTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryInfoTranslations
    **/
    _count?: true | DeliveryInfoTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryInfoTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryInfoTranslationMaxAggregateInputType
  }

  export type GetDeliveryInfoTranslationAggregateType<T extends DeliveryInfoTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryInfoTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryInfoTranslation[P]>
      : GetScalarType<T[P], AggregateDeliveryInfoTranslation[P]>
  }




  export type DeliveryInfoTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryInfoTranslationWhereInput
    orderBy?: DeliveryInfoTranslationOrderByWithAggregationInput | DeliveryInfoTranslationOrderByWithAggregationInput[]
    by: DeliveryInfoTranslationScalarFieldEnum[] | DeliveryInfoTranslationScalarFieldEnum
    having?: DeliveryInfoTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryInfoTranslationCountAggregateInputType | true
    _min?: DeliveryInfoTranslationMinAggregateInputType
    _max?: DeliveryInfoTranslationMaxAggregateInputType
  }

  export type DeliveryInfoTranslationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    description: string
    languageCode: string
    deliveryId: string
    _count: DeliveryInfoTranslationCountAggregateOutputType | null
    _min: DeliveryInfoTranslationMinAggregateOutputType | null
    _max: DeliveryInfoTranslationMaxAggregateOutputType | null
  }

  type GetDeliveryInfoTranslationGroupByPayload<T extends DeliveryInfoTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryInfoTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryInfoTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryInfoTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryInfoTranslationGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryInfoTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    languageCode?: boolean
    deliveryId?: boolean
    deliveryInfo?: boolean | DeliveryInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryInfoTranslation"]>

  export type DeliveryInfoTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    languageCode?: boolean
    deliveryId?: boolean
    deliveryInfo?: boolean | DeliveryInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryInfoTranslation"]>

  export type DeliveryInfoTranslationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    languageCode?: boolean
    deliveryId?: boolean
  }

  export type DeliveryInfoTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryInfo?: boolean | DeliveryInfoDefaultArgs<ExtArgs>
  }
  export type DeliveryInfoTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deliveryInfo?: boolean | DeliveryInfoDefaultArgs<ExtArgs>
  }

  export type $DeliveryInfoTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryInfoTranslation"
    objects: {
      deliveryInfo: Prisma.$DeliveryInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      description: string
      languageCode: string
      deliveryId: string
    }, ExtArgs["result"]["deliveryInfoTranslation"]>
    composites: {}
  }

  type DeliveryInfoTranslationGetPayload<S extends boolean | null | undefined | DeliveryInfoTranslationDefaultArgs> = $Result.GetResult<Prisma.$DeliveryInfoTranslationPayload, S>

  type DeliveryInfoTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliveryInfoTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliveryInfoTranslationCountAggregateInputType | true
    }

  export interface DeliveryInfoTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryInfoTranslation'], meta: { name: 'DeliveryInfoTranslation' } }
    /**
     * Find zero or one DeliveryInfoTranslation that matches the filter.
     * @param {DeliveryInfoTranslationFindUniqueArgs} args - Arguments to find a DeliveryInfoTranslation
     * @example
     * // Get one DeliveryInfoTranslation
     * const deliveryInfoTranslation = await prisma.deliveryInfoTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryInfoTranslationFindUniqueArgs>(args: SelectSubset<T, DeliveryInfoTranslationFindUniqueArgs<ExtArgs>>): Prisma__DeliveryInfoTranslationClient<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeliveryInfoTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliveryInfoTranslationFindUniqueOrThrowArgs} args - Arguments to find a DeliveryInfoTranslation
     * @example
     * // Get one DeliveryInfoTranslation
     * const deliveryInfoTranslation = await prisma.deliveryInfoTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryInfoTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryInfoTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryInfoTranslationClient<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeliveryInfoTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoTranslationFindFirstArgs} args - Arguments to find a DeliveryInfoTranslation
     * @example
     * // Get one DeliveryInfoTranslation
     * const deliveryInfoTranslation = await prisma.deliveryInfoTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryInfoTranslationFindFirstArgs>(args?: SelectSubset<T, DeliveryInfoTranslationFindFirstArgs<ExtArgs>>): Prisma__DeliveryInfoTranslationClient<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeliveryInfoTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoTranslationFindFirstOrThrowArgs} args - Arguments to find a DeliveryInfoTranslation
     * @example
     * // Get one DeliveryInfoTranslation
     * const deliveryInfoTranslation = await prisma.deliveryInfoTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryInfoTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryInfoTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryInfoTranslationClient<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeliveryInfoTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryInfoTranslations
     * const deliveryInfoTranslations = await prisma.deliveryInfoTranslation.findMany()
     * 
     * // Get first 10 DeliveryInfoTranslations
     * const deliveryInfoTranslations = await prisma.deliveryInfoTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryInfoTranslationWithIdOnly = await prisma.deliveryInfoTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryInfoTranslationFindManyArgs>(args?: SelectSubset<T, DeliveryInfoTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeliveryInfoTranslation.
     * @param {DeliveryInfoTranslationCreateArgs} args - Arguments to create a DeliveryInfoTranslation.
     * @example
     * // Create one DeliveryInfoTranslation
     * const DeliveryInfoTranslation = await prisma.deliveryInfoTranslation.create({
     *   data: {
     *     // ... data to create a DeliveryInfoTranslation
     *   }
     * })
     * 
     */
    create<T extends DeliveryInfoTranslationCreateArgs>(args: SelectSubset<T, DeliveryInfoTranslationCreateArgs<ExtArgs>>): Prisma__DeliveryInfoTranslationClient<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeliveryInfoTranslations.
     * @param {DeliveryInfoTranslationCreateManyArgs} args - Arguments to create many DeliveryInfoTranslations.
     * @example
     * // Create many DeliveryInfoTranslations
     * const deliveryInfoTranslation = await prisma.deliveryInfoTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryInfoTranslationCreateManyArgs>(args?: SelectSubset<T, DeliveryInfoTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryInfoTranslations and returns the data saved in the database.
     * @param {DeliveryInfoTranslationCreateManyAndReturnArgs} args - Arguments to create many DeliveryInfoTranslations.
     * @example
     * // Create many DeliveryInfoTranslations
     * const deliveryInfoTranslation = await prisma.deliveryInfoTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryInfoTranslations and only return the `id`
     * const deliveryInfoTranslationWithIdOnly = await prisma.deliveryInfoTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryInfoTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryInfoTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeliveryInfoTranslation.
     * @param {DeliveryInfoTranslationDeleteArgs} args - Arguments to delete one DeliveryInfoTranslation.
     * @example
     * // Delete one DeliveryInfoTranslation
     * const DeliveryInfoTranslation = await prisma.deliveryInfoTranslation.delete({
     *   where: {
     *     // ... filter to delete one DeliveryInfoTranslation
     *   }
     * })
     * 
     */
    delete<T extends DeliveryInfoTranslationDeleteArgs>(args: SelectSubset<T, DeliveryInfoTranslationDeleteArgs<ExtArgs>>): Prisma__DeliveryInfoTranslationClient<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeliveryInfoTranslation.
     * @param {DeliveryInfoTranslationUpdateArgs} args - Arguments to update one DeliveryInfoTranslation.
     * @example
     * // Update one DeliveryInfoTranslation
     * const deliveryInfoTranslation = await prisma.deliveryInfoTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryInfoTranslationUpdateArgs>(args: SelectSubset<T, DeliveryInfoTranslationUpdateArgs<ExtArgs>>): Prisma__DeliveryInfoTranslationClient<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeliveryInfoTranslations.
     * @param {DeliveryInfoTranslationDeleteManyArgs} args - Arguments to filter DeliveryInfoTranslations to delete.
     * @example
     * // Delete a few DeliveryInfoTranslations
     * const { count } = await prisma.deliveryInfoTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryInfoTranslationDeleteManyArgs>(args?: SelectSubset<T, DeliveryInfoTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryInfoTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryInfoTranslations
     * const deliveryInfoTranslation = await prisma.deliveryInfoTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryInfoTranslationUpdateManyArgs>(args: SelectSubset<T, DeliveryInfoTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryInfoTranslation.
     * @param {DeliveryInfoTranslationUpsertArgs} args - Arguments to update or create a DeliveryInfoTranslation.
     * @example
     * // Update or create a DeliveryInfoTranslation
     * const deliveryInfoTranslation = await prisma.deliveryInfoTranslation.upsert({
     *   create: {
     *     // ... data to create a DeliveryInfoTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryInfoTranslation we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryInfoTranslationUpsertArgs>(args: SelectSubset<T, DeliveryInfoTranslationUpsertArgs<ExtArgs>>): Prisma__DeliveryInfoTranslationClient<$Result.GetResult<Prisma.$DeliveryInfoTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeliveryInfoTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoTranslationCountArgs} args - Arguments to filter DeliveryInfoTranslations to count.
     * @example
     * // Count the number of DeliveryInfoTranslations
     * const count = await prisma.deliveryInfoTranslation.count({
     *   where: {
     *     // ... the filter for the DeliveryInfoTranslations we want to count
     *   }
     * })
    **/
    count<T extends DeliveryInfoTranslationCountArgs>(
      args?: Subset<T, DeliveryInfoTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryInfoTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryInfoTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryInfoTranslationAggregateArgs>(args: Subset<T, DeliveryInfoTranslationAggregateArgs>): Prisma.PrismaPromise<GetDeliveryInfoTranslationAggregateType<T>>

    /**
     * Group by DeliveryInfoTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryInfoTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryInfoTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryInfoTranslationGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryInfoTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryInfoTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryInfoTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryInfoTranslation model
   */
  readonly fields: DeliveryInfoTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryInfoTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryInfoTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deliveryInfo<T extends DeliveryInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryInfoDefaultArgs<ExtArgs>>): Prisma__DeliveryInfoClient<$Result.GetResult<Prisma.$DeliveryInfoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryInfoTranslation model
   */ 
  interface DeliveryInfoTranslationFieldRefs {
    readonly id: FieldRef<"DeliveryInfoTranslation", 'String'>
    readonly createdAt: FieldRef<"DeliveryInfoTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"DeliveryInfoTranslation", 'DateTime'>
    readonly description: FieldRef<"DeliveryInfoTranslation", 'String'>
    readonly languageCode: FieldRef<"DeliveryInfoTranslation", 'String'>
    readonly deliveryId: FieldRef<"DeliveryInfoTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryInfoTranslation findUnique
   */
  export type DeliveryInfoTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfoTranslation to fetch.
     */
    where: DeliveryInfoTranslationWhereUniqueInput
  }

  /**
   * DeliveryInfoTranslation findUniqueOrThrow
   */
  export type DeliveryInfoTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfoTranslation to fetch.
     */
    where: DeliveryInfoTranslationWhereUniqueInput
  }

  /**
   * DeliveryInfoTranslation findFirst
   */
  export type DeliveryInfoTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfoTranslation to fetch.
     */
    where?: DeliveryInfoTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryInfoTranslations to fetch.
     */
    orderBy?: DeliveryInfoTranslationOrderByWithRelationInput | DeliveryInfoTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryInfoTranslations.
     */
    cursor?: DeliveryInfoTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryInfoTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryInfoTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryInfoTranslations.
     */
    distinct?: DeliveryInfoTranslationScalarFieldEnum | DeliveryInfoTranslationScalarFieldEnum[]
  }

  /**
   * DeliveryInfoTranslation findFirstOrThrow
   */
  export type DeliveryInfoTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfoTranslation to fetch.
     */
    where?: DeliveryInfoTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryInfoTranslations to fetch.
     */
    orderBy?: DeliveryInfoTranslationOrderByWithRelationInput | DeliveryInfoTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryInfoTranslations.
     */
    cursor?: DeliveryInfoTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryInfoTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryInfoTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryInfoTranslations.
     */
    distinct?: DeliveryInfoTranslationScalarFieldEnum | DeliveryInfoTranslationScalarFieldEnum[]
  }

  /**
   * DeliveryInfoTranslation findMany
   */
  export type DeliveryInfoTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryInfoTranslations to fetch.
     */
    where?: DeliveryInfoTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryInfoTranslations to fetch.
     */
    orderBy?: DeliveryInfoTranslationOrderByWithRelationInput | DeliveryInfoTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryInfoTranslations.
     */
    cursor?: DeliveryInfoTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryInfoTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryInfoTranslations.
     */
    skip?: number
    distinct?: DeliveryInfoTranslationScalarFieldEnum | DeliveryInfoTranslationScalarFieldEnum[]
  }

  /**
   * DeliveryInfoTranslation create
   */
  export type DeliveryInfoTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryInfoTranslation.
     */
    data: XOR<DeliveryInfoTranslationCreateInput, DeliveryInfoTranslationUncheckedCreateInput>
  }

  /**
   * DeliveryInfoTranslation createMany
   */
  export type DeliveryInfoTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryInfoTranslations.
     */
    data: DeliveryInfoTranslationCreateManyInput | DeliveryInfoTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryInfoTranslation createManyAndReturn
   */
  export type DeliveryInfoTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeliveryInfoTranslations.
     */
    data: DeliveryInfoTranslationCreateManyInput | DeliveryInfoTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryInfoTranslation update
   */
  export type DeliveryInfoTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryInfoTranslation.
     */
    data: XOR<DeliveryInfoTranslationUpdateInput, DeliveryInfoTranslationUncheckedUpdateInput>
    /**
     * Choose, which DeliveryInfoTranslation to update.
     */
    where: DeliveryInfoTranslationWhereUniqueInput
  }

  /**
   * DeliveryInfoTranslation updateMany
   */
  export type DeliveryInfoTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryInfoTranslations.
     */
    data: XOR<DeliveryInfoTranslationUpdateManyMutationInput, DeliveryInfoTranslationUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryInfoTranslations to update
     */
    where?: DeliveryInfoTranslationWhereInput
  }

  /**
   * DeliveryInfoTranslation upsert
   */
  export type DeliveryInfoTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryInfoTranslation to update in case it exists.
     */
    where: DeliveryInfoTranslationWhereUniqueInput
    /**
     * In case the DeliveryInfoTranslation found by the `where` argument doesn't exist, create a new DeliveryInfoTranslation with this data.
     */
    create: XOR<DeliveryInfoTranslationCreateInput, DeliveryInfoTranslationUncheckedCreateInput>
    /**
     * In case the DeliveryInfoTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryInfoTranslationUpdateInput, DeliveryInfoTranslationUncheckedUpdateInput>
  }

  /**
   * DeliveryInfoTranslation delete
   */
  export type DeliveryInfoTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
    /**
     * Filter which DeliveryInfoTranslation to delete.
     */
    where: DeliveryInfoTranslationWhereUniqueInput
  }

  /**
   * DeliveryInfoTranslation deleteMany
   */
  export type DeliveryInfoTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryInfoTranslations to delete
     */
    where?: DeliveryInfoTranslationWhereInput
  }

  /**
   * DeliveryInfoTranslation without action
   */
  export type DeliveryInfoTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryInfoTranslation
     */
    select?: DeliveryInfoTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInfoTranslationInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    description: number
    _all: number
  }


  export type PaymentMethodMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    description: string
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    translation?: boolean | PaymentMethod$translationArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
  }, ExtArgs["result"]["paymentMethod"]>

  export type PaymentMethodSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
  }

  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translation?: boolean | PaymentMethod$translationArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      translation: Prisma.$PaymentMethodTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      description: string
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethods and returns the data saved in the database.
     * @param {PaymentMethodCreateManyAndReturnArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethods and only return the `id`
     * const paymentMethodWithIdOnly = await prisma.paymentMethod.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translation<T extends PaymentMethod$translationArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$translationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */ 
  interface PaymentMethodFieldRefs {
    readonly id: FieldRef<"PaymentMethod", 'String'>
    readonly createdAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethod", 'DateTime'>
    readonly description: FieldRef<"PaymentMethod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod createManyAndReturn
   */
  export type PaymentMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
  }

  /**
   * PaymentMethod.translation
   */
  export type PaymentMethod$translationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    where?: PaymentMethodTranslationWhereInput
    orderBy?: PaymentMethodTranslationOrderByWithRelationInput | PaymentMethodTranslationOrderByWithRelationInput[]
    cursor?: PaymentMethodTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentMethodTranslationScalarFieldEnum | PaymentMethodTranslationScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethodTranslation
   */

  export type AggregatePaymentMethodTranslation = {
    _count: PaymentMethodTranslationCountAggregateOutputType | null
    _min: PaymentMethodTranslationMinAggregateOutputType | null
    _max: PaymentMethodTranslationMaxAggregateOutputType | null
  }

  export type PaymentMethodTranslationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    languageCode: string | null
    paymentMethodId: string | null
  }

  export type PaymentMethodTranslationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    languageCode: string | null
    paymentMethodId: string | null
  }

  export type PaymentMethodTranslationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    description: number
    languageCode: number
    paymentMethodId: number
    _all: number
  }


  export type PaymentMethodTranslationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    languageCode?: true
    paymentMethodId?: true
  }

  export type PaymentMethodTranslationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    languageCode?: true
    paymentMethodId?: true
  }

  export type PaymentMethodTranslationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    languageCode?: true
    paymentMethodId?: true
    _all?: true
  }

  export type PaymentMethodTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethodTranslation to aggregate.
     */
    where?: PaymentMethodTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethodTranslations to fetch.
     */
    orderBy?: PaymentMethodTranslationOrderByWithRelationInput | PaymentMethodTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethodTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethodTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethodTranslations
    **/
    _count?: true | PaymentMethodTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodTranslationMaxAggregateInputType
  }

  export type GetPaymentMethodTranslationAggregateType<T extends PaymentMethodTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethodTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethodTranslation[P]>
      : GetScalarType<T[P], AggregatePaymentMethodTranslation[P]>
  }




  export type PaymentMethodTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodTranslationWhereInput
    orderBy?: PaymentMethodTranslationOrderByWithAggregationInput | PaymentMethodTranslationOrderByWithAggregationInput[]
    by: PaymentMethodTranslationScalarFieldEnum[] | PaymentMethodTranslationScalarFieldEnum
    having?: PaymentMethodTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodTranslationCountAggregateInputType | true
    _min?: PaymentMethodTranslationMinAggregateInputType
    _max?: PaymentMethodTranslationMaxAggregateInputType
  }

  export type PaymentMethodTranslationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    description: string
    languageCode: string
    paymentMethodId: string
    _count: PaymentMethodTranslationCountAggregateOutputType | null
    _min: PaymentMethodTranslationMinAggregateOutputType | null
    _max: PaymentMethodTranslationMaxAggregateOutputType | null
  }

  type GetPaymentMethodTranslationGroupByPayload<T extends PaymentMethodTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodTranslationGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    languageCode?: boolean
    paymentMethodId?: boolean
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethodTranslation"]>

  export type PaymentMethodTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    languageCode?: boolean
    paymentMethodId?: boolean
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethodTranslation"]>

  export type PaymentMethodTranslationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    languageCode?: boolean
    paymentMethodId?: boolean
  }

  export type PaymentMethodTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }
  export type PaymentMethodTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethodTranslation"
    objects: {
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      description: string
      languageCode: string
      paymentMethodId: string
    }, ExtArgs["result"]["paymentMethodTranslation"]>
    composites: {}
  }

  type PaymentMethodTranslationGetPayload<S extends boolean | null | undefined | PaymentMethodTranslationDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodTranslationPayload, S>

  type PaymentMethodTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentMethodTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentMethodTranslationCountAggregateInputType | true
    }

  export interface PaymentMethodTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethodTranslation'], meta: { name: 'PaymentMethodTranslation' } }
    /**
     * Find zero or one PaymentMethodTranslation that matches the filter.
     * @param {PaymentMethodTranslationFindUniqueArgs} args - Arguments to find a PaymentMethodTranslation
     * @example
     * // Get one PaymentMethodTranslation
     * const paymentMethodTranslation = await prisma.paymentMethodTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodTranslationFindUniqueArgs>(args: SelectSubset<T, PaymentMethodTranslationFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodTranslationClient<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentMethodTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentMethodTranslationFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethodTranslation
     * @example
     * // Get one PaymentMethodTranslation
     * const paymentMethodTranslation = await prisma.paymentMethodTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodTranslationClient<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentMethodTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodTranslationFindFirstArgs} args - Arguments to find a PaymentMethodTranslation
     * @example
     * // Get one PaymentMethodTranslation
     * const paymentMethodTranslation = await prisma.paymentMethodTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodTranslationFindFirstArgs>(args?: SelectSubset<T, PaymentMethodTranslationFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodTranslationClient<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentMethodTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodTranslationFindFirstOrThrowArgs} args - Arguments to find a PaymentMethodTranslation
     * @example
     * // Get one PaymentMethodTranslation
     * const paymentMethodTranslation = await prisma.paymentMethodTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodTranslationClient<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentMethodTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethodTranslations
     * const paymentMethodTranslations = await prisma.paymentMethodTranslation.findMany()
     * 
     * // Get first 10 PaymentMethodTranslations
     * const paymentMethodTranslations = await prisma.paymentMethodTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentMethodTranslationWithIdOnly = await prisma.paymentMethodTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentMethodTranslationFindManyArgs>(args?: SelectSubset<T, PaymentMethodTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentMethodTranslation.
     * @param {PaymentMethodTranslationCreateArgs} args - Arguments to create a PaymentMethodTranslation.
     * @example
     * // Create one PaymentMethodTranslation
     * const PaymentMethodTranslation = await prisma.paymentMethodTranslation.create({
     *   data: {
     *     // ... data to create a PaymentMethodTranslation
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodTranslationCreateArgs>(args: SelectSubset<T, PaymentMethodTranslationCreateArgs<ExtArgs>>): Prisma__PaymentMethodTranslationClient<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentMethodTranslations.
     * @param {PaymentMethodTranslationCreateManyArgs} args - Arguments to create many PaymentMethodTranslations.
     * @example
     * // Create many PaymentMethodTranslations
     * const paymentMethodTranslation = await prisma.paymentMethodTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodTranslationCreateManyArgs>(args?: SelectSubset<T, PaymentMethodTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentMethodTranslations and returns the data saved in the database.
     * @param {PaymentMethodTranslationCreateManyAndReturnArgs} args - Arguments to create many PaymentMethodTranslations.
     * @example
     * // Create many PaymentMethodTranslations
     * const paymentMethodTranslation = await prisma.paymentMethodTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentMethodTranslations and only return the `id`
     * const paymentMethodTranslationWithIdOnly = await prisma.paymentMethodTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentMethodTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentMethodTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentMethodTranslation.
     * @param {PaymentMethodTranslationDeleteArgs} args - Arguments to delete one PaymentMethodTranslation.
     * @example
     * // Delete one PaymentMethodTranslation
     * const PaymentMethodTranslation = await prisma.paymentMethodTranslation.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethodTranslation
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodTranslationDeleteArgs>(args: SelectSubset<T, PaymentMethodTranslationDeleteArgs<ExtArgs>>): Prisma__PaymentMethodTranslationClient<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentMethodTranslation.
     * @param {PaymentMethodTranslationUpdateArgs} args - Arguments to update one PaymentMethodTranslation.
     * @example
     * // Update one PaymentMethodTranslation
     * const paymentMethodTranslation = await prisma.paymentMethodTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodTranslationUpdateArgs>(args: SelectSubset<T, PaymentMethodTranslationUpdateArgs<ExtArgs>>): Prisma__PaymentMethodTranslationClient<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentMethodTranslations.
     * @param {PaymentMethodTranslationDeleteManyArgs} args - Arguments to filter PaymentMethodTranslations to delete.
     * @example
     * // Delete a few PaymentMethodTranslations
     * const { count } = await prisma.paymentMethodTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodTranslationDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethodTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethodTranslations
     * const paymentMethodTranslation = await prisma.paymentMethodTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodTranslationUpdateManyArgs>(args: SelectSubset<T, PaymentMethodTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethodTranslation.
     * @param {PaymentMethodTranslationUpsertArgs} args - Arguments to update or create a PaymentMethodTranslation.
     * @example
     * // Update or create a PaymentMethodTranslation
     * const paymentMethodTranslation = await prisma.paymentMethodTranslation.upsert({
     *   create: {
     *     // ... data to create a PaymentMethodTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethodTranslation we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodTranslationUpsertArgs>(args: SelectSubset<T, PaymentMethodTranslationUpsertArgs<ExtArgs>>): Prisma__PaymentMethodTranslationClient<$Result.GetResult<Prisma.$PaymentMethodTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentMethodTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodTranslationCountArgs} args - Arguments to filter PaymentMethodTranslations to count.
     * @example
     * // Count the number of PaymentMethodTranslations
     * const count = await prisma.paymentMethodTranslation.count({
     *   where: {
     *     // ... the filter for the PaymentMethodTranslations we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodTranslationCountArgs>(
      args?: Subset<T, PaymentMethodTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethodTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodTranslationAggregateArgs>(args: Subset<T, PaymentMethodTranslationAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodTranslationAggregateType<T>>

    /**
     * Group by PaymentMethodTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodTranslationGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethodTranslation model
   */
  readonly fields: PaymentMethodTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethodTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethodTranslation model
   */ 
  interface PaymentMethodTranslationFieldRefs {
    readonly id: FieldRef<"PaymentMethodTranslation", 'String'>
    readonly createdAt: FieldRef<"PaymentMethodTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentMethodTranslation", 'DateTime'>
    readonly description: FieldRef<"PaymentMethodTranslation", 'String'>
    readonly languageCode: FieldRef<"PaymentMethodTranslation", 'String'>
    readonly paymentMethodId: FieldRef<"PaymentMethodTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethodTranslation findUnique
   */
  export type PaymentMethodTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodTranslation to fetch.
     */
    where: PaymentMethodTranslationWhereUniqueInput
  }

  /**
   * PaymentMethodTranslation findUniqueOrThrow
   */
  export type PaymentMethodTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodTranslation to fetch.
     */
    where: PaymentMethodTranslationWhereUniqueInput
  }

  /**
   * PaymentMethodTranslation findFirst
   */
  export type PaymentMethodTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodTranslation to fetch.
     */
    where?: PaymentMethodTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethodTranslations to fetch.
     */
    orderBy?: PaymentMethodTranslationOrderByWithRelationInput | PaymentMethodTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethodTranslations.
     */
    cursor?: PaymentMethodTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethodTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethodTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethodTranslations.
     */
    distinct?: PaymentMethodTranslationScalarFieldEnum | PaymentMethodTranslationScalarFieldEnum[]
  }

  /**
   * PaymentMethodTranslation findFirstOrThrow
   */
  export type PaymentMethodTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodTranslation to fetch.
     */
    where?: PaymentMethodTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethodTranslations to fetch.
     */
    orderBy?: PaymentMethodTranslationOrderByWithRelationInput | PaymentMethodTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethodTranslations.
     */
    cursor?: PaymentMethodTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethodTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethodTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethodTranslations.
     */
    distinct?: PaymentMethodTranslationScalarFieldEnum | PaymentMethodTranslationScalarFieldEnum[]
  }

  /**
   * PaymentMethodTranslation findMany
   */
  export type PaymentMethodTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethodTranslations to fetch.
     */
    where?: PaymentMethodTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethodTranslations to fetch.
     */
    orderBy?: PaymentMethodTranslationOrderByWithRelationInput | PaymentMethodTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethodTranslations.
     */
    cursor?: PaymentMethodTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethodTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethodTranslations.
     */
    skip?: number
    distinct?: PaymentMethodTranslationScalarFieldEnum | PaymentMethodTranslationScalarFieldEnum[]
  }

  /**
   * PaymentMethodTranslation create
   */
  export type PaymentMethodTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethodTranslation.
     */
    data: XOR<PaymentMethodTranslationCreateInput, PaymentMethodTranslationUncheckedCreateInput>
  }

  /**
   * PaymentMethodTranslation createMany
   */
  export type PaymentMethodTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethodTranslations.
     */
    data: PaymentMethodTranslationCreateManyInput | PaymentMethodTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentMethodTranslation createManyAndReturn
   */
  export type PaymentMethodTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentMethodTranslations.
     */
    data: PaymentMethodTranslationCreateManyInput | PaymentMethodTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentMethodTranslation update
   */
  export type PaymentMethodTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethodTranslation.
     */
    data: XOR<PaymentMethodTranslationUpdateInput, PaymentMethodTranslationUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethodTranslation to update.
     */
    where: PaymentMethodTranslationWhereUniqueInput
  }

  /**
   * PaymentMethodTranslation updateMany
   */
  export type PaymentMethodTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethodTranslations.
     */
    data: XOR<PaymentMethodTranslationUpdateManyMutationInput, PaymentMethodTranslationUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethodTranslations to update
     */
    where?: PaymentMethodTranslationWhereInput
  }

  /**
   * PaymentMethodTranslation upsert
   */
  export type PaymentMethodTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethodTranslation to update in case it exists.
     */
    where: PaymentMethodTranslationWhereUniqueInput
    /**
     * In case the PaymentMethodTranslation found by the `where` argument doesn't exist, create a new PaymentMethodTranslation with this data.
     */
    create: XOR<PaymentMethodTranslationCreateInput, PaymentMethodTranslationUncheckedCreateInput>
    /**
     * In case the PaymentMethodTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodTranslationUpdateInput, PaymentMethodTranslationUncheckedUpdateInput>
  }

  /**
   * PaymentMethodTranslation delete
   */
  export type PaymentMethodTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethodTranslation to delete.
     */
    where: PaymentMethodTranslationWhereUniqueInput
  }

  /**
   * PaymentMethodTranslation deleteMany
   */
  export type PaymentMethodTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethodTranslations to delete
     */
    where?: PaymentMethodTranslationWhereInput
  }

  /**
   * PaymentMethodTranslation without action
   */
  export type PaymentMethodTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodTranslation
     */
    select?: PaymentMethodTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodTranslationInclude<ExtArgs> | null
  }


  /**
   * Model FAQ
   */

  export type AggregateFAQ = {
    _count: FAQCountAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  export type FAQMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updateAt: Date | null
    question: string | null
    answer: string | null
  }

  export type FAQMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updateAt: Date | null
    question: string | null
    answer: string | null
  }

  export type FAQCountAggregateOutputType = {
    id: number
    createdAt: number
    updateAt: number
    question: number
    answer: number
    _all: number
  }


  export type FAQMinAggregateInputType = {
    id?: true
    createdAt?: true
    updateAt?: true
    question?: true
    answer?: true
  }

  export type FAQMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updateAt?: true
    question?: true
    answer?: true
  }

  export type FAQCountAggregateInputType = {
    id?: true
    createdAt?: true
    updateAt?: true
    question?: true
    answer?: true
    _all?: true
  }

  export type FAQAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQ to aggregate.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQS
    **/
    _count?: true | FAQCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQMaxAggregateInputType
  }

  export type GetFAQAggregateType<T extends FAQAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQ]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQ[P]>
      : GetScalarType<T[P], AggregateFAQ[P]>
  }




  export type FAQGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQWhereInput
    orderBy?: FAQOrderByWithAggregationInput | FAQOrderByWithAggregationInput[]
    by: FAQScalarFieldEnum[] | FAQScalarFieldEnum
    having?: FAQScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQCountAggregateInputType | true
    _min?: FAQMinAggregateInputType
    _max?: FAQMaxAggregateInputType
  }

  export type FAQGroupByOutputType = {
    id: string
    createdAt: Date
    updateAt: Date
    question: string
    answer: string
    _count: FAQCountAggregateOutputType | null
    _min: FAQMinAggregateOutputType | null
    _max: FAQMaxAggregateOutputType | null
  }

  type GetFAQGroupByPayload<T extends FAQGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQGroupByOutputType[P]>
            : GetScalarType<T[P], FAQGroupByOutputType[P]>
        }
      >
    >


  export type FAQSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updateAt?: boolean
    question?: boolean
    answer?: boolean
    translations?: boolean | FAQ$translationsArgs<ExtArgs>
    _count?: boolean | FAQCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updateAt?: boolean
    question?: boolean
    answer?: boolean
  }, ExtArgs["result"]["fAQ"]>

  export type FAQSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updateAt?: boolean
    question?: boolean
    answer?: boolean
  }

  export type FAQInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | FAQ$translationsArgs<ExtArgs>
    _count?: boolean | FAQCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FAQIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FAQPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQ"
    objects: {
      translations: Prisma.$FAQTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updateAt: Date
      question: string
      answer: string
    }, ExtArgs["result"]["fAQ"]>
    composites: {}
  }

  type FAQGetPayload<S extends boolean | null | undefined | FAQDefaultArgs> = $Result.GetResult<Prisma.$FAQPayload, S>

  type FAQCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FAQFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FAQCountAggregateInputType | true
    }

  export interface FAQDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQ'], meta: { name: 'FAQ' } }
    /**
     * Find zero or one FAQ that matches the filter.
     * @param {FAQFindUniqueArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQFindUniqueArgs>(args: SelectSubset<T, FAQFindUniqueArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FAQ that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FAQFindUniqueOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FAQ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQFindFirstArgs>(args?: SelectSubset<T, FAQFindFirstArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FAQ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindFirstOrThrowArgs} args - Arguments to find a FAQ
     * @example
     * // Get one FAQ
     * const fAQ = await prisma.fAQ.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FAQS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQS
     * const fAQS = await prisma.fAQ.findMany()
     * 
     * // Get first 10 FAQS
     * const fAQS = await prisma.fAQ.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQWithIdOnly = await prisma.fAQ.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQFindManyArgs>(args?: SelectSubset<T, FAQFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FAQ.
     * @param {FAQCreateArgs} args - Arguments to create a FAQ.
     * @example
     * // Create one FAQ
     * const FAQ = await prisma.fAQ.create({
     *   data: {
     *     // ... data to create a FAQ
     *   }
     * })
     * 
     */
    create<T extends FAQCreateArgs>(args: SelectSubset<T, FAQCreateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FAQS.
     * @param {FAQCreateManyArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQCreateManyArgs>(args?: SelectSubset<T, FAQCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQS and returns the data saved in the database.
     * @param {FAQCreateManyAndReturnArgs} args - Arguments to create many FAQS.
     * @example
     * // Create many FAQS
     * const fAQ = await prisma.fAQ.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQS and only return the `id`
     * const fAQWithIdOnly = await prisma.fAQ.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FAQ.
     * @param {FAQDeleteArgs} args - Arguments to delete one FAQ.
     * @example
     * // Delete one FAQ
     * const FAQ = await prisma.fAQ.delete({
     *   where: {
     *     // ... filter to delete one FAQ
     *   }
     * })
     * 
     */
    delete<T extends FAQDeleteArgs>(args: SelectSubset<T, FAQDeleteArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FAQ.
     * @param {FAQUpdateArgs} args - Arguments to update one FAQ.
     * @example
     * // Update one FAQ
     * const fAQ = await prisma.fAQ.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQUpdateArgs>(args: SelectSubset<T, FAQUpdateArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FAQS.
     * @param {FAQDeleteManyArgs} args - Arguments to filter FAQS to delete.
     * @example
     * // Delete a few FAQS
     * const { count } = await prisma.fAQ.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQDeleteManyArgs>(args?: SelectSubset<T, FAQDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQS
     * const fAQ = await prisma.fAQ.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQUpdateManyArgs>(args: SelectSubset<T, FAQUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FAQ.
     * @param {FAQUpsertArgs} args - Arguments to update or create a FAQ.
     * @example
     * // Update or create a FAQ
     * const fAQ = await prisma.fAQ.upsert({
     *   create: {
     *     // ... data to create a FAQ
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQ we want to update
     *   }
     * })
     */
    upsert<T extends FAQUpsertArgs>(args: SelectSubset<T, FAQUpsertArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FAQS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQCountArgs} args - Arguments to filter FAQS to count.
     * @example
     * // Count the number of FAQS
     * const count = await prisma.fAQ.count({
     *   where: {
     *     // ... the filter for the FAQS we want to count
     *   }
     * })
    **/
    count<T extends FAQCountArgs>(
      args?: Subset<T, FAQCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQAggregateArgs>(args: Subset<T, FAQAggregateArgs>): Prisma.PrismaPromise<GetFAQAggregateType<T>>

    /**
     * Group by FAQ.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQGroupByArgs['orderBy'] }
        : { orderBy?: FAQGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQ model
   */
  readonly fields: FAQFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQ.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends FAQ$translationsArgs<ExtArgs> = {}>(args?: Subset<T, FAQ$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQ model
   */ 
  interface FAQFieldRefs {
    readonly id: FieldRef<"FAQ", 'String'>
    readonly createdAt: FieldRef<"FAQ", 'DateTime'>
    readonly updateAt: FieldRef<"FAQ", 'DateTime'>
    readonly question: FieldRef<"FAQ", 'String'>
    readonly answer: FieldRef<"FAQ", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FAQ findUnique
   */
  export type FAQFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findUniqueOrThrow
   */
  export type FAQFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ findFirst
   */
  export type FAQFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findFirstOrThrow
   */
  export type FAQFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQ to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQS.
     */
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ findMany
   */
  export type FAQFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter, which FAQS to fetch.
     */
    where?: FAQWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQS to fetch.
     */
    orderBy?: FAQOrderByWithRelationInput | FAQOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQS.
     */
    cursor?: FAQWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQS.
     */
    skip?: number
    distinct?: FAQScalarFieldEnum | FAQScalarFieldEnum[]
  }

  /**
   * FAQ create
   */
  export type FAQCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * The data needed to create a FAQ.
     */
    data: XOR<FAQCreateInput, FAQUncheckedCreateInput>
  }

  /**
   * FAQ createMany
   */
  export type FAQCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ createManyAndReturn
   */
  export type FAQCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FAQS.
     */
    data: FAQCreateManyInput | FAQCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQ update
   */
  export type FAQUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * The data needed to update a FAQ.
     */
    data: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
    /**
     * Choose, which FAQ to update.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ updateMany
   */
  export type FAQUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQS.
     */
    data: XOR<FAQUpdateManyMutationInput, FAQUncheckedUpdateManyInput>
    /**
     * Filter which FAQS to update
     */
    where?: FAQWhereInput
  }

  /**
   * FAQ upsert
   */
  export type FAQUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * The filter to search for the FAQ to update in case it exists.
     */
    where: FAQWhereUniqueInput
    /**
     * In case the FAQ found by the `where` argument doesn't exist, create a new FAQ with this data.
     */
    create: XOR<FAQCreateInput, FAQUncheckedCreateInput>
    /**
     * In case the FAQ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQUpdateInput, FAQUncheckedUpdateInput>
  }

  /**
   * FAQ delete
   */
  export type FAQDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
    /**
     * Filter which FAQ to delete.
     */
    where: FAQWhereUniqueInput
  }

  /**
   * FAQ deleteMany
   */
  export type FAQDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQS to delete
     */
    where?: FAQWhereInput
  }

  /**
   * FAQ.translations
   */
  export type FAQ$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    where?: FAQTranslationWhereInput
    orderBy?: FAQTranslationOrderByWithRelationInput | FAQTranslationOrderByWithRelationInput[]
    cursor?: FAQTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FAQTranslationScalarFieldEnum | FAQTranslationScalarFieldEnum[]
  }

  /**
   * FAQ without action
   */
  export type FAQDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQ
     */
    select?: FAQSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQInclude<ExtArgs> | null
  }


  /**
   * Model FAQTranslation
   */

  export type AggregateFAQTranslation = {
    _count: FAQTranslationCountAggregateOutputType | null
    _min: FAQTranslationMinAggregateOutputType | null
    _max: FAQTranslationMaxAggregateOutputType | null
  }

  export type FAQTranslationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    question: string | null
    answer: string | null
    languageCode: string | null
    faqId: string | null
  }

  export type FAQTranslationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    question: string | null
    answer: string | null
    languageCode: string | null
    faqId: string | null
  }

  export type FAQTranslationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    question: number
    answer: number
    languageCode: number
    faqId: number
    _all: number
  }


  export type FAQTranslationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    question?: true
    answer?: true
    languageCode?: true
    faqId?: true
  }

  export type FAQTranslationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    question?: true
    answer?: true
    languageCode?: true
    faqId?: true
  }

  export type FAQTranslationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    question?: true
    answer?: true
    languageCode?: true
    faqId?: true
    _all?: true
  }

  export type FAQTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQTranslation to aggregate.
     */
    where?: FAQTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQTranslations to fetch.
     */
    orderBy?: FAQTranslationOrderByWithRelationInput | FAQTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FAQTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FAQTranslations
    **/
    _count?: true | FAQTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FAQTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FAQTranslationMaxAggregateInputType
  }

  export type GetFAQTranslationAggregateType<T extends FAQTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateFAQTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFAQTranslation[P]>
      : GetScalarType<T[P], AggregateFAQTranslation[P]>
  }




  export type FAQTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FAQTranslationWhereInput
    orderBy?: FAQTranslationOrderByWithAggregationInput | FAQTranslationOrderByWithAggregationInput[]
    by: FAQTranslationScalarFieldEnum[] | FAQTranslationScalarFieldEnum
    having?: FAQTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FAQTranslationCountAggregateInputType | true
    _min?: FAQTranslationMinAggregateInputType
    _max?: FAQTranslationMaxAggregateInputType
  }

  export type FAQTranslationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    question: string
    answer: string
    languageCode: string
    faqId: string
    _count: FAQTranslationCountAggregateOutputType | null
    _min: FAQTranslationMinAggregateOutputType | null
    _max: FAQTranslationMaxAggregateOutputType | null
  }

  type GetFAQTranslationGroupByPayload<T extends FAQTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FAQTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FAQTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FAQTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], FAQTranslationGroupByOutputType[P]>
        }
      >
    >


  export type FAQTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean
    answer?: boolean
    languageCode?: boolean
    faqId?: boolean
    faq?: boolean | FAQDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQTranslation"]>

  export type FAQTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean
    answer?: boolean
    languageCode?: boolean
    faqId?: boolean
    faq?: boolean | FAQDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fAQTranslation"]>

  export type FAQTranslationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    question?: boolean
    answer?: boolean
    languageCode?: boolean
    faqId?: boolean
  }

  export type FAQTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faq?: boolean | FAQDefaultArgs<ExtArgs>
  }
  export type FAQTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faq?: boolean | FAQDefaultArgs<ExtArgs>
  }

  export type $FAQTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FAQTranslation"
    objects: {
      faq: Prisma.$FAQPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      question: string
      answer: string
      languageCode: string
      faqId: string
    }, ExtArgs["result"]["fAQTranslation"]>
    composites: {}
  }

  type FAQTranslationGetPayload<S extends boolean | null | undefined | FAQTranslationDefaultArgs> = $Result.GetResult<Prisma.$FAQTranslationPayload, S>

  type FAQTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FAQTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FAQTranslationCountAggregateInputType | true
    }

  export interface FAQTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FAQTranslation'], meta: { name: 'FAQTranslation' } }
    /**
     * Find zero or one FAQTranslation that matches the filter.
     * @param {FAQTranslationFindUniqueArgs} args - Arguments to find a FAQTranslation
     * @example
     * // Get one FAQTranslation
     * const fAQTranslation = await prisma.fAQTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FAQTranslationFindUniqueArgs>(args: SelectSubset<T, FAQTranslationFindUniqueArgs<ExtArgs>>): Prisma__FAQTranslationClient<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FAQTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FAQTranslationFindUniqueOrThrowArgs} args - Arguments to find a FAQTranslation
     * @example
     * // Get one FAQTranslation
     * const fAQTranslation = await prisma.fAQTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FAQTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, FAQTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FAQTranslationClient<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FAQTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQTranslationFindFirstArgs} args - Arguments to find a FAQTranslation
     * @example
     * // Get one FAQTranslation
     * const fAQTranslation = await prisma.fAQTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FAQTranslationFindFirstArgs>(args?: SelectSubset<T, FAQTranslationFindFirstArgs<ExtArgs>>): Prisma__FAQTranslationClient<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FAQTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQTranslationFindFirstOrThrowArgs} args - Arguments to find a FAQTranslation
     * @example
     * // Get one FAQTranslation
     * const fAQTranslation = await prisma.fAQTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FAQTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, FAQTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FAQTranslationClient<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FAQTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FAQTranslations
     * const fAQTranslations = await prisma.fAQTranslation.findMany()
     * 
     * // Get first 10 FAQTranslations
     * const fAQTranslations = await prisma.fAQTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fAQTranslationWithIdOnly = await prisma.fAQTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FAQTranslationFindManyArgs>(args?: SelectSubset<T, FAQTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FAQTranslation.
     * @param {FAQTranslationCreateArgs} args - Arguments to create a FAQTranslation.
     * @example
     * // Create one FAQTranslation
     * const FAQTranslation = await prisma.fAQTranslation.create({
     *   data: {
     *     // ... data to create a FAQTranslation
     *   }
     * })
     * 
     */
    create<T extends FAQTranslationCreateArgs>(args: SelectSubset<T, FAQTranslationCreateArgs<ExtArgs>>): Prisma__FAQTranslationClient<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FAQTranslations.
     * @param {FAQTranslationCreateManyArgs} args - Arguments to create many FAQTranslations.
     * @example
     * // Create many FAQTranslations
     * const fAQTranslation = await prisma.fAQTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FAQTranslationCreateManyArgs>(args?: SelectSubset<T, FAQTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FAQTranslations and returns the data saved in the database.
     * @param {FAQTranslationCreateManyAndReturnArgs} args - Arguments to create many FAQTranslations.
     * @example
     * // Create many FAQTranslations
     * const fAQTranslation = await prisma.fAQTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FAQTranslations and only return the `id`
     * const fAQTranslationWithIdOnly = await prisma.fAQTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FAQTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, FAQTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FAQTranslation.
     * @param {FAQTranslationDeleteArgs} args - Arguments to delete one FAQTranslation.
     * @example
     * // Delete one FAQTranslation
     * const FAQTranslation = await prisma.fAQTranslation.delete({
     *   where: {
     *     // ... filter to delete one FAQTranslation
     *   }
     * })
     * 
     */
    delete<T extends FAQTranslationDeleteArgs>(args: SelectSubset<T, FAQTranslationDeleteArgs<ExtArgs>>): Prisma__FAQTranslationClient<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FAQTranslation.
     * @param {FAQTranslationUpdateArgs} args - Arguments to update one FAQTranslation.
     * @example
     * // Update one FAQTranslation
     * const fAQTranslation = await prisma.fAQTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FAQTranslationUpdateArgs>(args: SelectSubset<T, FAQTranslationUpdateArgs<ExtArgs>>): Prisma__FAQTranslationClient<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FAQTranslations.
     * @param {FAQTranslationDeleteManyArgs} args - Arguments to filter FAQTranslations to delete.
     * @example
     * // Delete a few FAQTranslations
     * const { count } = await prisma.fAQTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FAQTranslationDeleteManyArgs>(args?: SelectSubset<T, FAQTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FAQTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FAQTranslations
     * const fAQTranslation = await prisma.fAQTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FAQTranslationUpdateManyArgs>(args: SelectSubset<T, FAQTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FAQTranslation.
     * @param {FAQTranslationUpsertArgs} args - Arguments to update or create a FAQTranslation.
     * @example
     * // Update or create a FAQTranslation
     * const fAQTranslation = await prisma.fAQTranslation.upsert({
     *   create: {
     *     // ... data to create a FAQTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FAQTranslation we want to update
     *   }
     * })
     */
    upsert<T extends FAQTranslationUpsertArgs>(args: SelectSubset<T, FAQTranslationUpsertArgs<ExtArgs>>): Prisma__FAQTranslationClient<$Result.GetResult<Prisma.$FAQTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FAQTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQTranslationCountArgs} args - Arguments to filter FAQTranslations to count.
     * @example
     * // Count the number of FAQTranslations
     * const count = await prisma.fAQTranslation.count({
     *   where: {
     *     // ... the filter for the FAQTranslations we want to count
     *   }
     * })
    **/
    count<T extends FAQTranslationCountArgs>(
      args?: Subset<T, FAQTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FAQTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FAQTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FAQTranslationAggregateArgs>(args: Subset<T, FAQTranslationAggregateArgs>): Prisma.PrismaPromise<GetFAQTranslationAggregateType<T>>

    /**
     * Group by FAQTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FAQTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FAQTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FAQTranslationGroupByArgs['orderBy'] }
        : { orderBy?: FAQTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FAQTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFAQTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FAQTranslation model
   */
  readonly fields: FAQTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FAQTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FAQTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    faq<T extends FAQDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FAQDefaultArgs<ExtArgs>>): Prisma__FAQClient<$Result.GetResult<Prisma.$FAQPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FAQTranslation model
   */ 
  interface FAQTranslationFieldRefs {
    readonly id: FieldRef<"FAQTranslation", 'String'>
    readonly createdAt: FieldRef<"FAQTranslation", 'DateTime'>
    readonly updatedAt: FieldRef<"FAQTranslation", 'DateTime'>
    readonly question: FieldRef<"FAQTranslation", 'String'>
    readonly answer: FieldRef<"FAQTranslation", 'String'>
    readonly languageCode: FieldRef<"FAQTranslation", 'String'>
    readonly faqId: FieldRef<"FAQTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FAQTranslation findUnique
   */
  export type FAQTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FAQTranslation to fetch.
     */
    where: FAQTranslationWhereUniqueInput
  }

  /**
   * FAQTranslation findUniqueOrThrow
   */
  export type FAQTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FAQTranslation to fetch.
     */
    where: FAQTranslationWhereUniqueInput
  }

  /**
   * FAQTranslation findFirst
   */
  export type FAQTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FAQTranslation to fetch.
     */
    where?: FAQTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQTranslations to fetch.
     */
    orderBy?: FAQTranslationOrderByWithRelationInput | FAQTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQTranslations.
     */
    cursor?: FAQTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQTranslations.
     */
    distinct?: FAQTranslationScalarFieldEnum | FAQTranslationScalarFieldEnum[]
  }

  /**
   * FAQTranslation findFirstOrThrow
   */
  export type FAQTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FAQTranslation to fetch.
     */
    where?: FAQTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQTranslations to fetch.
     */
    orderBy?: FAQTranslationOrderByWithRelationInput | FAQTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FAQTranslations.
     */
    cursor?: FAQTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FAQTranslations.
     */
    distinct?: FAQTranslationScalarFieldEnum | FAQTranslationScalarFieldEnum[]
  }

  /**
   * FAQTranslation findMany
   */
  export type FAQTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    /**
     * Filter, which FAQTranslations to fetch.
     */
    where?: FAQTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FAQTranslations to fetch.
     */
    orderBy?: FAQTranslationOrderByWithRelationInput | FAQTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FAQTranslations.
     */
    cursor?: FAQTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FAQTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FAQTranslations.
     */
    skip?: number
    distinct?: FAQTranslationScalarFieldEnum | FAQTranslationScalarFieldEnum[]
  }

  /**
   * FAQTranslation create
   */
  export type FAQTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a FAQTranslation.
     */
    data: XOR<FAQTranslationCreateInput, FAQTranslationUncheckedCreateInput>
  }

  /**
   * FAQTranslation createMany
   */
  export type FAQTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FAQTranslations.
     */
    data: FAQTranslationCreateManyInput | FAQTranslationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FAQTranslation createManyAndReturn
   */
  export type FAQTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FAQTranslations.
     */
    data: FAQTranslationCreateManyInput | FAQTranslationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FAQTranslation update
   */
  export type FAQTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a FAQTranslation.
     */
    data: XOR<FAQTranslationUpdateInput, FAQTranslationUncheckedUpdateInput>
    /**
     * Choose, which FAQTranslation to update.
     */
    where: FAQTranslationWhereUniqueInput
  }

  /**
   * FAQTranslation updateMany
   */
  export type FAQTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FAQTranslations.
     */
    data: XOR<FAQTranslationUpdateManyMutationInput, FAQTranslationUncheckedUpdateManyInput>
    /**
     * Filter which FAQTranslations to update
     */
    where?: FAQTranslationWhereInput
  }

  /**
   * FAQTranslation upsert
   */
  export type FAQTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the FAQTranslation to update in case it exists.
     */
    where: FAQTranslationWhereUniqueInput
    /**
     * In case the FAQTranslation found by the `where` argument doesn't exist, create a new FAQTranslation with this data.
     */
    create: XOR<FAQTranslationCreateInput, FAQTranslationUncheckedCreateInput>
    /**
     * In case the FAQTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FAQTranslationUpdateInput, FAQTranslationUncheckedUpdateInput>
  }

  /**
   * FAQTranslation delete
   */
  export type FAQTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
    /**
     * Filter which FAQTranslation to delete.
     */
    where: FAQTranslationWhereUniqueInput
  }

  /**
   * FAQTranslation deleteMany
   */
  export type FAQTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FAQTranslations to delete
     */
    where?: FAQTranslationWhereInput
  }

  /**
   * FAQTranslation without action
   */
  export type FAQTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FAQTranslation
     */
    select?: FAQTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FAQTranslationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const HeroBillboardsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    image: 'image',
    title: 'title',
    subtitle: 'subtitle',
    url: 'url'
  };

  export type HeroBillboardsScalarFieldEnum = (typeof HeroBillboardsScalarFieldEnum)[keyof typeof HeroBillboardsScalarFieldEnum]


  export const HeroBillboardsTranslationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    title: 'title',
    langCode: 'langCode',
    subtitle: 'subtitle',
    heroBillboardId: 'heroBillboardId'
  };

  export type HeroBillboardsTranslationScalarFieldEnum = (typeof HeroBillboardsTranslationScalarFieldEnum)[keyof typeof HeroBillboardsTranslationScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    code: 'code'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const BillboardScalarFieldEnum: {
    id: 'id',
    label: 'label',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BillboardScalarFieldEnum = (typeof BillboardScalarFieldEnum)[keyof typeof BillboardScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    billboardId: 'billboardId',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId',
    maxPrice: 'maxPrice'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ProductCategoryScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    categoryId: 'categoryId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductCategoryScalarFieldEnum = (typeof ProductCategoryScalarFieldEnum)[keyof typeof ProductCategoryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    quantity: 'quantity',
    price: 'price',
    type: 'type',
    isArchived: 'isArchived',
    isFeatured: 'isFeatured',
    backgroundColor: 'backgroundColor',
    textColor: 'textColor',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    article: 'article'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductTranslationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    languageCode: 'languageCode',
    title: 'title',
    description: 'description',
    productId: 'productId'
  };

  export type ProductTranslationScalarFieldEnum = (typeof ProductTranslationScalarFieldEnum)[keyof typeof ProductTranslationScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    isPaid: 'isPaid',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    orderNumber: 'orderNumber',
    message: 'message',
    messagngerType: 'messagngerType',
    messenger: 'messenger',
    totalPrice: 'totalPrice',
    orderStatus: 'orderStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    orderId: 'orderId',
    price: 'price',
    productId: 'productId',
    quantity: 'quantity'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const CharacteristicScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    description: 'description'
  };

  export type CharacteristicScalarFieldEnum = (typeof CharacteristicScalarFieldEnum)[keyof typeof CharacteristicScalarFieldEnum]


  export const CharacteristicTranslationScalarFieldEnum: {
    id: 'id',
    createAt: 'createAt',
    updateAt: 'updateAt',
    languageCode: 'languageCode',
    name: 'name',
    characteristicId: 'characteristicId'
  };

  export type CharacteristicTranslationScalarFieldEnum = (typeof CharacteristicTranslationScalarFieldEnum)[keyof typeof CharacteristicTranslationScalarFieldEnum]


  export const ProductCharacteristicScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    characteristicId: 'characteristicId',
    name: 'name',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type ProductCharacteristicScalarFieldEnum = (typeof ProductCharacteristicScalarFieldEnum)[keyof typeof ProductCharacteristicScalarFieldEnum]


  export const ProductCharacteristicTranslationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    languageCode: 'languageCode',
    description: 'description',
    productCharacteristicId: 'productCharacteristicId'
  };

  export type ProductCharacteristicTranslationScalarFieldEnum = (typeof ProductCharacteristicTranslationScalarFieldEnum)[keyof typeof ProductCharacteristicTranslationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    address: 'address',
    avatar: 'avatar',
    role: 'role',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    desc: 'desc',
    avtor: 'avtor'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReviewPhotoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    url: 'url',
    reviewId: 'reviewId'
  };

  export type ReviewPhotoScalarFieldEnum = (typeof ReviewPhotoScalarFieldEnum)[keyof typeof ReviewPhotoScalarFieldEnum]


  export const ReviewTranslationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    desc: 'desc',
    languageCode: 'languageCode',
    reviewId: 'reviewId'
  };

  export type ReviewTranslationScalarFieldEnum = (typeof ReviewTranslationScalarFieldEnum)[keyof typeof ReviewTranslationScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    firstName: 'firstName',
    email: 'email',
    messenger: 'messenger',
    messagngerType: 'messagngerType',
    message: 'message'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const DeliveryInfoScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description'
  };

  export type DeliveryInfoScalarFieldEnum = (typeof DeliveryInfoScalarFieldEnum)[keyof typeof DeliveryInfoScalarFieldEnum]


  export const DeliveryInfoTranslationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    languageCode: 'languageCode',
    deliveryId: 'deliveryId'
  };

  export type DeliveryInfoTranslationScalarFieldEnum = (typeof DeliveryInfoTranslationScalarFieldEnum)[keyof typeof DeliveryInfoTranslationScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const PaymentMethodTranslationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    languageCode: 'languageCode',
    paymentMethodId: 'paymentMethodId'
  };

  export type PaymentMethodTranslationScalarFieldEnum = (typeof PaymentMethodTranslationScalarFieldEnum)[keyof typeof PaymentMethodTranslationScalarFieldEnum]


  export const FAQScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updateAt: 'updateAt',
    question: 'question',
    answer: 'answer'
  };

  export type FAQScalarFieldEnum = (typeof FAQScalarFieldEnum)[keyof typeof FAQScalarFieldEnum]


  export const FAQTranslationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    question: 'question',
    answer: 'answer',
    languageCode: 'languageCode',
    faqId: 'faqId'
  };

  export type FAQTranslationScalarFieldEnum = (typeof FAQTranslationScalarFieldEnum)[keyof typeof FAQTranslationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TypeCategory'
   */
  export type EnumTypeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeCategory'>
    


  /**
   * Reference to a field of type 'TypeCategory[]'
   */
  export type ListEnumTypeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeCategory[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'ProductType[]'
   */
  export type ListEnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'OrderTypes'
   */
  export type EnumOrderTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderTypes'>
    


  /**
   * Reference to a field of type 'OrderTypes[]'
   */
  export type ListEnumOrderTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderTypes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type HeroBillboardsWhereInput = {
    AND?: HeroBillboardsWhereInput | HeroBillboardsWhereInput[]
    OR?: HeroBillboardsWhereInput[]
    NOT?: HeroBillboardsWhereInput | HeroBillboardsWhereInput[]
    id?: StringFilter<"HeroBillboards"> | string
    createdAt?: DateTimeFilter<"HeroBillboards"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBillboards"> | Date | string
    image?: StringFilter<"HeroBillboards"> | string
    title?: StringFilter<"HeroBillboards"> | string
    subtitle?: StringFilter<"HeroBillboards"> | string
    url?: StringFilter<"HeroBillboards"> | string
    translations?: HeroBillboardsTranslationListRelationFilter
  }

  export type HeroBillboardsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    url?: SortOrder
    translations?: HeroBillboardsTranslationOrderByRelationAggregateInput
  }

  export type HeroBillboardsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HeroBillboardsWhereInput | HeroBillboardsWhereInput[]
    OR?: HeroBillboardsWhereInput[]
    NOT?: HeroBillboardsWhereInput | HeroBillboardsWhereInput[]
    createdAt?: DateTimeFilter<"HeroBillboards"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBillboards"> | Date | string
    image?: StringFilter<"HeroBillboards"> | string
    title?: StringFilter<"HeroBillboards"> | string
    subtitle?: StringFilter<"HeroBillboards"> | string
    url?: StringFilter<"HeroBillboards"> | string
    translations?: HeroBillboardsTranslationListRelationFilter
  }, "id">

  export type HeroBillboardsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    url?: SortOrder
    _count?: HeroBillboardsCountOrderByAggregateInput
    _max?: HeroBillboardsMaxOrderByAggregateInput
    _min?: HeroBillboardsMinOrderByAggregateInput
  }

  export type HeroBillboardsScalarWhereWithAggregatesInput = {
    AND?: HeroBillboardsScalarWhereWithAggregatesInput | HeroBillboardsScalarWhereWithAggregatesInput[]
    OR?: HeroBillboardsScalarWhereWithAggregatesInput[]
    NOT?: HeroBillboardsScalarWhereWithAggregatesInput | HeroBillboardsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HeroBillboards"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HeroBillboards"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HeroBillboards"> | Date | string
    image?: StringWithAggregatesFilter<"HeroBillboards"> | string
    title?: StringWithAggregatesFilter<"HeroBillboards"> | string
    subtitle?: StringWithAggregatesFilter<"HeroBillboards"> | string
    url?: StringWithAggregatesFilter<"HeroBillboards"> | string
  }

  export type HeroBillboardsTranslationWhereInput = {
    AND?: HeroBillboardsTranslationWhereInput | HeroBillboardsTranslationWhereInput[]
    OR?: HeroBillboardsTranslationWhereInput[]
    NOT?: HeroBillboardsTranslationWhereInput | HeroBillboardsTranslationWhereInput[]
    id?: StringFilter<"HeroBillboardsTranslation"> | string
    createdAt?: DateTimeFilter<"HeroBillboardsTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBillboardsTranslation"> | Date | string
    title?: StringFilter<"HeroBillboardsTranslation"> | string
    langCode?: StringFilter<"HeroBillboardsTranslation"> | string
    subtitle?: StringFilter<"HeroBillboardsTranslation"> | string
    heroBillboardId?: StringFilter<"HeroBillboardsTranslation"> | string
    heroBillboard?: XOR<HeroBillboardsRelationFilter, HeroBillboardsWhereInput>
  }

  export type HeroBillboardsTranslationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    langCode?: SortOrder
    subtitle?: SortOrder
    heroBillboardId?: SortOrder
    heroBillboard?: HeroBillboardsOrderByWithRelationInput
  }

  export type HeroBillboardsTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HeroBillboardsTranslationWhereInput | HeroBillboardsTranslationWhereInput[]
    OR?: HeroBillboardsTranslationWhereInput[]
    NOT?: HeroBillboardsTranslationWhereInput | HeroBillboardsTranslationWhereInput[]
    createdAt?: DateTimeFilter<"HeroBillboardsTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBillboardsTranslation"> | Date | string
    title?: StringFilter<"HeroBillboardsTranslation"> | string
    langCode?: StringFilter<"HeroBillboardsTranslation"> | string
    subtitle?: StringFilter<"HeroBillboardsTranslation"> | string
    heroBillboardId?: StringFilter<"HeroBillboardsTranslation"> | string
    heroBillboard?: XOR<HeroBillboardsRelationFilter, HeroBillboardsWhereInput>
  }, "id">

  export type HeroBillboardsTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    langCode?: SortOrder
    subtitle?: SortOrder
    heroBillboardId?: SortOrder
    _count?: HeroBillboardsTranslationCountOrderByAggregateInput
    _max?: HeroBillboardsTranslationMaxOrderByAggregateInput
    _min?: HeroBillboardsTranslationMinOrderByAggregateInput
  }

  export type HeroBillboardsTranslationScalarWhereWithAggregatesInput = {
    AND?: HeroBillboardsTranslationScalarWhereWithAggregatesInput | HeroBillboardsTranslationScalarWhereWithAggregatesInput[]
    OR?: HeroBillboardsTranslationScalarWhereWithAggregatesInput[]
    NOT?: HeroBillboardsTranslationScalarWhereWithAggregatesInput | HeroBillboardsTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HeroBillboardsTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"HeroBillboardsTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HeroBillboardsTranslation"> | Date | string
    title?: StringWithAggregatesFilter<"HeroBillboardsTranslation"> | string
    langCode?: StringWithAggregatesFilter<"HeroBillboardsTranslation"> | string
    subtitle?: StringWithAggregatesFilter<"HeroBillboardsTranslation"> | string
    heroBillboardId?: StringWithAggregatesFilter<"HeroBillboardsTranslation"> | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: StringFilter<"Language"> | string
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    name?: StringFilter<"Language"> | string
    code?: StringFilter<"Language"> | string
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    createdAt?: DateTimeFilter<"Language"> | Date | string
    updatedAt?: DateTimeFilter<"Language"> | Date | string
    name?: StringFilter<"Language"> | string
    code?: StringFilter<"Language"> | string
  }, "id">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Language"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Language"> | Date | string
    name?: StringWithAggregatesFilter<"Language"> | string
    code?: StringWithAggregatesFilter<"Language"> | string
  }

  export type BillboardWhereInput = {
    AND?: BillboardWhereInput | BillboardWhereInput[]
    OR?: BillboardWhereInput[]
    NOT?: BillboardWhereInput | BillboardWhereInput[]
    id?: StringFilter<"Billboard"> | string
    label?: StringFilter<"Billboard"> | string
    imageUrl?: StringFilter<"Billboard"> | string
    createdAt?: DateTimeFilter<"Billboard"> | Date | string
    updatedAt?: DateTimeFilter<"Billboard"> | Date | string
    categories?: CategoryListRelationFilter
  }

  export type BillboardOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categories?: CategoryOrderByRelationAggregateInput
  }

  export type BillboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillboardWhereInput | BillboardWhereInput[]
    OR?: BillboardWhereInput[]
    NOT?: BillboardWhereInput | BillboardWhereInput[]
    label?: StringFilter<"Billboard"> | string
    imageUrl?: StringFilter<"Billboard"> | string
    createdAt?: DateTimeFilter<"Billboard"> | Date | string
    updatedAt?: DateTimeFilter<"Billboard"> | Date | string
    categories?: CategoryListRelationFilter
  }, "id">

  export type BillboardOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BillboardCountOrderByAggregateInput
    _max?: BillboardMaxOrderByAggregateInput
    _min?: BillboardMinOrderByAggregateInput
  }

  export type BillboardScalarWhereWithAggregatesInput = {
    AND?: BillboardScalarWhereWithAggregatesInput | BillboardScalarWhereWithAggregatesInput[]
    OR?: BillboardScalarWhereWithAggregatesInput[]
    NOT?: BillboardScalarWhereWithAggregatesInput | BillboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Billboard"> | string
    label?: StringWithAggregatesFilter<"Billboard"> | string
    imageUrl?: StringWithAggregatesFilter<"Billboard"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Billboard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Billboard"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    billboardId?: StringNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    type?: EnumTypeCategoryFilter<"Category"> | $Enums.TypeCategory
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parentId?: StringNullableFilter<"Category"> | string | null
    maxPrice?: DecimalNullableFilter<"Category"> | Decimal | DecimalJsLike | number | string | null
    billboard?: XOR<BillboardNullableRelationFilter, BillboardWhereInput> | null
    products?: ProductCategoryListRelationFilter
    parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    billboardId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    billboard?: BillboardOrderByWithRelationInput
    products?: ProductCategoryOrderByRelationAggregateInput
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    billboardId?: StringNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    type?: EnumTypeCategoryFilter<"Category"> | $Enums.TypeCategory
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parentId?: StringNullableFilter<"Category"> | string | null
    maxPrice?: DecimalNullableFilter<"Category"> | Decimal | DecimalJsLike | number | string | null
    billboard?: XOR<BillboardNullableRelationFilter, BillboardWhereInput> | null
    products?: ProductCategoryListRelationFilter
    parent?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    billboardId?: SortOrderInput | SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    maxPrice?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    billboardId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    name?: StringWithAggregatesFilter<"Category"> | string
    type?: EnumTypeCategoryWithAggregatesFilter<"Category"> | $Enums.TypeCategory
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    maxPrice?: DecimalNullableWithAggregatesFilter<"Category"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductCategoryWhereInput = {
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    productId?: StringFilter<"ProductCategory"> | string
    categoryId?: StringFilter<"ProductCategory"> | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }

  export type ProductCategoryOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
  }

  export type ProductCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_categoryId?: ProductCategoryProductIdCategoryIdCompoundUniqueInput
    AND?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    OR?: ProductCategoryWhereInput[]
    NOT?: ProductCategoryWhereInput | ProductCategoryWhereInput[]
    productId?: StringFilter<"ProductCategory"> | string
    categoryId?: StringFilter<"ProductCategory"> | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
  }, "id" | "productId_categoryId">

  export type ProductCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCategoryCountOrderByAggregateInput
    _max?: ProductCategoryMaxOrderByAggregateInput
    _min?: ProductCategoryMinOrderByAggregateInput
  }

  export type ProductCategoryScalarWhereWithAggregatesInput = {
    AND?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    OR?: ProductCategoryScalarWhereWithAggregatesInput[]
    NOT?: ProductCategoryScalarWhereWithAggregatesInput | ProductCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCategory"> | string
    productId?: StringWithAggregatesFilter<"ProductCategory"> | string
    categoryId?: StringWithAggregatesFilter<"ProductCategory"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCategory"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    quantity?: IntFilter<"Product"> | number
    price?: IntFilter<"Product"> | number
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    isArchived?: BoolFilter<"Product"> | boolean
    isFeatured?: BoolFilter<"Product"> | boolean
    backgroundColor?: StringFilter<"Product"> | string
    textColor?: StringFilter<"Product"> | string
    position?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    article?: StringFilter<"Product"> | string
    categories?: ProductCategoryListRelationFilter
    images?: ImageListRelationFilter
    orderItems?: OrderItemListRelationFilter
    productCharacteristics?: ProductCharacteristicListRelationFilter
    translations?: ProductTranslationListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    type?: SortOrder
    isArchived?: SortOrder
    isFeatured?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
    categories?: ProductCategoryOrderByRelationAggregateInput
    images?: ImageOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    productCharacteristics?: ProductCharacteristicOrderByRelationAggregateInput
    translations?: ProductTranslationOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    title?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    quantity?: IntFilter<"Product"> | number
    price?: IntFilter<"Product"> | number
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    isArchived?: BoolFilter<"Product"> | boolean
    isFeatured?: BoolFilter<"Product"> | boolean
    backgroundColor?: StringFilter<"Product"> | string
    textColor?: StringFilter<"Product"> | string
    position?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    article?: StringFilter<"Product"> | string
    categories?: ProductCategoryListRelationFilter
    images?: ImageListRelationFilter
    orderItems?: OrderItemListRelationFilter
    productCharacteristics?: ProductCharacteristicListRelationFilter
    translations?: ProductTranslationListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    type?: SortOrder
    isArchived?: SortOrder
    isFeatured?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    title?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    quantity?: IntWithAggregatesFilter<"Product"> | number
    price?: IntWithAggregatesFilter<"Product"> | number
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    isArchived?: BoolWithAggregatesFilter<"Product"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"Product"> | boolean
    backgroundColor?: StringWithAggregatesFilter<"Product"> | string
    textColor?: StringWithAggregatesFilter<"Product"> | string
    position?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    article?: StringWithAggregatesFilter<"Product"> | string
  }

  export type ProductTranslationWhereInput = {
    AND?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    OR?: ProductTranslationWhereInput[]
    NOT?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    id?: StringFilter<"ProductTranslation"> | string
    createdAt?: DateTimeFilter<"ProductTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductTranslation"> | Date | string
    languageCode?: StringFilter<"ProductTranslation"> | string
    title?: StringFilter<"ProductTranslation"> | string
    description?: StringFilter<"ProductTranslation"> | string
    productId?: StringFilter<"ProductTranslation"> | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ProductTranslationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId?: string
    AND?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    OR?: ProductTranslationWhereInput[]
    NOT?: ProductTranslationWhereInput | ProductTranslationWhereInput[]
    createdAt?: DateTimeFilter<"ProductTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductTranslation"> | Date | string
    languageCode?: StringFilter<"ProductTranslation"> | string
    title?: StringFilter<"ProductTranslation"> | string
    description?: StringFilter<"ProductTranslation"> | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "productId">

  export type ProductTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    productId?: SortOrder
    _count?: ProductTranslationCountOrderByAggregateInput
    _max?: ProductTranslationMaxOrderByAggregateInput
    _min?: ProductTranslationMinOrderByAggregateInput
  }

  export type ProductTranslationScalarWhereWithAggregatesInput = {
    AND?: ProductTranslationScalarWhereWithAggregatesInput | ProductTranslationScalarWhereWithAggregatesInput[]
    OR?: ProductTranslationScalarWhereWithAggregatesInput[]
    NOT?: ProductTranslationScalarWhereWithAggregatesInput | ProductTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductTranslation"> | Date | string
    languageCode?: StringWithAggregatesFilter<"ProductTranslation"> | string
    title?: StringWithAggregatesFilter<"ProductTranslation"> | string
    description?: StringWithAggregatesFilter<"ProductTranslation"> | string
    productId?: StringWithAggregatesFilter<"ProductTranslation"> | string
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: StringFilter<"Image"> | string
    productId?: StringFilter<"Image"> | string
    url?: StringFilter<"Image"> | string
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    url?: string
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    productId?: StringFilter<"Image"> | string
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "url">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Image"> | string
    productId?: StringWithAggregatesFilter<"Image"> | string
    url?: StringWithAggregatesFilter<"Image"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    isPaid?: BoolFilter<"Order"> | boolean
    firstName?: StringFilter<"Order"> | string
    lastName?: StringFilter<"Order"> | string
    phone?: StringFilter<"Order"> | string
    email?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    message?: StringFilter<"Order"> | string
    messagngerType?: StringFilter<"Order"> | string
    messenger?: StringFilter<"Order"> | string
    totalPrice?: IntFilter<"Order"> | number
    orderStatus?: EnumOrderTypesFilter<"Order"> | $Enums.OrderTypes
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    userId?: StringFilter<"Order"> | string
    orderItems?: OrderItemListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    isPaid?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    orderNumber?: SortOrder
    message?: SortOrder
    messagngerType?: SortOrder
    messenger?: SortOrder
    totalPrice?: SortOrder
    orderStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    orderItems?: OrderItemOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    isPaid?: BoolFilter<"Order"> | boolean
    firstName?: StringFilter<"Order"> | string
    lastName?: StringFilter<"Order"> | string
    phone?: StringFilter<"Order"> | string
    email?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    message?: StringFilter<"Order"> | string
    messagngerType?: StringFilter<"Order"> | string
    messenger?: StringFilter<"Order"> | string
    totalPrice?: IntFilter<"Order"> | number
    orderStatus?: EnumOrderTypesFilter<"Order"> | $Enums.OrderTypes
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    userId?: StringFilter<"Order"> | string
    orderItems?: OrderItemListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    isPaid?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    orderNumber?: SortOrder
    message?: SortOrder
    messagngerType?: SortOrder
    messenger?: SortOrder
    totalPrice?: SortOrder
    orderStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    isPaid?: BoolWithAggregatesFilter<"Order"> | boolean
    firstName?: StringWithAggregatesFilter<"Order"> | string
    lastName?: StringWithAggregatesFilter<"Order"> | string
    phone?: StringWithAggregatesFilter<"Order"> | string
    email?: StringWithAggregatesFilter<"Order"> | string
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    message?: StringWithAggregatesFilter<"Order"> | string
    messagngerType?: StringWithAggregatesFilter<"Order"> | string
    messenger?: StringWithAggregatesFilter<"Order"> | string
    totalPrice?: IntWithAggregatesFilter<"Order"> | number
    orderStatus?: EnumOrderTypesWithAggregatesFilter<"Order"> | $Enums.OrderTypes
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    userId?: StringWithAggregatesFilter<"Order"> | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    orderId?: StringFilter<"OrderItem"> | string
    price?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_orderId?: OrderItemProductIdOrderIdCompoundUniqueInput
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    orderId?: StringFilter<"OrderItem"> | string
    price?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "productId_orderId">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    price?: StringWithAggregatesFilter<"OrderItem"> | string
    productId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
  }

  export type CharacteristicWhereInput = {
    AND?: CharacteristicWhereInput | CharacteristicWhereInput[]
    OR?: CharacteristicWhereInput[]
    NOT?: CharacteristicWhereInput | CharacteristicWhereInput[]
    id?: StringFilter<"Characteristic"> | string
    createdAt?: DateTimeFilter<"Characteristic"> | Date | string
    updatedAt?: DateTimeFilter<"Characteristic"> | Date | string
    name?: StringFilter<"Characteristic"> | string
    description?: StringNullableFilter<"Characteristic"> | string | null
    productCharacteristics?: ProductCharacteristicListRelationFilter
    translations?: CharacteristicTranslationListRelationFilter
  }

  export type CharacteristicOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    productCharacteristics?: ProductCharacteristicOrderByRelationAggregateInput
    translations?: CharacteristicTranslationOrderByRelationAggregateInput
  }

  export type CharacteristicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacteristicWhereInput | CharacteristicWhereInput[]
    OR?: CharacteristicWhereInput[]
    NOT?: CharacteristicWhereInput | CharacteristicWhereInput[]
    createdAt?: DateTimeFilter<"Characteristic"> | Date | string
    updatedAt?: DateTimeFilter<"Characteristic"> | Date | string
    name?: StringFilter<"Characteristic"> | string
    description?: StringNullableFilter<"Characteristic"> | string | null
    productCharacteristics?: ProductCharacteristicListRelationFilter
    translations?: CharacteristicTranslationListRelationFilter
  }, "id">

  export type CharacteristicOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CharacteristicCountOrderByAggregateInput
    _max?: CharacteristicMaxOrderByAggregateInput
    _min?: CharacteristicMinOrderByAggregateInput
  }

  export type CharacteristicScalarWhereWithAggregatesInput = {
    AND?: CharacteristicScalarWhereWithAggregatesInput | CharacteristicScalarWhereWithAggregatesInput[]
    OR?: CharacteristicScalarWhereWithAggregatesInput[]
    NOT?: CharacteristicScalarWhereWithAggregatesInput | CharacteristicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Characteristic"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Characteristic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Characteristic"> | Date | string
    name?: StringWithAggregatesFilter<"Characteristic"> | string
    description?: StringNullableWithAggregatesFilter<"Characteristic"> | string | null
  }

  export type CharacteristicTranslationWhereInput = {
    AND?: CharacteristicTranslationWhereInput | CharacteristicTranslationWhereInput[]
    OR?: CharacteristicTranslationWhereInput[]
    NOT?: CharacteristicTranslationWhereInput | CharacteristicTranslationWhereInput[]
    id?: StringFilter<"CharacteristicTranslation"> | string
    createAt?: DateTimeFilter<"CharacteristicTranslation"> | Date | string
    updateAt?: DateTimeFilter<"CharacteristicTranslation"> | Date | string
    languageCode?: StringFilter<"CharacteristicTranslation"> | string
    name?: StringFilter<"CharacteristicTranslation"> | string
    characteristicId?: StringFilter<"CharacteristicTranslation"> | string
    characteristic?: XOR<CharacteristicRelationFilter, CharacteristicWhereInput>
  }

  export type CharacteristicTranslationOrderByWithRelationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    languageCode?: SortOrder
    name?: SortOrder
    characteristicId?: SortOrder
    characteristic?: CharacteristicOrderByWithRelationInput
  }

  export type CharacteristicTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharacteristicTranslationWhereInput | CharacteristicTranslationWhereInput[]
    OR?: CharacteristicTranslationWhereInput[]
    NOT?: CharacteristicTranslationWhereInput | CharacteristicTranslationWhereInput[]
    createAt?: DateTimeFilter<"CharacteristicTranslation"> | Date | string
    updateAt?: DateTimeFilter<"CharacteristicTranslation"> | Date | string
    languageCode?: StringFilter<"CharacteristicTranslation"> | string
    name?: StringFilter<"CharacteristicTranslation"> | string
    characteristicId?: StringFilter<"CharacteristicTranslation"> | string
    characteristic?: XOR<CharacteristicRelationFilter, CharacteristicWhereInput>
  }, "id">

  export type CharacteristicTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    languageCode?: SortOrder
    name?: SortOrder
    characteristicId?: SortOrder
    _count?: CharacteristicTranslationCountOrderByAggregateInput
    _max?: CharacteristicTranslationMaxOrderByAggregateInput
    _min?: CharacteristicTranslationMinOrderByAggregateInput
  }

  export type CharacteristicTranslationScalarWhereWithAggregatesInput = {
    AND?: CharacteristicTranslationScalarWhereWithAggregatesInput | CharacteristicTranslationScalarWhereWithAggregatesInput[]
    OR?: CharacteristicTranslationScalarWhereWithAggregatesInput[]
    NOT?: CharacteristicTranslationScalarWhereWithAggregatesInput | CharacteristicTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacteristicTranslation"> | string
    createAt?: DateTimeWithAggregatesFilter<"CharacteristicTranslation"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"CharacteristicTranslation"> | Date | string
    languageCode?: StringWithAggregatesFilter<"CharacteristicTranslation"> | string
    name?: StringWithAggregatesFilter<"CharacteristicTranslation"> | string
    characteristicId?: StringWithAggregatesFilter<"CharacteristicTranslation"> | string
  }

  export type ProductCharacteristicWhereInput = {
    AND?: ProductCharacteristicWhereInput | ProductCharacteristicWhereInput[]
    OR?: ProductCharacteristicWhereInput[]
    NOT?: ProductCharacteristicWhereInput | ProductCharacteristicWhereInput[]
    id?: StringFilter<"ProductCharacteristic"> | string
    productId?: StringFilter<"ProductCharacteristic"> | string
    characteristicId?: StringFilter<"ProductCharacteristic"> | string
    name?: StringFilter<"ProductCharacteristic"> | string
    createAt?: DateTimeFilter<"ProductCharacteristic"> | Date | string
    updateAt?: DateTimeFilter<"ProductCharacteristic"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    characteristic?: XOR<CharacteristicRelationFilter, CharacteristicWhereInput>
    translations?: ProductCharacteristicTranslationListRelationFilter
  }

  export type ProductCharacteristicOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    characteristic?: CharacteristicOrderByWithRelationInput
    translations?: ProductCharacteristicTranslationOrderByRelationAggregateInput
  }

  export type ProductCharacteristicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_characteristicId?: ProductCharacteristicProductIdCharacteristicIdCompoundUniqueInput
    AND?: ProductCharacteristicWhereInput | ProductCharacteristicWhereInput[]
    OR?: ProductCharacteristicWhereInput[]
    NOT?: ProductCharacteristicWhereInput | ProductCharacteristicWhereInput[]
    productId?: StringFilter<"ProductCharacteristic"> | string
    characteristicId?: StringFilter<"ProductCharacteristic"> | string
    name?: StringFilter<"ProductCharacteristic"> | string
    createAt?: DateTimeFilter<"ProductCharacteristic"> | Date | string
    updateAt?: DateTimeFilter<"ProductCharacteristic"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    characteristic?: XOR<CharacteristicRelationFilter, CharacteristicWhereInput>
    translations?: ProductCharacteristicTranslationListRelationFilter
  }, "id" | "productId_characteristicId">

  export type ProductCharacteristicOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: ProductCharacteristicCountOrderByAggregateInput
    _max?: ProductCharacteristicMaxOrderByAggregateInput
    _min?: ProductCharacteristicMinOrderByAggregateInput
  }

  export type ProductCharacteristicScalarWhereWithAggregatesInput = {
    AND?: ProductCharacteristicScalarWhereWithAggregatesInput | ProductCharacteristicScalarWhereWithAggregatesInput[]
    OR?: ProductCharacteristicScalarWhereWithAggregatesInput[]
    NOT?: ProductCharacteristicScalarWhereWithAggregatesInput | ProductCharacteristicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCharacteristic"> | string
    productId?: StringWithAggregatesFilter<"ProductCharacteristic"> | string
    characteristicId?: StringWithAggregatesFilter<"ProductCharacteristic"> | string
    name?: StringWithAggregatesFilter<"ProductCharacteristic"> | string
    createAt?: DateTimeWithAggregatesFilter<"ProductCharacteristic"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"ProductCharacteristic"> | Date | string
  }

  export type ProductCharacteristicTranslationWhereInput = {
    AND?: ProductCharacteristicTranslationWhereInput | ProductCharacteristicTranslationWhereInput[]
    OR?: ProductCharacteristicTranslationWhereInput[]
    NOT?: ProductCharacteristicTranslationWhereInput | ProductCharacteristicTranslationWhereInput[]
    id?: StringFilter<"ProductCharacteristicTranslation"> | string
    createdAt?: DateTimeFilter<"ProductCharacteristicTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCharacteristicTranslation"> | Date | string
    languageCode?: StringFilter<"ProductCharacteristicTranslation"> | string
    description?: StringFilter<"ProductCharacteristicTranslation"> | string
    productCharacteristicId?: StringFilter<"ProductCharacteristicTranslation"> | string
    productCharacteristic?: XOR<ProductCharacteristicRelationFilter, ProductCharacteristicWhereInput>
  }

  export type ProductCharacteristicTranslationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    description?: SortOrder
    productCharacteristicId?: SortOrder
    productCharacteristic?: ProductCharacteristicOrderByWithRelationInput
  }

  export type ProductCharacteristicTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productCharacteristicId_languageCode?: ProductCharacteristicTranslationProductCharacteristicIdLanguageCodeCompoundUniqueInput
    AND?: ProductCharacteristicTranslationWhereInput | ProductCharacteristicTranslationWhereInput[]
    OR?: ProductCharacteristicTranslationWhereInput[]
    NOT?: ProductCharacteristicTranslationWhereInput | ProductCharacteristicTranslationWhereInput[]
    createdAt?: DateTimeFilter<"ProductCharacteristicTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCharacteristicTranslation"> | Date | string
    languageCode?: StringFilter<"ProductCharacteristicTranslation"> | string
    description?: StringFilter<"ProductCharacteristicTranslation"> | string
    productCharacteristicId?: StringFilter<"ProductCharacteristicTranslation"> | string
    productCharacteristic?: XOR<ProductCharacteristicRelationFilter, ProductCharacteristicWhereInput>
  }, "id" | "productCharacteristicId_languageCode">

  export type ProductCharacteristicTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    description?: SortOrder
    productCharacteristicId?: SortOrder
    _count?: ProductCharacteristicTranslationCountOrderByAggregateInput
    _max?: ProductCharacteristicTranslationMaxOrderByAggregateInput
    _min?: ProductCharacteristicTranslationMinOrderByAggregateInput
  }

  export type ProductCharacteristicTranslationScalarWhereWithAggregatesInput = {
    AND?: ProductCharacteristicTranslationScalarWhereWithAggregatesInput | ProductCharacteristicTranslationScalarWhereWithAggregatesInput[]
    OR?: ProductCharacteristicTranslationScalarWhereWithAggregatesInput[]
    NOT?: ProductCharacteristicTranslationScalarWhereWithAggregatesInput | ProductCharacteristicTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductCharacteristicTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProductCharacteristicTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductCharacteristicTranslation"> | Date | string
    languageCode?: StringWithAggregatesFilter<"ProductCharacteristicTranslation"> | string
    description?: StringWithAggregatesFilter<"ProductCharacteristicTranslation"> | string
    productCharacteristicId?: StringWithAggregatesFilter<"ProductCharacteristicTranslation"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    address?: StringFilter<"User"> | string
    avatar?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    orders?: OrderListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    password?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    address?: StringFilter<"User"> | string
    avatar?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    orders?: OrderListRelationFilter
  }, "id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    address?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    desc?: StringFilter<"Review"> | string
    avtor?: StringFilter<"Review"> | string
    photo?: ReviewPhotoListRelationFilter
    translation?: ReviewTranslationListRelationFilter
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    avtor?: SortOrder
    photo?: ReviewPhotoOrderByRelationAggregateInput
    translation?: ReviewTranslationOrderByRelationAggregateInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    desc?: StringFilter<"Review"> | string
    avtor?: StringFilter<"Review"> | string
    photo?: ReviewPhotoListRelationFilter
    translation?: ReviewTranslationListRelationFilter
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    avtor?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    desc?: StringWithAggregatesFilter<"Review"> | string
    avtor?: StringWithAggregatesFilter<"Review"> | string
  }

  export type ReviewPhotoWhereInput = {
    AND?: ReviewPhotoWhereInput | ReviewPhotoWhereInput[]
    OR?: ReviewPhotoWhereInput[]
    NOT?: ReviewPhotoWhereInput | ReviewPhotoWhereInput[]
    id?: StringFilter<"ReviewPhoto"> | string
    createdAt?: DateTimeFilter<"ReviewPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewPhoto"> | Date | string
    url?: StringFilter<"ReviewPhoto"> | string
    reviewId?: StringFilter<"ReviewPhoto"> | string
    review?: XOR<ReviewRelationFilter, ReviewWhereInput>
  }

  export type ReviewPhotoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    url?: SortOrder
    reviewId?: SortOrder
    review?: ReviewOrderByWithRelationInput
  }

  export type ReviewPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewPhotoWhereInput | ReviewPhotoWhereInput[]
    OR?: ReviewPhotoWhereInput[]
    NOT?: ReviewPhotoWhereInput | ReviewPhotoWhereInput[]
    createdAt?: DateTimeFilter<"ReviewPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewPhoto"> | Date | string
    url?: StringFilter<"ReviewPhoto"> | string
    reviewId?: StringFilter<"ReviewPhoto"> | string
    review?: XOR<ReviewRelationFilter, ReviewWhereInput>
  }, "id">

  export type ReviewPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    url?: SortOrder
    reviewId?: SortOrder
    _count?: ReviewPhotoCountOrderByAggregateInput
    _max?: ReviewPhotoMaxOrderByAggregateInput
    _min?: ReviewPhotoMinOrderByAggregateInput
  }

  export type ReviewPhotoScalarWhereWithAggregatesInput = {
    AND?: ReviewPhotoScalarWhereWithAggregatesInput | ReviewPhotoScalarWhereWithAggregatesInput[]
    OR?: ReviewPhotoScalarWhereWithAggregatesInput[]
    NOT?: ReviewPhotoScalarWhereWithAggregatesInput | ReviewPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewPhoto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewPhoto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReviewPhoto"> | Date | string
    url?: StringWithAggregatesFilter<"ReviewPhoto"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewPhoto"> | string
  }

  export type ReviewTranslationWhereInput = {
    AND?: ReviewTranslationWhereInput | ReviewTranslationWhereInput[]
    OR?: ReviewTranslationWhereInput[]
    NOT?: ReviewTranslationWhereInput | ReviewTranslationWhereInput[]
    id?: StringFilter<"ReviewTranslation"> | string
    createdAt?: DateTimeFilter<"ReviewTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewTranslation"> | Date | string
    desc?: StringFilter<"ReviewTranslation"> | string
    languageCode?: StringFilter<"ReviewTranslation"> | string
    reviewId?: StringFilter<"ReviewTranslation"> | string
    review?: XOR<ReviewRelationFilter, ReviewWhereInput>
  }

  export type ReviewTranslationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    languageCode?: SortOrder
    reviewId?: SortOrder
    review?: ReviewOrderByWithRelationInput
  }

  export type ReviewTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewTranslationWhereInput | ReviewTranslationWhereInput[]
    OR?: ReviewTranslationWhereInput[]
    NOT?: ReviewTranslationWhereInput | ReviewTranslationWhereInput[]
    createdAt?: DateTimeFilter<"ReviewTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewTranslation"> | Date | string
    desc?: StringFilter<"ReviewTranslation"> | string
    languageCode?: StringFilter<"ReviewTranslation"> | string
    reviewId?: StringFilter<"ReviewTranslation"> | string
    review?: XOR<ReviewRelationFilter, ReviewWhereInput>
  }, "id">

  export type ReviewTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    languageCode?: SortOrder
    reviewId?: SortOrder
    _count?: ReviewTranslationCountOrderByAggregateInput
    _max?: ReviewTranslationMaxOrderByAggregateInput
    _min?: ReviewTranslationMinOrderByAggregateInput
  }

  export type ReviewTranslationScalarWhereWithAggregatesInput = {
    AND?: ReviewTranslationScalarWhereWithAggregatesInput | ReviewTranslationScalarWhereWithAggregatesInput[]
    OR?: ReviewTranslationScalarWhereWithAggregatesInput[]
    NOT?: ReviewTranslationScalarWhereWithAggregatesInput | ReviewTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReviewTranslation"> | Date | string
    desc?: StringWithAggregatesFilter<"ReviewTranslation"> | string
    languageCode?: StringWithAggregatesFilter<"ReviewTranslation"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewTranslation"> | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter<"Feedback"> | string
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    firstName?: StringFilter<"Feedback"> | string
    email?: StringFilter<"Feedback"> | string
    messenger?: StringFilter<"Feedback"> | string
    messagngerType?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    email?: SortOrder
    messenger?: SortOrder
    messagngerType?: SortOrder
    message?: SortOrder
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeFilter<"Feedback"> | Date | string
    firstName?: StringFilter<"Feedback"> | string
    email?: StringFilter<"Feedback"> | string
    messenger?: StringFilter<"Feedback"> | string
    messagngerType?: StringFilter<"Feedback"> | string
    message?: StringFilter<"Feedback"> | string
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    email?: SortOrder
    messenger?: SortOrder
    messagngerType?: SortOrder
    message?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feedback"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    firstName?: StringWithAggregatesFilter<"Feedback"> | string
    email?: StringWithAggregatesFilter<"Feedback"> | string
    messenger?: StringWithAggregatesFilter<"Feedback"> | string
    messagngerType?: StringWithAggregatesFilter<"Feedback"> | string
    message?: StringWithAggregatesFilter<"Feedback"> | string
  }

  export type DeliveryInfoWhereInput = {
    AND?: DeliveryInfoWhereInput | DeliveryInfoWhereInput[]
    OR?: DeliveryInfoWhereInput[]
    NOT?: DeliveryInfoWhereInput | DeliveryInfoWhereInput[]
    id?: StringFilter<"DeliveryInfo"> | string
    createdAt?: DateTimeFilter<"DeliveryInfo"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryInfo"> | Date | string
    description?: StringFilter<"DeliveryInfo"> | string
    translation?: DeliveryInfoTranslationListRelationFilter
  }

  export type DeliveryInfoOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    translation?: DeliveryInfoTranslationOrderByRelationAggregateInput
  }

  export type DeliveryInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryInfoWhereInput | DeliveryInfoWhereInput[]
    OR?: DeliveryInfoWhereInput[]
    NOT?: DeliveryInfoWhereInput | DeliveryInfoWhereInput[]
    createdAt?: DateTimeFilter<"DeliveryInfo"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryInfo"> | Date | string
    description?: StringFilter<"DeliveryInfo"> | string
    translation?: DeliveryInfoTranslationListRelationFilter
  }, "id">

  export type DeliveryInfoOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    _count?: DeliveryInfoCountOrderByAggregateInput
    _max?: DeliveryInfoMaxOrderByAggregateInput
    _min?: DeliveryInfoMinOrderByAggregateInput
  }

  export type DeliveryInfoScalarWhereWithAggregatesInput = {
    AND?: DeliveryInfoScalarWhereWithAggregatesInput | DeliveryInfoScalarWhereWithAggregatesInput[]
    OR?: DeliveryInfoScalarWhereWithAggregatesInput[]
    NOT?: DeliveryInfoScalarWhereWithAggregatesInput | DeliveryInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryInfo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryInfo"> | Date | string
    description?: StringWithAggregatesFilter<"DeliveryInfo"> | string
  }

  export type DeliveryInfoTranslationWhereInput = {
    AND?: DeliveryInfoTranslationWhereInput | DeliveryInfoTranslationWhereInput[]
    OR?: DeliveryInfoTranslationWhereInput[]
    NOT?: DeliveryInfoTranslationWhereInput | DeliveryInfoTranslationWhereInput[]
    id?: StringFilter<"DeliveryInfoTranslation"> | string
    createdAt?: DateTimeFilter<"DeliveryInfoTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryInfoTranslation"> | Date | string
    description?: StringFilter<"DeliveryInfoTranslation"> | string
    languageCode?: StringFilter<"DeliveryInfoTranslation"> | string
    deliveryId?: StringFilter<"DeliveryInfoTranslation"> | string
    deliveryInfo?: XOR<DeliveryInfoRelationFilter, DeliveryInfoWhereInput>
  }

  export type DeliveryInfoTranslationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    deliveryId?: SortOrder
    deliveryInfo?: DeliveryInfoOrderByWithRelationInput
  }

  export type DeliveryInfoTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    languageCode?: string
    AND?: DeliveryInfoTranslationWhereInput | DeliveryInfoTranslationWhereInput[]
    OR?: DeliveryInfoTranslationWhereInput[]
    NOT?: DeliveryInfoTranslationWhereInput | DeliveryInfoTranslationWhereInput[]
    createdAt?: DateTimeFilter<"DeliveryInfoTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryInfoTranslation"> | Date | string
    description?: StringFilter<"DeliveryInfoTranslation"> | string
    deliveryId?: StringFilter<"DeliveryInfoTranslation"> | string
    deliveryInfo?: XOR<DeliveryInfoRelationFilter, DeliveryInfoWhereInput>
  }, "id" | "languageCode">

  export type DeliveryInfoTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    deliveryId?: SortOrder
    _count?: DeliveryInfoTranslationCountOrderByAggregateInput
    _max?: DeliveryInfoTranslationMaxOrderByAggregateInput
    _min?: DeliveryInfoTranslationMinOrderByAggregateInput
  }

  export type DeliveryInfoTranslationScalarWhereWithAggregatesInput = {
    AND?: DeliveryInfoTranslationScalarWhereWithAggregatesInput | DeliveryInfoTranslationScalarWhereWithAggregatesInput[]
    OR?: DeliveryInfoTranslationScalarWhereWithAggregatesInput[]
    NOT?: DeliveryInfoTranslationScalarWhereWithAggregatesInput | DeliveryInfoTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeliveryInfoTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeliveryInfoTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeliveryInfoTranslation"> | Date | string
    description?: StringWithAggregatesFilter<"DeliveryInfoTranslation"> | string
    languageCode?: StringWithAggregatesFilter<"DeliveryInfoTranslation"> | string
    deliveryId?: StringWithAggregatesFilter<"DeliveryInfoTranslation"> | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    id?: StringFilter<"PaymentMethod"> | string
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    description?: StringFilter<"PaymentMethod"> | string
    translation?: PaymentMethodTranslationListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    translation?: PaymentMethodTranslationOrderByRelationAggregateInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    createdAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethod"> | Date | string
    description?: StringFilter<"PaymentMethod"> | string
    translation?: PaymentMethodTranslationListRelationFilter
  }, "id">

  export type PaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethod"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethod"> | Date | string
    description?: StringWithAggregatesFilter<"PaymentMethod"> | string
  }

  export type PaymentMethodTranslationWhereInput = {
    AND?: PaymentMethodTranslationWhereInput | PaymentMethodTranslationWhereInput[]
    OR?: PaymentMethodTranslationWhereInput[]
    NOT?: PaymentMethodTranslationWhereInput | PaymentMethodTranslationWhereInput[]
    id?: StringFilter<"PaymentMethodTranslation"> | string
    createdAt?: DateTimeFilter<"PaymentMethodTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethodTranslation"> | Date | string
    description?: StringFilter<"PaymentMethodTranslation"> | string
    languageCode?: StringFilter<"PaymentMethodTranslation"> | string
    paymentMethodId?: StringFilter<"PaymentMethodTranslation"> | string
    paymentMethod?: XOR<PaymentMethodRelationFilter, PaymentMethodWhereInput>
  }

  export type PaymentMethodTranslationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    paymentMethodId?: SortOrder
    paymentMethod?: PaymentMethodOrderByWithRelationInput
  }

  export type PaymentMethodTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    languageCode?: string
    AND?: PaymentMethodTranslationWhereInput | PaymentMethodTranslationWhereInput[]
    OR?: PaymentMethodTranslationWhereInput[]
    NOT?: PaymentMethodTranslationWhereInput | PaymentMethodTranslationWhereInput[]
    createdAt?: DateTimeFilter<"PaymentMethodTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethodTranslation"> | Date | string
    description?: StringFilter<"PaymentMethodTranslation"> | string
    paymentMethodId?: StringFilter<"PaymentMethodTranslation"> | string
    paymentMethod?: XOR<PaymentMethodRelationFilter, PaymentMethodWhereInput>
  }, "id" | "languageCode">

  export type PaymentMethodTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    paymentMethodId?: SortOrder
    _count?: PaymentMethodTranslationCountOrderByAggregateInput
    _max?: PaymentMethodTranslationMaxOrderByAggregateInput
    _min?: PaymentMethodTranslationMinOrderByAggregateInput
  }

  export type PaymentMethodTranslationScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodTranslationScalarWhereWithAggregatesInput | PaymentMethodTranslationScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodTranslationScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodTranslationScalarWhereWithAggregatesInput | PaymentMethodTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentMethodTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PaymentMethodTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentMethodTranslation"> | Date | string
    description?: StringWithAggregatesFilter<"PaymentMethodTranslation"> | string
    languageCode?: StringWithAggregatesFilter<"PaymentMethodTranslation"> | string
    paymentMethodId?: StringWithAggregatesFilter<"PaymentMethodTranslation"> | string
  }

  export type FAQWhereInput = {
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    id?: StringFilter<"FAQ"> | string
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updateAt?: DateTimeFilter<"FAQ"> | Date | string
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    translations?: FAQTranslationListRelationFilter
  }

  export type FAQOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    translations?: FAQTranslationOrderByRelationAggregateInput
  }

  export type FAQWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FAQWhereInput | FAQWhereInput[]
    OR?: FAQWhereInput[]
    NOT?: FAQWhereInput | FAQWhereInput[]
    createdAt?: DateTimeFilter<"FAQ"> | Date | string
    updateAt?: DateTimeFilter<"FAQ"> | Date | string
    question?: StringFilter<"FAQ"> | string
    answer?: StringFilter<"FAQ"> | string
    translations?: FAQTranslationListRelationFilter
  }, "id">

  export type FAQOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    _count?: FAQCountOrderByAggregateInput
    _max?: FAQMaxOrderByAggregateInput
    _min?: FAQMinOrderByAggregateInput
  }

  export type FAQScalarWhereWithAggregatesInput = {
    AND?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    OR?: FAQScalarWhereWithAggregatesInput[]
    NOT?: FAQScalarWhereWithAggregatesInput | FAQScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FAQ"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"FAQ"> | Date | string
    question?: StringWithAggregatesFilter<"FAQ"> | string
    answer?: StringWithAggregatesFilter<"FAQ"> | string
  }

  export type FAQTranslationWhereInput = {
    AND?: FAQTranslationWhereInput | FAQTranslationWhereInput[]
    OR?: FAQTranslationWhereInput[]
    NOT?: FAQTranslationWhereInput | FAQTranslationWhereInput[]
    id?: StringFilter<"FAQTranslation"> | string
    createdAt?: DateTimeFilter<"FAQTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"FAQTranslation"> | Date | string
    question?: StringFilter<"FAQTranslation"> | string
    answer?: StringFilter<"FAQTranslation"> | string
    languageCode?: StringFilter<"FAQTranslation"> | string
    faqId?: StringFilter<"FAQTranslation"> | string
    faq?: XOR<FAQRelationFilter, FAQWhereInput>
  }

  export type FAQTranslationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    languageCode?: SortOrder
    faqId?: SortOrder
    faq?: FAQOrderByWithRelationInput
  }

  export type FAQTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    languageCode?: string
    AND?: FAQTranslationWhereInput | FAQTranslationWhereInput[]
    OR?: FAQTranslationWhereInput[]
    NOT?: FAQTranslationWhereInput | FAQTranslationWhereInput[]
    createdAt?: DateTimeFilter<"FAQTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"FAQTranslation"> | Date | string
    question?: StringFilter<"FAQTranslation"> | string
    answer?: StringFilter<"FAQTranslation"> | string
    faqId?: StringFilter<"FAQTranslation"> | string
    faq?: XOR<FAQRelationFilter, FAQWhereInput>
  }, "id" | "languageCode">

  export type FAQTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    languageCode?: SortOrder
    faqId?: SortOrder
    _count?: FAQTranslationCountOrderByAggregateInput
    _max?: FAQTranslationMaxOrderByAggregateInput
    _min?: FAQTranslationMinOrderByAggregateInput
  }

  export type FAQTranslationScalarWhereWithAggregatesInput = {
    AND?: FAQTranslationScalarWhereWithAggregatesInput | FAQTranslationScalarWhereWithAggregatesInput[]
    OR?: FAQTranslationScalarWhereWithAggregatesInput[]
    NOT?: FAQTranslationScalarWhereWithAggregatesInput | FAQTranslationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FAQTranslation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FAQTranslation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FAQTranslation"> | Date | string
    question?: StringWithAggregatesFilter<"FAQTranslation"> | string
    answer?: StringWithAggregatesFilter<"FAQTranslation"> | string
    languageCode?: StringWithAggregatesFilter<"FAQTranslation"> | string
    faqId?: StringWithAggregatesFilter<"FAQTranslation"> | string
  }

  export type HeroBillboardsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image: string
    title?: string
    subtitle?: string
    url: string
    translations?: HeroBillboardsTranslationCreateNestedManyWithoutHeroBillboardInput
  }

  export type HeroBillboardsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image: string
    title?: string
    subtitle?: string
    url: string
    translations?: HeroBillboardsTranslationUncheckedCreateNestedManyWithoutHeroBillboardInput
  }

  export type HeroBillboardsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    translations?: HeroBillboardsTranslationUpdateManyWithoutHeroBillboardNestedInput
  }

  export type HeroBillboardsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    translations?: HeroBillboardsTranslationUncheckedUpdateManyWithoutHeroBillboardNestedInput
  }

  export type HeroBillboardsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image: string
    title?: string
    subtitle?: string
    url: string
  }

  export type HeroBillboardsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HeroBillboardsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HeroBillboardsTranslationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string
    langCode: string
    subtitle?: string
    heroBillboard: HeroBillboardsCreateNestedOneWithoutTranslationsInput
  }

  export type HeroBillboardsTranslationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string
    langCode: string
    subtitle?: string
    heroBillboardId: string
  }

  export type HeroBillboardsTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    langCode?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    heroBillboard?: HeroBillboardsUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type HeroBillboardsTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    langCode?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    heroBillboardId?: StringFieldUpdateOperationsInput | string
  }

  export type HeroBillboardsTranslationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string
    langCode: string
    subtitle?: string
    heroBillboardId: string
  }

  export type HeroBillboardsTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    langCode?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
  }

  export type HeroBillboardsTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    langCode?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    heroBillboardId?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
  }

  export type LanguageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
  }

  export type LanguageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    code: string
  }

  export type LanguageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type BillboardCreateInput = {
    id?: string
    label: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryCreateNestedManyWithoutBillboardInput
  }

  export type BillboardUncheckedCreateInput = {
    id?: string
    label: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutBillboardInput
  }

  export type BillboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUpdateManyWithoutBillboardNestedInput
  }

  export type BillboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutBillboardNestedInput
  }

  export type BillboardCreateManyInput = {
    id?: string
    label: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    billboard?: BillboardCreateNestedOneWithoutCategoriesInput
    products?: ProductCategoryCreateNestedManyWithoutCategoryInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    billboardId?: string | null
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billboard?: BillboardUpdateOneWithoutCategoriesNestedInput
    products?: ProductCategoryUpdateManyWithoutCategoryNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    billboardId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    billboardId?: string | null
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    maxPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    billboardId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductCategoryCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCategoriesInput
    category: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductCategoryUncheckedCreateInput = {
    id?: string
    productId: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCategoriesNestedInput
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryCreateManyInput = {
    id?: string
    productId: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ImageCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ImageUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ImageUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ImageUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    title: string
    description: string
    product: ProductCreateNestedOneWithoutTranslationsInput
  }

  export type ProductTranslationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    title: string
    description: string
    productId: string
  }

  export type ProductTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    product?: ProductUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type ProductTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    title: string
    description: string
    productId: string
  }

  export type ProductTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateInput = {
    id?: string
    productId: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateManyInput = {
    id?: string
    productId: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    isPaid?: boolean
    firstName?: string
    lastName?: string
    phone?: string
    email?: string
    orderNumber?: string
    message?: string
    messagngerType?: string
    messenger?: string
    totalPrice?: number
    orderStatus?: $Enums.OrderTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    user: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    isPaid?: boolean
    firstName?: string
    lastName?: string
    phone?: string
    email?: string
    orderNumber?: string
    message?: string
    messagngerType?: string
    messenger?: string
    totalPrice?: number
    orderStatus?: $Enums.OrderTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderStatus?: EnumOrderTypesFieldUpdateOperationsInput | $Enums.OrderTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderStatus?: EnumOrderTypesFieldUpdateOperationsInput | $Enums.OrderTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    isPaid?: boolean
    firstName?: string
    lastName?: string
    phone?: string
    email?: string
    orderNumber?: string
    message?: string
    messagngerType?: string
    messenger?: string
    totalPrice?: number
    orderStatus?: $Enums.OrderTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderStatus?: EnumOrderTypesFieldUpdateOperationsInput | $Enums.OrderTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderStatus?: EnumOrderTypesFieldUpdateOperationsInput | $Enums.OrderTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    price?: string
    quantity?: number
    order: OrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: string
    price?: string
    productId: string
    quantity?: number
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: string
    price?: string
    productId: string
    quantity?: number
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CharacteristicCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string | null
    productCharacteristics?: ProductCharacteristicCreateNestedManyWithoutCharacteristicInput
    translations?: CharacteristicTranslationCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string | null
    productCharacteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicInput
    translations?: CharacteristicTranslationUncheckedCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productCharacteristics?: ProductCharacteristicUpdateManyWithoutCharacteristicNestedInput
    translations?: CharacteristicTranslationUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productCharacteristics?: ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicNestedInput
    translations?: CharacteristicTranslationUncheckedUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string | null
  }

  export type CharacteristicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacteristicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacteristicTranslationCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    languageCode: string
    name: string
    characteristic: CharacteristicCreateNestedOneWithoutTranslationsInput
  }

  export type CharacteristicTranslationUncheckedCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    languageCode: string
    name: string
    characteristicId: string
  }

  export type CharacteristicTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    characteristic?: CharacteristicUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type CharacteristicTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicTranslationCreateManyInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    languageCode: string
    name: string
    characteristicId: string
  }

  export type CharacteristicTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCharacteristicCreateInput = {
    id?: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    product: ProductCreateNestedOneWithoutProductCharacteristicsInput
    characteristic: CharacteristicCreateNestedOneWithoutProductCharacteristicsInput
    translations?: ProductCharacteristicTranslationCreateNestedManyWithoutProductCharacteristicInput
  }

  export type ProductCharacteristicUncheckedCreateInput = {
    id?: string
    productId: string
    characteristicId: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    translations?: ProductCharacteristicTranslationUncheckedCreateNestedManyWithoutProductCharacteristicInput
  }

  export type ProductCharacteristicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductCharacteristicsNestedInput
    characteristic?: CharacteristicUpdateOneRequiredWithoutProductCharacteristicsNestedInput
    translations?: ProductCharacteristicTranslationUpdateManyWithoutProductCharacteristicNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ProductCharacteristicTranslationUncheckedUpdateManyWithoutProductCharacteristicNestedInput
  }

  export type ProductCharacteristicCreateManyInput = {
    id?: string
    productId: string
    characteristicId: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProductCharacteristicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCharacteristicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCharacteristicTranslationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    description: string
    productCharacteristic: ProductCharacteristicCreateNestedOneWithoutTranslationsInput
  }

  export type ProductCharacteristicTranslationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    description: string
    productCharacteristicId: string
  }

  export type ProductCharacteristicTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    productCharacteristic?: ProductCharacteristicUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type ProductCharacteristicTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    productCharacteristicId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCharacteristicTranslationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    description: string
    productCharacteristicId: string
  }

  export type ProductCharacteristicTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCharacteristicTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    productCharacteristicId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string
    lastName?: string
    email?: string
    phoneNumber?: string
    address?: string
    avatar?: string
    role?: string
    password?: string
    orders?: OrderCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string
    lastName?: string
    email?: string
    phoneNumber?: string
    address?: string
    avatar?: string
    role?: string
    password?: string
    orders?: OrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    orders?: OrderUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string
    lastName?: string
    email?: string
    phoneNumber?: string
    address?: string
    avatar?: string
    role?: string
    password?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    avtor: string
    photo?: ReviewPhotoCreateNestedManyWithoutReviewInput
    translation?: ReviewTranslationCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    avtor: string
    photo?: ReviewPhotoUncheckedCreateNestedManyWithoutReviewInput
    translation?: ReviewTranslationUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    avtor?: StringFieldUpdateOperationsInput | string
    photo?: ReviewPhotoUpdateManyWithoutReviewNestedInput
    translation?: ReviewTranslationUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    avtor?: StringFieldUpdateOperationsInput | string
    photo?: ReviewPhotoUncheckedUpdateManyWithoutReviewNestedInput
    translation?: ReviewTranslationUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    avtor: string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    avtor?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    avtor?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewPhotoCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    url: string
    review: ReviewCreateNestedOneWithoutPhotoInput
  }

  export type ReviewPhotoUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    url: string
    reviewId: string
  }

  export type ReviewPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    review?: ReviewUpdateOneRequiredWithoutPhotoNestedInput
  }

  export type ReviewPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewPhotoCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    url: string
    reviewId: string
  }

  export type ReviewPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewTranslationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    languageCode: string
    review: ReviewCreateNestedOneWithoutTranslationInput
  }

  export type ReviewTranslationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    languageCode: string
    reviewId: string
  }

  export type ReviewTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    review?: ReviewUpdateOneRequiredWithoutTranslationNestedInput
  }

  export type ReviewTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewTranslationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    languageCode: string
    reviewId: string
  }

  export type ReviewTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    email: string
    messenger: string
    messagngerType: string
    message: string
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    email: string
    messenger: string
    messagngerType: string
    message: string
  }

  export type FeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName: string
    email: string
    messenger: string
    messagngerType: string
    message: string
  }

  export type FeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryInfoCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    translation?: DeliveryInfoTranslationCreateNestedManyWithoutDeliveryInfoInput
  }

  export type DeliveryInfoUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    translation?: DeliveryInfoTranslationUncheckedCreateNestedManyWithoutDeliveryInfoInput
  }

  export type DeliveryInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    translation?: DeliveryInfoTranslationUpdateManyWithoutDeliveryInfoNestedInput
  }

  export type DeliveryInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    translation?: DeliveryInfoTranslationUncheckedUpdateManyWithoutDeliveryInfoNestedInput
  }

  export type DeliveryInfoCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type DeliveryInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryInfoTranslationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
    deliveryInfo: DeliveryInfoCreateNestedOneWithoutTranslationInput
  }

  export type DeliveryInfoTranslationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
    deliveryId: string
  }

  export type DeliveryInfoTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    deliveryInfo?: DeliveryInfoUpdateOneRequiredWithoutTranslationNestedInput
  }

  export type DeliveryInfoTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryInfoTranslationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
    deliveryId: string
  }

  export type DeliveryInfoTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryInfoTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    deliveryId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    translation?: PaymentMethodTranslationCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    translation?: PaymentMethodTranslationUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    translation?: PaymentMethodTranslationUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    translation?: PaymentMethodTranslationUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type PaymentMethodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodTranslationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
    paymentMethod: PaymentMethodCreateNestedOneWithoutTranslationInput
  }

  export type PaymentMethodTranslationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
    paymentMethodId: string
  }

  export type PaymentMethodTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutTranslationNestedInput
  }

  export type PaymentMethodTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodTranslationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
    paymentMethodId: string
  }

  export type PaymentMethodTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    paymentMethodId?: StringFieldUpdateOperationsInput | string
  }

  export type FAQCreateInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    question: string
    answer: string
    translations?: FAQTranslationCreateNestedManyWithoutFaqInput
  }

  export type FAQUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    question: string
    answer: string
    translations?: FAQTranslationUncheckedCreateNestedManyWithoutFaqInput
  }

  export type FAQUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    translations?: FAQTranslationUpdateManyWithoutFaqNestedInput
  }

  export type FAQUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    translations?: FAQTranslationUncheckedUpdateManyWithoutFaqNestedInput
  }

  export type FAQCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    question: string
    answer: string
  }

  export type FAQUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FAQUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FAQTranslationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: string
    answer: string
    languageCode: string
    faq: FAQCreateNestedOneWithoutTranslationsInput
  }

  export type FAQTranslationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: string
    answer: string
    languageCode: string
    faqId: string
  }

  export type FAQTranslationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    faq?: FAQUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type FAQTranslationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    faqId?: StringFieldUpdateOperationsInput | string
  }

  export type FAQTranslationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: string
    answer: string
    languageCode: string
    faqId: string
  }

  export type FAQTranslationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type FAQTranslationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    faqId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type HeroBillboardsTranslationListRelationFilter = {
    every?: HeroBillboardsTranslationWhereInput
    some?: HeroBillboardsTranslationWhereInput
    none?: HeroBillboardsTranslationWhereInput
  }

  export type HeroBillboardsTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HeroBillboardsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    url?: SortOrder
  }

  export type HeroBillboardsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    url?: SortOrder
  }

  export type HeroBillboardsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    image?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    url?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type HeroBillboardsRelationFilter = {
    is?: HeroBillboardsWhereInput
    isNot?: HeroBillboardsWhereInput
  }

  export type HeroBillboardsTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    langCode?: SortOrder
    subtitle?: SortOrder
    heroBillboardId?: SortOrder
  }

  export type HeroBillboardsTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    langCode?: SortOrder
    subtitle?: SortOrder
    heroBillboardId?: SortOrder
  }

  export type HeroBillboardsTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    langCode?: SortOrder
    subtitle?: SortOrder
    heroBillboardId?: SortOrder
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    code?: SortOrder
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillboardCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillboardMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BillboardMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTypeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeCategory | EnumTypeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TypeCategory[] | ListEnumTypeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeCategory[] | ListEnumTypeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeCategoryFilter<$PrismaModel> | $Enums.TypeCategory
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BillboardNullableRelationFilter = {
    is?: BillboardWhereInput | null
    isNot?: BillboardWhereInput | null
  }

  export type ProductCategoryListRelationFilter = {
    every?: ProductCategoryWhereInput
    some?: ProductCategoryWhereInput
    none?: ProductCategoryWhereInput
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProductCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    billboardId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    maxPrice?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    maxPrice?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    billboardId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    maxPrice?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    billboardId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    maxPrice?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    maxPrice?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTypeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeCategory | EnumTypeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TypeCategory[] | ListEnumTypeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeCategory[] | ListEnumTypeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TypeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeCategoryFilter<$PrismaModel>
    _max?: NestedEnumTypeCategoryFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type ProductCategoryProductIdCategoryIdCompoundUniqueInput = {
    productId: string
    categoryId: string
  }

  export type ProductCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type ProductCharacteristicListRelationFilter = {
    every?: ProductCharacteristicWhereInput
    some?: ProductCharacteristicWhereInput
    none?: ProductCharacteristicWhereInput
  }

  export type ProductTranslationListRelationFilter = {
    every?: ProductTranslationWhereInput
    some?: ProductTranslationWhereInput
    none?: ProductTranslationWhereInput
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCharacteristicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    type?: SortOrder
    isArchived?: SortOrder
    isFeatured?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    position?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    type?: SortOrder
    isArchived?: SortOrder
    isFeatured?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    type?: SortOrder
    isArchived?: SortOrder
    isFeatured?: SortOrder
    backgroundColor?: SortOrder
    textColor?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    article?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    quantity?: SortOrder
    price?: SortOrder
    position?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProductTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    productId?: SortOrder
  }

  export type ProductTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    productId?: SortOrder
  }

  export type ProductTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    title?: SortOrder
    description?: SortOrder
    productId?: SortOrder
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOrderTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderTypes | EnumOrderTypesFieldRefInput<$PrismaModel>
    in?: $Enums.OrderTypes[] | ListEnumOrderTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderTypes[] | ListEnumOrderTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypesFilter<$PrismaModel> | $Enums.OrderTypes
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    isPaid?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    orderNumber?: SortOrder
    message?: SortOrder
    messagngerType?: SortOrder
    messenger?: SortOrder
    totalPrice?: SortOrder
    orderStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    isPaid?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    orderNumber?: SortOrder
    message?: SortOrder
    messagngerType?: SortOrder
    messenger?: SortOrder
    totalPrice?: SortOrder
    orderStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    isPaid?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    orderNumber?: SortOrder
    message?: SortOrder
    messagngerType?: SortOrder
    messenger?: SortOrder
    totalPrice?: SortOrder
    orderStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalPrice?: SortOrder
  }

  export type EnumOrderTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderTypes | EnumOrderTypesFieldRefInput<$PrismaModel>
    in?: $Enums.OrderTypes[] | ListEnumOrderTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderTypes[] | ListEnumOrderTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypesWithAggregatesFilter<$PrismaModel> | $Enums.OrderTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypesFilter<$PrismaModel>
    _max?: NestedEnumOrderTypesFilter<$PrismaModel>
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemProductIdOrderIdCompoundUniqueInput = {
    productId: string
    orderId: string
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderId?: SortOrder
    price?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type CharacteristicTranslationListRelationFilter = {
    every?: CharacteristicTranslationWhereInput
    some?: CharacteristicTranslationWhereInput
    none?: CharacteristicTranslationWhereInput
  }

  export type CharacteristicTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacteristicCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CharacteristicMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CharacteristicMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CharacteristicRelationFilter = {
    is?: CharacteristicWhereInput
    isNot?: CharacteristicWhereInput
  }

  export type CharacteristicTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    languageCode?: SortOrder
    name?: SortOrder
    characteristicId?: SortOrder
  }

  export type CharacteristicTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    languageCode?: SortOrder
    name?: SortOrder
    characteristicId?: SortOrder
  }

  export type CharacteristicTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    languageCode?: SortOrder
    name?: SortOrder
    characteristicId?: SortOrder
  }

  export type ProductCharacteristicTranslationListRelationFilter = {
    every?: ProductCharacteristicTranslationWhereInput
    some?: ProductCharacteristicTranslationWhereInput
    none?: ProductCharacteristicTranslationWhereInput
  }

  export type ProductCharacteristicTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCharacteristicProductIdCharacteristicIdCompoundUniqueInput = {
    productId: string
    characteristicId: string
  }

  export type ProductCharacteristicCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProductCharacteristicMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProductCharacteristicMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    characteristicId?: SortOrder
    name?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type ProductCharacteristicRelationFilter = {
    is?: ProductCharacteristicWhereInput
    isNot?: ProductCharacteristicWhereInput
  }

  export type ProductCharacteristicTranslationProductCharacteristicIdLanguageCodeCompoundUniqueInput = {
    productCharacteristicId: string
    languageCode: string
  }

  export type ProductCharacteristicTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    description?: SortOrder
    productCharacteristicId?: SortOrder
  }

  export type ProductCharacteristicTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    description?: SortOrder
    productCharacteristicId?: SortOrder
  }

  export type ProductCharacteristicTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    languageCode?: SortOrder
    description?: SortOrder
    productCharacteristicId?: SortOrder
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    password?: SortOrder
  }

  export type ReviewPhotoListRelationFilter = {
    every?: ReviewPhotoWhereInput
    some?: ReviewPhotoWhereInput
    none?: ReviewPhotoWhereInput
  }

  export type ReviewTranslationListRelationFilter = {
    every?: ReviewTranslationWhereInput
    some?: ReviewTranslationWhereInput
    none?: ReviewTranslationWhereInput
  }

  export type ReviewPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    avtor?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    avtor?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    avtor?: SortOrder
  }

  export type ReviewRelationFilter = {
    is?: ReviewWhereInput
    isNot?: ReviewWhereInput
  }

  export type ReviewPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    url?: SortOrder
    reviewId?: SortOrder
  }

  export type ReviewPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    url?: SortOrder
    reviewId?: SortOrder
  }

  export type ReviewPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    url?: SortOrder
    reviewId?: SortOrder
  }

  export type ReviewTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    languageCode?: SortOrder
    reviewId?: SortOrder
  }

  export type ReviewTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    languageCode?: SortOrder
    reviewId?: SortOrder
  }

  export type ReviewTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    desc?: SortOrder
    languageCode?: SortOrder
    reviewId?: SortOrder
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    email?: SortOrder
    messenger?: SortOrder
    messagngerType?: SortOrder
    message?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    email?: SortOrder
    messenger?: SortOrder
    messagngerType?: SortOrder
    message?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstName?: SortOrder
    email?: SortOrder
    messenger?: SortOrder
    messagngerType?: SortOrder
    message?: SortOrder
  }

  export type DeliveryInfoTranslationListRelationFilter = {
    every?: DeliveryInfoTranslationWhereInput
    some?: DeliveryInfoTranslationWhereInput
    none?: DeliveryInfoTranslationWhereInput
  }

  export type DeliveryInfoTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryInfoCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type DeliveryInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type DeliveryInfoMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type DeliveryInfoRelationFilter = {
    is?: DeliveryInfoWhereInput
    isNot?: DeliveryInfoWhereInput
  }

  export type DeliveryInfoTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    deliveryId?: SortOrder
  }

  export type DeliveryInfoTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    deliveryId?: SortOrder
  }

  export type DeliveryInfoTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    deliveryId?: SortOrder
  }

  export type PaymentMethodTranslationListRelationFilter = {
    every?: PaymentMethodTranslationWhereInput
    some?: PaymentMethodTranslationWhereInput
    none?: PaymentMethodTranslationWhereInput
  }

  export type PaymentMethodTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
  }

  export type PaymentMethodRelationFilter = {
    is?: PaymentMethodWhereInput
    isNot?: PaymentMethodWhereInput
  }

  export type PaymentMethodTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type PaymentMethodTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type PaymentMethodTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    languageCode?: SortOrder
    paymentMethodId?: SortOrder
  }

  export type FAQTranslationListRelationFilter = {
    every?: FAQTranslationWhereInput
    some?: FAQTranslationWhereInput
    none?: FAQTranslationWhereInput
  }

  export type FAQTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FAQCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type FAQMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type FAQMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updateAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type FAQRelationFilter = {
    is?: FAQWhereInput
    isNot?: FAQWhereInput
  }

  export type FAQTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    languageCode?: SortOrder
    faqId?: SortOrder
  }

  export type FAQTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    languageCode?: SortOrder
    faqId?: SortOrder
  }

  export type FAQTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    languageCode?: SortOrder
    faqId?: SortOrder
  }

  export type HeroBillboardsTranslationCreateNestedManyWithoutHeroBillboardInput = {
    create?: XOR<HeroBillboardsTranslationCreateWithoutHeroBillboardInput, HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput> | HeroBillboardsTranslationCreateWithoutHeroBillboardInput[] | HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput[]
    connectOrCreate?: HeroBillboardsTranslationCreateOrConnectWithoutHeroBillboardInput | HeroBillboardsTranslationCreateOrConnectWithoutHeroBillboardInput[]
    createMany?: HeroBillboardsTranslationCreateManyHeroBillboardInputEnvelope
    connect?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
  }

  export type HeroBillboardsTranslationUncheckedCreateNestedManyWithoutHeroBillboardInput = {
    create?: XOR<HeroBillboardsTranslationCreateWithoutHeroBillboardInput, HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput> | HeroBillboardsTranslationCreateWithoutHeroBillboardInput[] | HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput[]
    connectOrCreate?: HeroBillboardsTranslationCreateOrConnectWithoutHeroBillboardInput | HeroBillboardsTranslationCreateOrConnectWithoutHeroBillboardInput[]
    createMany?: HeroBillboardsTranslationCreateManyHeroBillboardInputEnvelope
    connect?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type HeroBillboardsTranslationUpdateManyWithoutHeroBillboardNestedInput = {
    create?: XOR<HeroBillboardsTranslationCreateWithoutHeroBillboardInput, HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput> | HeroBillboardsTranslationCreateWithoutHeroBillboardInput[] | HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput[]
    connectOrCreate?: HeroBillboardsTranslationCreateOrConnectWithoutHeroBillboardInput | HeroBillboardsTranslationCreateOrConnectWithoutHeroBillboardInput[]
    upsert?: HeroBillboardsTranslationUpsertWithWhereUniqueWithoutHeroBillboardInput | HeroBillboardsTranslationUpsertWithWhereUniqueWithoutHeroBillboardInput[]
    createMany?: HeroBillboardsTranslationCreateManyHeroBillboardInputEnvelope
    set?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
    disconnect?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
    delete?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
    connect?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
    update?: HeroBillboardsTranslationUpdateWithWhereUniqueWithoutHeroBillboardInput | HeroBillboardsTranslationUpdateWithWhereUniqueWithoutHeroBillboardInput[]
    updateMany?: HeroBillboardsTranslationUpdateManyWithWhereWithoutHeroBillboardInput | HeroBillboardsTranslationUpdateManyWithWhereWithoutHeroBillboardInput[]
    deleteMany?: HeroBillboardsTranslationScalarWhereInput | HeroBillboardsTranslationScalarWhereInput[]
  }

  export type HeroBillboardsTranslationUncheckedUpdateManyWithoutHeroBillboardNestedInput = {
    create?: XOR<HeroBillboardsTranslationCreateWithoutHeroBillboardInput, HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput> | HeroBillboardsTranslationCreateWithoutHeroBillboardInput[] | HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput[]
    connectOrCreate?: HeroBillboardsTranslationCreateOrConnectWithoutHeroBillboardInput | HeroBillboardsTranslationCreateOrConnectWithoutHeroBillboardInput[]
    upsert?: HeroBillboardsTranslationUpsertWithWhereUniqueWithoutHeroBillboardInput | HeroBillboardsTranslationUpsertWithWhereUniqueWithoutHeroBillboardInput[]
    createMany?: HeroBillboardsTranslationCreateManyHeroBillboardInputEnvelope
    set?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
    disconnect?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
    delete?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
    connect?: HeroBillboardsTranslationWhereUniqueInput | HeroBillboardsTranslationWhereUniqueInput[]
    update?: HeroBillboardsTranslationUpdateWithWhereUniqueWithoutHeroBillboardInput | HeroBillboardsTranslationUpdateWithWhereUniqueWithoutHeroBillboardInput[]
    updateMany?: HeroBillboardsTranslationUpdateManyWithWhereWithoutHeroBillboardInput | HeroBillboardsTranslationUpdateManyWithWhereWithoutHeroBillboardInput[]
    deleteMany?: HeroBillboardsTranslationScalarWhereInput | HeroBillboardsTranslationScalarWhereInput[]
  }

  export type HeroBillboardsCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<HeroBillboardsCreateWithoutTranslationsInput, HeroBillboardsUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: HeroBillboardsCreateOrConnectWithoutTranslationsInput
    connect?: HeroBillboardsWhereUniqueInput
  }

  export type HeroBillboardsUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<HeroBillboardsCreateWithoutTranslationsInput, HeroBillboardsUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: HeroBillboardsCreateOrConnectWithoutTranslationsInput
    upsert?: HeroBillboardsUpsertWithoutTranslationsInput
    connect?: HeroBillboardsWhereUniqueInput
    update?: XOR<XOR<HeroBillboardsUpdateToOneWithWhereWithoutTranslationsInput, HeroBillboardsUpdateWithoutTranslationsInput>, HeroBillboardsUncheckedUpdateWithoutTranslationsInput>
  }

  export type CategoryCreateNestedManyWithoutBillboardInput = {
    create?: XOR<CategoryCreateWithoutBillboardInput, CategoryUncheckedCreateWithoutBillboardInput> | CategoryCreateWithoutBillboardInput[] | CategoryUncheckedCreateWithoutBillboardInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBillboardInput | CategoryCreateOrConnectWithoutBillboardInput[]
    createMany?: CategoryCreateManyBillboardInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutBillboardInput = {
    create?: XOR<CategoryCreateWithoutBillboardInput, CategoryUncheckedCreateWithoutBillboardInput> | CategoryCreateWithoutBillboardInput[] | CategoryUncheckedCreateWithoutBillboardInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBillboardInput | CategoryCreateOrConnectWithoutBillboardInput[]
    createMany?: CategoryCreateManyBillboardInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CategoryUpdateManyWithoutBillboardNestedInput = {
    create?: XOR<CategoryCreateWithoutBillboardInput, CategoryUncheckedCreateWithoutBillboardInput> | CategoryCreateWithoutBillboardInput[] | CategoryUncheckedCreateWithoutBillboardInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBillboardInput | CategoryCreateOrConnectWithoutBillboardInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutBillboardInput | CategoryUpsertWithWhereUniqueWithoutBillboardInput[]
    createMany?: CategoryCreateManyBillboardInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutBillboardInput | CategoryUpdateWithWhereUniqueWithoutBillboardInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutBillboardInput | CategoryUpdateManyWithWhereWithoutBillboardInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutBillboardNestedInput = {
    create?: XOR<CategoryCreateWithoutBillboardInput, CategoryUncheckedCreateWithoutBillboardInput> | CategoryCreateWithoutBillboardInput[] | CategoryUncheckedCreateWithoutBillboardInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutBillboardInput | CategoryCreateOrConnectWithoutBillboardInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutBillboardInput | CategoryUpsertWithWhereUniqueWithoutBillboardInput[]
    createMany?: CategoryCreateManyBillboardInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutBillboardInput | CategoryUpdateWithWhereUniqueWithoutBillboardInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutBillboardInput | CategoryUpdateManyWithWhereWithoutBillboardInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type BillboardCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<BillboardCreateWithoutCategoriesInput, BillboardUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BillboardCreateOrConnectWithoutCategoriesInput
    connect?: BillboardWhereUniqueInput
  }

  export type ProductCategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type EnumTypeCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TypeCategory
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BillboardUpdateOneWithoutCategoriesNestedInput = {
    create?: XOR<BillboardCreateWithoutCategoriesInput, BillboardUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: BillboardCreateOrConnectWithoutCategoriesInput
    upsert?: BillboardUpsertWithoutCategoriesInput
    disconnect?: BillboardWhereInput | boolean
    delete?: BillboardWhereInput | boolean
    connect?: BillboardWhereUniqueInput
    update?: XOR<XOR<BillboardUpdateToOneWithWhereWithoutCategoriesInput, BillboardUpdateWithoutCategoriesInput>, BillboardUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductCategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput | ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput | ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCategoryInput | ProductCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput> | ProductCategoryCreateWithoutCategoryInput[] | ProductCategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutCategoryInput | ProductCategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput | ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCategoryCreateManyCategoryInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput | ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutCategoryInput | ProductCategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCategoriesInput
    upsert?: ProductUpsertWithoutCategoriesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCategoriesInput, ProductUpdateWithoutCategoriesInput>, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type CategoryUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductCategoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ImageCreateNestedManyWithoutProductInput = {
    create?: XOR<ImageCreateWithoutProductInput, ImageUncheckedCreateWithoutProductInput> | ImageCreateWithoutProductInput[] | ImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutProductInput | ImageCreateOrConnectWithoutProductInput[]
    createMany?: ImageCreateManyProductInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductCharacteristicCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput> | ProductCharacteristicCreateWithoutProductInput[] | ProductCharacteristicUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutProductInput | ProductCharacteristicCreateOrConnectWithoutProductInput[]
    createMany?: ProductCharacteristicCreateManyProductInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type ProductTranslationCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput> | ProductTranslationCreateWithoutProductInput[] | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProductInput | ProductTranslationCreateOrConnectWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type ProductCategoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ImageCreateWithoutProductInput, ImageUncheckedCreateWithoutProductInput> | ImageCreateWithoutProductInput[] | ImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutProductInput | ImageCreateOrConnectWithoutProductInput[]
    createMany?: ImageCreateManyProductInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput> | ProductCharacteristicCreateWithoutProductInput[] | ProductCharacteristicUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutProductInput | ProductCharacteristicCreateOrConnectWithoutProductInput[]
    createMany?: ProductCharacteristicCreateManyProductInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type ProductTranslationUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput> | ProductTranslationCreateWithoutProductInput[] | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProductInput | ProductTranslationCreateOrConnectWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProductCategoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<ImageCreateWithoutProductInput, ImageUncheckedCreateWithoutProductInput> | ImageCreateWithoutProductInput[] | ImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutProductInput | ImageCreateOrConnectWithoutProductInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutProductInput | ImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ImageCreateManyProductInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutProductInput | ImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutProductInput | ImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductCharacteristicUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput> | ProductCharacteristicCreateWithoutProductInput[] | ProductCharacteristicUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutProductInput | ProductCharacteristicCreateOrConnectWithoutProductInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput | ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCharacteristicCreateManyProductInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput | ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutProductInput | ProductCharacteristicUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type ProductTranslationUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput> | ProductTranslationCreateWithoutProductInput[] | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProductInput | ProductTranslationCreateOrConnectWithoutProductInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutProductInput | ProductTranslationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutProductInput | ProductTranslationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutProductInput | ProductTranslationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput> | ProductCategoryCreateWithoutProductInput[] | ProductCategoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCategoryCreateOrConnectWithoutProductInput | ProductCategoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductCategoryUpsertWithWhereUniqueWithoutProductInput | ProductCategoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCategoryCreateManyProductInputEnvelope
    set?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    disconnect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    delete?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    connect?: ProductCategoryWhereUniqueInput | ProductCategoryWhereUniqueInput[]
    update?: ProductCategoryUpdateWithWhereUniqueWithoutProductInput | ProductCategoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCategoryUpdateManyWithWhereWithoutProductInput | ProductCategoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ImageCreateWithoutProductInput, ImageUncheckedCreateWithoutProductInput> | ImageCreateWithoutProductInput[] | ImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutProductInput | ImageCreateOrConnectWithoutProductInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutProductInput | ImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ImageCreateManyProductInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutProductInput | ImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutProductInput | ImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput> | ProductCharacteristicCreateWithoutProductInput[] | ProductCharacteristicUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutProductInput | ProductCharacteristicCreateOrConnectWithoutProductInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput | ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductCharacteristicCreateManyProductInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput | ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutProductInput | ProductCharacteristicUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type ProductTranslationUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput> | ProductTranslationCreateWithoutProductInput[] | ProductTranslationUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTranslationCreateOrConnectWithoutProductInput | ProductTranslationCreateOrConnectWithoutProductInput[]
    upsert?: ProductTranslationUpsertWithWhereUniqueWithoutProductInput | ProductTranslationUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTranslationCreateManyProductInputEnvelope
    set?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    disconnect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    delete?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    connect?: ProductTranslationWhereUniqueInput | ProductTranslationWhereUniqueInput[]
    update?: ProductTranslationUpdateWithWhereUniqueWithoutProductInput | ProductTranslationUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTranslationUpdateManyWithWhereWithoutProductInput | ProductTranslationUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<ProductCreateWithoutTranslationsInput, ProductUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTranslationsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<ProductCreateWithoutTranslationsInput, ProductUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTranslationsInput
    upsert?: ProductUpsertWithoutTranslationsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTranslationsInput, ProductUpdateWithoutTranslationsInput>, ProductUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    upsert?: ProductUpsertWithoutImagesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutImagesInput, ProductUpdateWithoutImagesInput>, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EnumOrderTypesFieldUpdateOperationsInput = {
    set?: $Enums.OrderTypes
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductCharacteristicCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput> | ProductCharacteristicCreateWithoutCharacteristicInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type CharacteristicTranslationCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<CharacteristicTranslationCreateWithoutCharacteristicInput, CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput> | CharacteristicTranslationCreateWithoutCharacteristicInput[] | CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicTranslationCreateOrConnectWithoutCharacteristicInput | CharacteristicTranslationCreateOrConnectWithoutCharacteristicInput[]
    createMany?: CharacteristicTranslationCreateManyCharacteristicInputEnvelope
    connect?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
  }

  export type ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput> | ProductCharacteristicCreateWithoutCharacteristicInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicInputEnvelope
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
  }

  export type CharacteristicTranslationUncheckedCreateNestedManyWithoutCharacteristicInput = {
    create?: XOR<CharacteristicTranslationCreateWithoutCharacteristicInput, CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput> | CharacteristicTranslationCreateWithoutCharacteristicInput[] | CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicTranslationCreateOrConnectWithoutCharacteristicInput | CharacteristicTranslationCreateOrConnectWithoutCharacteristicInput[]
    createMany?: CharacteristicTranslationCreateManyCharacteristicInputEnvelope
    connect?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
  }

  export type ProductCharacteristicUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput> | ProductCharacteristicCreateWithoutCharacteristicInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput | ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput | ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput | ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type CharacteristicTranslationUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<CharacteristicTranslationCreateWithoutCharacteristicInput, CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput> | CharacteristicTranslationCreateWithoutCharacteristicInput[] | CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicTranslationCreateOrConnectWithoutCharacteristicInput | CharacteristicTranslationCreateOrConnectWithoutCharacteristicInput[]
    upsert?: CharacteristicTranslationUpsertWithWhereUniqueWithoutCharacteristicInput | CharacteristicTranslationUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: CharacteristicTranslationCreateManyCharacteristicInputEnvelope
    set?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
    disconnect?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
    delete?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
    connect?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
    update?: CharacteristicTranslationUpdateWithWhereUniqueWithoutCharacteristicInput | CharacteristicTranslationUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: CharacteristicTranslationUpdateManyWithWhereWithoutCharacteristicInput | CharacteristicTranslationUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: CharacteristicTranslationScalarWhereInput | CharacteristicTranslationScalarWhereInput[]
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput> | ProductCharacteristicCreateWithoutCharacteristicInput[] | ProductCharacteristicUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutCharacteristicInput | ProductCharacteristicCreateOrConnectWithoutCharacteristicInput[]
    upsert?: ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput | ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: ProductCharacteristicCreateManyCharacteristicInputEnvelope
    set?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    disconnect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    delete?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    connect?: ProductCharacteristicWhereUniqueInput | ProductCharacteristicWhereUniqueInput[]
    update?: ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput | ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput | ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
  }

  export type CharacteristicTranslationUncheckedUpdateManyWithoutCharacteristicNestedInput = {
    create?: XOR<CharacteristicTranslationCreateWithoutCharacteristicInput, CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput> | CharacteristicTranslationCreateWithoutCharacteristicInput[] | CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput[]
    connectOrCreate?: CharacteristicTranslationCreateOrConnectWithoutCharacteristicInput | CharacteristicTranslationCreateOrConnectWithoutCharacteristicInput[]
    upsert?: CharacteristicTranslationUpsertWithWhereUniqueWithoutCharacteristicInput | CharacteristicTranslationUpsertWithWhereUniqueWithoutCharacteristicInput[]
    createMany?: CharacteristicTranslationCreateManyCharacteristicInputEnvelope
    set?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
    disconnect?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
    delete?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
    connect?: CharacteristicTranslationWhereUniqueInput | CharacteristicTranslationWhereUniqueInput[]
    update?: CharacteristicTranslationUpdateWithWhereUniqueWithoutCharacteristicInput | CharacteristicTranslationUpdateWithWhereUniqueWithoutCharacteristicInput[]
    updateMany?: CharacteristicTranslationUpdateManyWithWhereWithoutCharacteristicInput | CharacteristicTranslationUpdateManyWithWhereWithoutCharacteristicInput[]
    deleteMany?: CharacteristicTranslationScalarWhereInput | CharacteristicTranslationScalarWhereInput[]
  }

  export type CharacteristicCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<CharacteristicCreateWithoutTranslationsInput, CharacteristicUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutTranslationsInput
    connect?: CharacteristicWhereUniqueInput
  }

  export type CharacteristicUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<CharacteristicCreateWithoutTranslationsInput, CharacteristicUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutTranslationsInput
    upsert?: CharacteristicUpsertWithoutTranslationsInput
    connect?: CharacteristicWhereUniqueInput
    update?: XOR<XOR<CharacteristicUpdateToOneWithWhereWithoutTranslationsInput, CharacteristicUpdateWithoutTranslationsInput>, CharacteristicUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductCreateNestedOneWithoutProductCharacteristicsInput = {
    create?: XOR<ProductCreateWithoutProductCharacteristicsInput, ProductUncheckedCreateWithoutProductCharacteristicsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductCharacteristicsInput
    connect?: ProductWhereUniqueInput
  }

  export type CharacteristicCreateNestedOneWithoutProductCharacteristicsInput = {
    create?: XOR<CharacteristicCreateWithoutProductCharacteristicsInput, CharacteristicUncheckedCreateWithoutProductCharacteristicsInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutProductCharacteristicsInput
    connect?: CharacteristicWhereUniqueInput
  }

  export type ProductCharacteristicTranslationCreateNestedManyWithoutProductCharacteristicInput = {
    create?: XOR<ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput, ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput> | ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput[] | ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicTranslationCreateOrConnectWithoutProductCharacteristicInput | ProductCharacteristicTranslationCreateOrConnectWithoutProductCharacteristicInput[]
    createMany?: ProductCharacteristicTranslationCreateManyProductCharacteristicInputEnvelope
    connect?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
  }

  export type ProductCharacteristicTranslationUncheckedCreateNestedManyWithoutProductCharacteristicInput = {
    create?: XOR<ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput, ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput> | ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput[] | ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicTranslationCreateOrConnectWithoutProductCharacteristicInput | ProductCharacteristicTranslationCreateOrConnectWithoutProductCharacteristicInput[]
    createMany?: ProductCharacteristicTranslationCreateManyProductCharacteristicInputEnvelope
    connect?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutProductCharacteristicsNestedInput = {
    create?: XOR<ProductCreateWithoutProductCharacteristicsInput, ProductUncheckedCreateWithoutProductCharacteristicsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutProductCharacteristicsInput
    upsert?: ProductUpsertWithoutProductCharacteristicsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutProductCharacteristicsInput, ProductUpdateWithoutProductCharacteristicsInput>, ProductUncheckedUpdateWithoutProductCharacteristicsInput>
  }

  export type CharacteristicUpdateOneRequiredWithoutProductCharacteristicsNestedInput = {
    create?: XOR<CharacteristicCreateWithoutProductCharacteristicsInput, CharacteristicUncheckedCreateWithoutProductCharacteristicsInput>
    connectOrCreate?: CharacteristicCreateOrConnectWithoutProductCharacteristicsInput
    upsert?: CharacteristicUpsertWithoutProductCharacteristicsInput
    connect?: CharacteristicWhereUniqueInput
    update?: XOR<XOR<CharacteristicUpdateToOneWithWhereWithoutProductCharacteristicsInput, CharacteristicUpdateWithoutProductCharacteristicsInput>, CharacteristicUncheckedUpdateWithoutProductCharacteristicsInput>
  }

  export type ProductCharacteristicTranslationUpdateManyWithoutProductCharacteristicNestedInput = {
    create?: XOR<ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput, ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput> | ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput[] | ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicTranslationCreateOrConnectWithoutProductCharacteristicInput | ProductCharacteristicTranslationCreateOrConnectWithoutProductCharacteristicInput[]
    upsert?: ProductCharacteristicTranslationUpsertWithWhereUniqueWithoutProductCharacteristicInput | ProductCharacteristicTranslationUpsertWithWhereUniqueWithoutProductCharacteristicInput[]
    createMany?: ProductCharacteristicTranslationCreateManyProductCharacteristicInputEnvelope
    set?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
    disconnect?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
    delete?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
    connect?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
    update?: ProductCharacteristicTranslationUpdateWithWhereUniqueWithoutProductCharacteristicInput | ProductCharacteristicTranslationUpdateWithWhereUniqueWithoutProductCharacteristicInput[]
    updateMany?: ProductCharacteristicTranslationUpdateManyWithWhereWithoutProductCharacteristicInput | ProductCharacteristicTranslationUpdateManyWithWhereWithoutProductCharacteristicInput[]
    deleteMany?: ProductCharacteristicTranslationScalarWhereInput | ProductCharacteristicTranslationScalarWhereInput[]
  }

  export type ProductCharacteristicTranslationUncheckedUpdateManyWithoutProductCharacteristicNestedInput = {
    create?: XOR<ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput, ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput> | ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput[] | ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput[]
    connectOrCreate?: ProductCharacteristicTranslationCreateOrConnectWithoutProductCharacteristicInput | ProductCharacteristicTranslationCreateOrConnectWithoutProductCharacteristicInput[]
    upsert?: ProductCharacteristicTranslationUpsertWithWhereUniqueWithoutProductCharacteristicInput | ProductCharacteristicTranslationUpsertWithWhereUniqueWithoutProductCharacteristicInput[]
    createMany?: ProductCharacteristicTranslationCreateManyProductCharacteristicInputEnvelope
    set?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
    disconnect?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
    delete?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
    connect?: ProductCharacteristicTranslationWhereUniqueInput | ProductCharacteristicTranslationWhereUniqueInput[]
    update?: ProductCharacteristicTranslationUpdateWithWhereUniqueWithoutProductCharacteristicInput | ProductCharacteristicTranslationUpdateWithWhereUniqueWithoutProductCharacteristicInput[]
    updateMany?: ProductCharacteristicTranslationUpdateManyWithWhereWithoutProductCharacteristicInput | ProductCharacteristicTranslationUpdateManyWithWhereWithoutProductCharacteristicInput[]
    deleteMany?: ProductCharacteristicTranslationScalarWhereInput | ProductCharacteristicTranslationScalarWhereInput[]
  }

  export type ProductCharacteristicCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<ProductCharacteristicCreateWithoutTranslationsInput, ProductCharacteristicUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutTranslationsInput
    connect?: ProductCharacteristicWhereUniqueInput
  }

  export type ProductCharacteristicUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<ProductCharacteristicCreateWithoutTranslationsInput, ProductCharacteristicUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: ProductCharacteristicCreateOrConnectWithoutTranslationsInput
    upsert?: ProductCharacteristicUpsertWithoutTranslationsInput
    connect?: ProductCharacteristicWhereUniqueInput
    update?: XOR<XOR<ProductCharacteristicUpdateToOneWithWhereWithoutTranslationsInput, ProductCharacteristicUpdateWithoutTranslationsInput>, ProductCharacteristicUncheckedUpdateWithoutTranslationsInput>
  }

  export type OrderCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput> | OrderCreateWithoutUserInput[] | OrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutUserInput | OrderCreateOrConnectWithoutUserInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutUserInput | OrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrderCreateManyUserInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutUserInput | OrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutUserInput | OrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReviewPhotoCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewPhotoCreateWithoutReviewInput, ReviewPhotoUncheckedCreateWithoutReviewInput> | ReviewPhotoCreateWithoutReviewInput[] | ReviewPhotoUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewPhotoCreateOrConnectWithoutReviewInput | ReviewPhotoCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewPhotoCreateManyReviewInputEnvelope
    connect?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
  }

  export type ReviewTranslationCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewTranslationCreateWithoutReviewInput, ReviewTranslationUncheckedCreateWithoutReviewInput> | ReviewTranslationCreateWithoutReviewInput[] | ReviewTranslationUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewTranslationCreateOrConnectWithoutReviewInput | ReviewTranslationCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewTranslationCreateManyReviewInputEnvelope
    connect?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
  }

  export type ReviewPhotoUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewPhotoCreateWithoutReviewInput, ReviewPhotoUncheckedCreateWithoutReviewInput> | ReviewPhotoCreateWithoutReviewInput[] | ReviewPhotoUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewPhotoCreateOrConnectWithoutReviewInput | ReviewPhotoCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewPhotoCreateManyReviewInputEnvelope
    connect?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
  }

  export type ReviewTranslationUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewTranslationCreateWithoutReviewInput, ReviewTranslationUncheckedCreateWithoutReviewInput> | ReviewTranslationCreateWithoutReviewInput[] | ReviewTranslationUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewTranslationCreateOrConnectWithoutReviewInput | ReviewTranslationCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewTranslationCreateManyReviewInputEnvelope
    connect?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
  }

  export type ReviewPhotoUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewPhotoCreateWithoutReviewInput, ReviewPhotoUncheckedCreateWithoutReviewInput> | ReviewPhotoCreateWithoutReviewInput[] | ReviewPhotoUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewPhotoCreateOrConnectWithoutReviewInput | ReviewPhotoCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewPhotoUpsertWithWhereUniqueWithoutReviewInput | ReviewPhotoUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewPhotoCreateManyReviewInputEnvelope
    set?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
    disconnect?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
    delete?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
    connect?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
    update?: ReviewPhotoUpdateWithWhereUniqueWithoutReviewInput | ReviewPhotoUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewPhotoUpdateManyWithWhereWithoutReviewInput | ReviewPhotoUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewPhotoScalarWhereInput | ReviewPhotoScalarWhereInput[]
  }

  export type ReviewTranslationUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewTranslationCreateWithoutReviewInput, ReviewTranslationUncheckedCreateWithoutReviewInput> | ReviewTranslationCreateWithoutReviewInput[] | ReviewTranslationUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewTranslationCreateOrConnectWithoutReviewInput | ReviewTranslationCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewTranslationUpsertWithWhereUniqueWithoutReviewInput | ReviewTranslationUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewTranslationCreateManyReviewInputEnvelope
    set?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
    disconnect?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
    delete?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
    connect?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
    update?: ReviewTranslationUpdateWithWhereUniqueWithoutReviewInput | ReviewTranslationUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewTranslationUpdateManyWithWhereWithoutReviewInput | ReviewTranslationUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewTranslationScalarWhereInput | ReviewTranslationScalarWhereInput[]
  }

  export type ReviewPhotoUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewPhotoCreateWithoutReviewInput, ReviewPhotoUncheckedCreateWithoutReviewInput> | ReviewPhotoCreateWithoutReviewInput[] | ReviewPhotoUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewPhotoCreateOrConnectWithoutReviewInput | ReviewPhotoCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewPhotoUpsertWithWhereUniqueWithoutReviewInput | ReviewPhotoUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewPhotoCreateManyReviewInputEnvelope
    set?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
    disconnect?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
    delete?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
    connect?: ReviewPhotoWhereUniqueInput | ReviewPhotoWhereUniqueInput[]
    update?: ReviewPhotoUpdateWithWhereUniqueWithoutReviewInput | ReviewPhotoUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewPhotoUpdateManyWithWhereWithoutReviewInput | ReviewPhotoUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewPhotoScalarWhereInput | ReviewPhotoScalarWhereInput[]
  }

  export type ReviewTranslationUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewTranslationCreateWithoutReviewInput, ReviewTranslationUncheckedCreateWithoutReviewInput> | ReviewTranslationCreateWithoutReviewInput[] | ReviewTranslationUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewTranslationCreateOrConnectWithoutReviewInput | ReviewTranslationCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewTranslationUpsertWithWhereUniqueWithoutReviewInput | ReviewTranslationUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewTranslationCreateManyReviewInputEnvelope
    set?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
    disconnect?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
    delete?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
    connect?: ReviewTranslationWhereUniqueInput | ReviewTranslationWhereUniqueInput[]
    update?: ReviewTranslationUpdateWithWhereUniqueWithoutReviewInput | ReviewTranslationUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewTranslationUpdateManyWithWhereWithoutReviewInput | ReviewTranslationUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewTranslationScalarWhereInput | ReviewTranslationScalarWhereInput[]
  }

  export type ReviewCreateNestedOneWithoutPhotoInput = {
    create?: XOR<ReviewCreateWithoutPhotoInput, ReviewUncheckedCreateWithoutPhotoInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutPhotoInput
    connect?: ReviewWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutPhotoNestedInput = {
    create?: XOR<ReviewCreateWithoutPhotoInput, ReviewUncheckedCreateWithoutPhotoInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutPhotoInput
    upsert?: ReviewUpsertWithoutPhotoInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutPhotoInput, ReviewUpdateWithoutPhotoInput>, ReviewUncheckedUpdateWithoutPhotoInput>
  }

  export type ReviewCreateNestedOneWithoutTranslationInput = {
    create?: XOR<ReviewCreateWithoutTranslationInput, ReviewUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutTranslationInput
    connect?: ReviewWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutTranslationNestedInput = {
    create?: XOR<ReviewCreateWithoutTranslationInput, ReviewUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutTranslationInput
    upsert?: ReviewUpsertWithoutTranslationInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutTranslationInput, ReviewUpdateWithoutTranslationInput>, ReviewUncheckedUpdateWithoutTranslationInput>
  }

  export type DeliveryInfoTranslationCreateNestedManyWithoutDeliveryInfoInput = {
    create?: XOR<DeliveryInfoTranslationCreateWithoutDeliveryInfoInput, DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput> | DeliveryInfoTranslationCreateWithoutDeliveryInfoInput[] | DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput[]
    connectOrCreate?: DeliveryInfoTranslationCreateOrConnectWithoutDeliveryInfoInput | DeliveryInfoTranslationCreateOrConnectWithoutDeliveryInfoInput[]
    createMany?: DeliveryInfoTranslationCreateManyDeliveryInfoInputEnvelope
    connect?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
  }

  export type DeliveryInfoTranslationUncheckedCreateNestedManyWithoutDeliveryInfoInput = {
    create?: XOR<DeliveryInfoTranslationCreateWithoutDeliveryInfoInput, DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput> | DeliveryInfoTranslationCreateWithoutDeliveryInfoInput[] | DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput[]
    connectOrCreate?: DeliveryInfoTranslationCreateOrConnectWithoutDeliveryInfoInput | DeliveryInfoTranslationCreateOrConnectWithoutDeliveryInfoInput[]
    createMany?: DeliveryInfoTranslationCreateManyDeliveryInfoInputEnvelope
    connect?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
  }

  export type DeliveryInfoTranslationUpdateManyWithoutDeliveryInfoNestedInput = {
    create?: XOR<DeliveryInfoTranslationCreateWithoutDeliveryInfoInput, DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput> | DeliveryInfoTranslationCreateWithoutDeliveryInfoInput[] | DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput[]
    connectOrCreate?: DeliveryInfoTranslationCreateOrConnectWithoutDeliveryInfoInput | DeliveryInfoTranslationCreateOrConnectWithoutDeliveryInfoInput[]
    upsert?: DeliveryInfoTranslationUpsertWithWhereUniqueWithoutDeliveryInfoInput | DeliveryInfoTranslationUpsertWithWhereUniqueWithoutDeliveryInfoInput[]
    createMany?: DeliveryInfoTranslationCreateManyDeliveryInfoInputEnvelope
    set?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
    disconnect?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
    delete?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
    connect?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
    update?: DeliveryInfoTranslationUpdateWithWhereUniqueWithoutDeliveryInfoInput | DeliveryInfoTranslationUpdateWithWhereUniqueWithoutDeliveryInfoInput[]
    updateMany?: DeliveryInfoTranslationUpdateManyWithWhereWithoutDeliveryInfoInput | DeliveryInfoTranslationUpdateManyWithWhereWithoutDeliveryInfoInput[]
    deleteMany?: DeliveryInfoTranslationScalarWhereInput | DeliveryInfoTranslationScalarWhereInput[]
  }

  export type DeliveryInfoTranslationUncheckedUpdateManyWithoutDeliveryInfoNestedInput = {
    create?: XOR<DeliveryInfoTranslationCreateWithoutDeliveryInfoInput, DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput> | DeliveryInfoTranslationCreateWithoutDeliveryInfoInput[] | DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput[]
    connectOrCreate?: DeliveryInfoTranslationCreateOrConnectWithoutDeliveryInfoInput | DeliveryInfoTranslationCreateOrConnectWithoutDeliveryInfoInput[]
    upsert?: DeliveryInfoTranslationUpsertWithWhereUniqueWithoutDeliveryInfoInput | DeliveryInfoTranslationUpsertWithWhereUniqueWithoutDeliveryInfoInput[]
    createMany?: DeliveryInfoTranslationCreateManyDeliveryInfoInputEnvelope
    set?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
    disconnect?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
    delete?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
    connect?: DeliveryInfoTranslationWhereUniqueInput | DeliveryInfoTranslationWhereUniqueInput[]
    update?: DeliveryInfoTranslationUpdateWithWhereUniqueWithoutDeliveryInfoInput | DeliveryInfoTranslationUpdateWithWhereUniqueWithoutDeliveryInfoInput[]
    updateMany?: DeliveryInfoTranslationUpdateManyWithWhereWithoutDeliveryInfoInput | DeliveryInfoTranslationUpdateManyWithWhereWithoutDeliveryInfoInput[]
    deleteMany?: DeliveryInfoTranslationScalarWhereInput | DeliveryInfoTranslationScalarWhereInput[]
  }

  export type DeliveryInfoCreateNestedOneWithoutTranslationInput = {
    create?: XOR<DeliveryInfoCreateWithoutTranslationInput, DeliveryInfoUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: DeliveryInfoCreateOrConnectWithoutTranslationInput
    connect?: DeliveryInfoWhereUniqueInput
  }

  export type DeliveryInfoUpdateOneRequiredWithoutTranslationNestedInput = {
    create?: XOR<DeliveryInfoCreateWithoutTranslationInput, DeliveryInfoUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: DeliveryInfoCreateOrConnectWithoutTranslationInput
    upsert?: DeliveryInfoUpsertWithoutTranslationInput
    connect?: DeliveryInfoWhereUniqueInput
    update?: XOR<XOR<DeliveryInfoUpdateToOneWithWhereWithoutTranslationInput, DeliveryInfoUpdateWithoutTranslationInput>, DeliveryInfoUncheckedUpdateWithoutTranslationInput>
  }

  export type PaymentMethodTranslationCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentMethodTranslationCreateWithoutPaymentMethodInput, PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput> | PaymentMethodTranslationCreateWithoutPaymentMethodInput[] | PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentMethodTranslationCreateOrConnectWithoutPaymentMethodInput | PaymentMethodTranslationCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentMethodTranslationCreateManyPaymentMethodInputEnvelope
    connect?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
  }

  export type PaymentMethodTranslationUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentMethodTranslationCreateWithoutPaymentMethodInput, PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput> | PaymentMethodTranslationCreateWithoutPaymentMethodInput[] | PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentMethodTranslationCreateOrConnectWithoutPaymentMethodInput | PaymentMethodTranslationCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentMethodTranslationCreateManyPaymentMethodInputEnvelope
    connect?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
  }

  export type PaymentMethodTranslationUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentMethodTranslationCreateWithoutPaymentMethodInput, PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput> | PaymentMethodTranslationCreateWithoutPaymentMethodInput[] | PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentMethodTranslationCreateOrConnectWithoutPaymentMethodInput | PaymentMethodTranslationCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentMethodTranslationUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentMethodTranslationUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentMethodTranslationCreateManyPaymentMethodInputEnvelope
    set?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
    disconnect?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
    delete?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
    connect?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
    update?: PaymentMethodTranslationUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentMethodTranslationUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentMethodTranslationUpdateManyWithWhereWithoutPaymentMethodInput | PaymentMethodTranslationUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentMethodTranslationScalarWhereInput | PaymentMethodTranslationScalarWhereInput[]
  }

  export type PaymentMethodTranslationUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentMethodTranslationCreateWithoutPaymentMethodInput, PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput> | PaymentMethodTranslationCreateWithoutPaymentMethodInput[] | PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentMethodTranslationCreateOrConnectWithoutPaymentMethodInput | PaymentMethodTranslationCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentMethodTranslationUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentMethodTranslationUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentMethodTranslationCreateManyPaymentMethodInputEnvelope
    set?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
    disconnect?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
    delete?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
    connect?: PaymentMethodTranslationWhereUniqueInput | PaymentMethodTranslationWhereUniqueInput[]
    update?: PaymentMethodTranslationUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentMethodTranslationUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentMethodTranslationUpdateManyWithWhereWithoutPaymentMethodInput | PaymentMethodTranslationUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentMethodTranslationScalarWhereInput | PaymentMethodTranslationScalarWhereInput[]
  }

  export type PaymentMethodCreateNestedOneWithoutTranslationInput = {
    create?: XOR<PaymentMethodCreateWithoutTranslationInput, PaymentMethodUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutTranslationInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type PaymentMethodUpdateOneRequiredWithoutTranslationNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutTranslationInput, PaymentMethodUncheckedCreateWithoutTranslationInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutTranslationInput
    upsert?: PaymentMethodUpsertWithoutTranslationInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutTranslationInput, PaymentMethodUpdateWithoutTranslationInput>, PaymentMethodUncheckedUpdateWithoutTranslationInput>
  }

  export type FAQTranslationCreateNestedManyWithoutFaqInput = {
    create?: XOR<FAQTranslationCreateWithoutFaqInput, FAQTranslationUncheckedCreateWithoutFaqInput> | FAQTranslationCreateWithoutFaqInput[] | FAQTranslationUncheckedCreateWithoutFaqInput[]
    connectOrCreate?: FAQTranslationCreateOrConnectWithoutFaqInput | FAQTranslationCreateOrConnectWithoutFaqInput[]
    createMany?: FAQTranslationCreateManyFaqInputEnvelope
    connect?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
  }

  export type FAQTranslationUncheckedCreateNestedManyWithoutFaqInput = {
    create?: XOR<FAQTranslationCreateWithoutFaqInput, FAQTranslationUncheckedCreateWithoutFaqInput> | FAQTranslationCreateWithoutFaqInput[] | FAQTranslationUncheckedCreateWithoutFaqInput[]
    connectOrCreate?: FAQTranslationCreateOrConnectWithoutFaqInput | FAQTranslationCreateOrConnectWithoutFaqInput[]
    createMany?: FAQTranslationCreateManyFaqInputEnvelope
    connect?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
  }

  export type FAQTranslationUpdateManyWithoutFaqNestedInput = {
    create?: XOR<FAQTranslationCreateWithoutFaqInput, FAQTranslationUncheckedCreateWithoutFaqInput> | FAQTranslationCreateWithoutFaqInput[] | FAQTranslationUncheckedCreateWithoutFaqInput[]
    connectOrCreate?: FAQTranslationCreateOrConnectWithoutFaqInput | FAQTranslationCreateOrConnectWithoutFaqInput[]
    upsert?: FAQTranslationUpsertWithWhereUniqueWithoutFaqInput | FAQTranslationUpsertWithWhereUniqueWithoutFaqInput[]
    createMany?: FAQTranslationCreateManyFaqInputEnvelope
    set?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
    disconnect?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
    delete?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
    connect?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
    update?: FAQTranslationUpdateWithWhereUniqueWithoutFaqInput | FAQTranslationUpdateWithWhereUniqueWithoutFaqInput[]
    updateMany?: FAQTranslationUpdateManyWithWhereWithoutFaqInput | FAQTranslationUpdateManyWithWhereWithoutFaqInput[]
    deleteMany?: FAQTranslationScalarWhereInput | FAQTranslationScalarWhereInput[]
  }

  export type FAQTranslationUncheckedUpdateManyWithoutFaqNestedInput = {
    create?: XOR<FAQTranslationCreateWithoutFaqInput, FAQTranslationUncheckedCreateWithoutFaqInput> | FAQTranslationCreateWithoutFaqInput[] | FAQTranslationUncheckedCreateWithoutFaqInput[]
    connectOrCreate?: FAQTranslationCreateOrConnectWithoutFaqInput | FAQTranslationCreateOrConnectWithoutFaqInput[]
    upsert?: FAQTranslationUpsertWithWhereUniqueWithoutFaqInput | FAQTranslationUpsertWithWhereUniqueWithoutFaqInput[]
    createMany?: FAQTranslationCreateManyFaqInputEnvelope
    set?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
    disconnect?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
    delete?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
    connect?: FAQTranslationWhereUniqueInput | FAQTranslationWhereUniqueInput[]
    update?: FAQTranslationUpdateWithWhereUniqueWithoutFaqInput | FAQTranslationUpdateWithWhereUniqueWithoutFaqInput[]
    updateMany?: FAQTranslationUpdateManyWithWhereWithoutFaqInput | FAQTranslationUpdateManyWithWhereWithoutFaqInput[]
    deleteMany?: FAQTranslationScalarWhereInput | FAQTranslationScalarWhereInput[]
  }

  export type FAQCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<FAQCreateWithoutTranslationsInput, FAQUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: FAQCreateOrConnectWithoutTranslationsInput
    connect?: FAQWhereUniqueInput
  }

  export type FAQUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<FAQCreateWithoutTranslationsInput, FAQUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: FAQCreateOrConnectWithoutTranslationsInput
    upsert?: FAQUpsertWithoutTranslationsInput
    connect?: FAQWhereUniqueInput
    update?: XOR<XOR<FAQUpdateToOneWithWhereWithoutTranslationsInput, FAQUpdateWithoutTranslationsInput>, FAQUncheckedUpdateWithoutTranslationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTypeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeCategory | EnumTypeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TypeCategory[] | ListEnumTypeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeCategory[] | ListEnumTypeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeCategoryFilter<$PrismaModel> | $Enums.TypeCategory
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTypeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeCategory | EnumTypeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TypeCategory[] | ListEnumTypeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeCategory[] | ListEnumTypeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TypeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeCategoryFilter<$PrismaModel>
    _max?: NestedEnumTypeCategoryFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductType[] | ListEnumProductTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumOrderTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderTypes | EnumOrderTypesFieldRefInput<$PrismaModel>
    in?: $Enums.OrderTypes[] | ListEnumOrderTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderTypes[] | ListEnumOrderTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypesFilter<$PrismaModel> | $Enums.OrderTypes
  }

  export type NestedEnumOrderTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderTypes | EnumOrderTypesFieldRefInput<$PrismaModel>
    in?: $Enums.OrderTypes[] | ListEnumOrderTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderTypes[] | ListEnumOrderTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypesWithAggregatesFilter<$PrismaModel> | $Enums.OrderTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypesFilter<$PrismaModel>
    _max?: NestedEnumOrderTypesFilter<$PrismaModel>
  }

  export type HeroBillboardsTranslationCreateWithoutHeroBillboardInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string
    langCode: string
    subtitle?: string
  }

  export type HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string
    langCode: string
    subtitle?: string
  }

  export type HeroBillboardsTranslationCreateOrConnectWithoutHeroBillboardInput = {
    where: HeroBillboardsTranslationWhereUniqueInput
    create: XOR<HeroBillboardsTranslationCreateWithoutHeroBillboardInput, HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput>
  }

  export type HeroBillboardsTranslationCreateManyHeroBillboardInputEnvelope = {
    data: HeroBillboardsTranslationCreateManyHeroBillboardInput | HeroBillboardsTranslationCreateManyHeroBillboardInput[]
    skipDuplicates?: boolean
  }

  export type HeroBillboardsTranslationUpsertWithWhereUniqueWithoutHeroBillboardInput = {
    where: HeroBillboardsTranslationWhereUniqueInput
    update: XOR<HeroBillboardsTranslationUpdateWithoutHeroBillboardInput, HeroBillboardsTranslationUncheckedUpdateWithoutHeroBillboardInput>
    create: XOR<HeroBillboardsTranslationCreateWithoutHeroBillboardInput, HeroBillboardsTranslationUncheckedCreateWithoutHeroBillboardInput>
  }

  export type HeroBillboardsTranslationUpdateWithWhereUniqueWithoutHeroBillboardInput = {
    where: HeroBillboardsTranslationWhereUniqueInput
    data: XOR<HeroBillboardsTranslationUpdateWithoutHeroBillboardInput, HeroBillboardsTranslationUncheckedUpdateWithoutHeroBillboardInput>
  }

  export type HeroBillboardsTranslationUpdateManyWithWhereWithoutHeroBillboardInput = {
    where: HeroBillboardsTranslationScalarWhereInput
    data: XOR<HeroBillboardsTranslationUpdateManyMutationInput, HeroBillboardsTranslationUncheckedUpdateManyWithoutHeroBillboardInput>
  }

  export type HeroBillboardsTranslationScalarWhereInput = {
    AND?: HeroBillboardsTranslationScalarWhereInput | HeroBillboardsTranslationScalarWhereInput[]
    OR?: HeroBillboardsTranslationScalarWhereInput[]
    NOT?: HeroBillboardsTranslationScalarWhereInput | HeroBillboardsTranslationScalarWhereInput[]
    id?: StringFilter<"HeroBillboardsTranslation"> | string
    createdAt?: DateTimeFilter<"HeroBillboardsTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBillboardsTranslation"> | Date | string
    title?: StringFilter<"HeroBillboardsTranslation"> | string
    langCode?: StringFilter<"HeroBillboardsTranslation"> | string
    subtitle?: StringFilter<"HeroBillboardsTranslation"> | string
    heroBillboardId?: StringFilter<"HeroBillboardsTranslation"> | string
  }

  export type HeroBillboardsCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image: string
    title?: string
    subtitle?: string
    url: string
  }

  export type HeroBillboardsUncheckedCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    image: string
    title?: string
    subtitle?: string
    url: string
  }

  export type HeroBillboardsCreateOrConnectWithoutTranslationsInput = {
    where: HeroBillboardsWhereUniqueInput
    create: XOR<HeroBillboardsCreateWithoutTranslationsInput, HeroBillboardsUncheckedCreateWithoutTranslationsInput>
  }

  export type HeroBillboardsUpsertWithoutTranslationsInput = {
    update: XOR<HeroBillboardsUpdateWithoutTranslationsInput, HeroBillboardsUncheckedUpdateWithoutTranslationsInput>
    create: XOR<HeroBillboardsCreateWithoutTranslationsInput, HeroBillboardsUncheckedCreateWithoutTranslationsInput>
    where?: HeroBillboardsWhereInput
  }

  export type HeroBillboardsUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: HeroBillboardsWhereInput
    data: XOR<HeroBillboardsUpdateWithoutTranslationsInput, HeroBillboardsUncheckedUpdateWithoutTranslationsInput>
  }

  export type HeroBillboardsUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type HeroBillboardsUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateWithoutBillboardInput = {
    id?: string
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryCreateNestedManyWithoutCategoryInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutBillboardInput = {
    id?: string
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutBillboardInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBillboardInput, CategoryUncheckedCreateWithoutBillboardInput>
  }

  export type CategoryCreateManyBillboardInputEnvelope = {
    data: CategoryCreateManyBillboardInput | CategoryCreateManyBillboardInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutBillboardInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutBillboardInput, CategoryUncheckedUpdateWithoutBillboardInput>
    create: XOR<CategoryCreateWithoutBillboardInput, CategoryUncheckedCreateWithoutBillboardInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutBillboardInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutBillboardInput, CategoryUncheckedUpdateWithoutBillboardInput>
  }

  export type CategoryUpdateManyWithWhereWithoutBillboardInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutBillboardInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    billboardId?: StringNullableFilter<"Category"> | string | null
    name?: StringFilter<"Category"> | string
    type?: EnumTypeCategoryFilter<"Category"> | $Enums.TypeCategory
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parentId?: StringNullableFilter<"Category"> | string | null
    maxPrice?: DecimalNullableFilter<"Category"> | Decimal | DecimalJsLike | number | string | null
  }

  export type BillboardCreateWithoutCategoriesInput = {
    id?: string
    label: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillboardUncheckedCreateWithoutCategoriesInput = {
    id?: string
    label: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BillboardCreateOrConnectWithoutCategoriesInput = {
    where: BillboardWhereUniqueInput
    create: XOR<BillboardCreateWithoutCategoriesInput, BillboardUncheckedCreateWithoutCategoriesInput>
  }

  export type ProductCategoryCreateWithoutCategoryInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutCategoriesInput
  }

  export type ProductCategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateOrConnectWithoutCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCategoryCreateManyCategoryInputEnvelope = {
    data: ProductCategoryCreateManyCategoryInput | ProductCategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    billboard?: BillboardCreateNestedOneWithoutCategoriesInput
    products?: ProductCategoryCreateNestedManyWithoutCategoryInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    billboardId?: string | null
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id?: string
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    billboard?: BillboardCreateNestedOneWithoutCategoriesInput
    products?: ProductCategoryCreateNestedManyWithoutCategoryInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id?: string
    billboardId?: string | null
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryUncheckedCreateNestedManyWithoutCategoryInput
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type BillboardUpsertWithoutCategoriesInput = {
    update: XOR<BillboardUpdateWithoutCategoriesInput, BillboardUncheckedUpdateWithoutCategoriesInput>
    create: XOR<BillboardCreateWithoutCategoriesInput, BillboardUncheckedCreateWithoutCategoriesInput>
    where?: BillboardWhereInput
  }

  export type BillboardUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: BillboardWhereInput
    data: XOR<BillboardUpdateWithoutCategoriesInput, BillboardUncheckedUpdateWithoutCategoriesInput>
  }

  export type BillboardUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BillboardUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutCategoryInput, ProductCategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCategoryCreateWithoutCategoryInput, ProductCategoryUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutCategoryInput, ProductCategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductCategoryScalarWhereInput = {
    AND?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    OR?: ProductCategoryScalarWhereInput[]
    NOT?: ProductCategoryScalarWhereInput | ProductCategoryScalarWhereInput[]
    id?: StringFilter<"ProductCategory"> | string
    productId?: StringFilter<"ProductCategory"> | string
    categoryId?: StringFilter<"ProductCategory"> | string
    createdAt?: DateTimeFilter<"ProductCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCategory"> | Date | string
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billboard?: BillboardUpdateOneWithoutCategoriesNestedInput
    products?: ProductCategoryUpdateManyWithoutCategoryNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    billboardId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type ProductCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    images?: ImageCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoriesInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    images?: ImageUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoriesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    id?: string
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    billboard?: BillboardCreateNestedOneWithoutCategoriesInput
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: string
    billboardId?: string | null
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    maxPrice?: Decimal | DecimalJsLike | number | string | null
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutCategoriesInput = {
    update: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
    create: XOR<ProductCreateWithoutCategoriesInput, ProductUncheckedCreateWithoutCategoriesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCategoriesInput, ProductUncheckedUpdateWithoutCategoriesInput>
  }

  export type ProductUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    images?: ImageUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    images?: ImageUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billboard?: BillboardUpdateOneWithoutCategoriesNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    billboardId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ProductCategoryCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductCategoryUncheckedCreateWithoutProductInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCategoryCreateOrConnectWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryCreateManyProductInputEnvelope = {
    data: ProductCategoryCreateManyProductInput | ProductCategoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ImageCreateWithoutProductInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageUncheckedCreateWithoutProductInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageCreateOrConnectWithoutProductInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutProductInput, ImageUncheckedCreateWithoutProductInput>
  }

  export type ImageCreateManyProductInputEnvelope = {
    data: ImageCreateManyProductInput | ImageCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    price?: string
    quantity?: number
    order: OrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: string
    price?: string
    quantity?: number
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductCharacteristicCreateWithoutProductInput = {
    id?: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    characteristic: CharacteristicCreateNestedOneWithoutProductCharacteristicsInput
    translations?: ProductCharacteristicTranslationCreateNestedManyWithoutProductCharacteristicInput
  }

  export type ProductCharacteristicUncheckedCreateWithoutProductInput = {
    id?: string
    characteristicId: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    translations?: ProductCharacteristicTranslationUncheckedCreateNestedManyWithoutProductCharacteristicInput
  }

  export type ProductCharacteristicCreateOrConnectWithoutProductInput = {
    where: ProductCharacteristicWhereUniqueInput
    create: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput>
  }

  export type ProductCharacteristicCreateManyProductInputEnvelope = {
    data: ProductCharacteristicCreateManyProductInput | ProductCharacteristicCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductTranslationCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    title: string
    description: string
  }

  export type ProductTranslationUncheckedCreateWithoutProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    title: string
    description: string
  }

  export type ProductTranslationCreateOrConnectWithoutProductInput = {
    where: ProductTranslationWhereUniqueInput
    create: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput>
  }

  export type ProductTranslationCreateManyProductInputEnvelope = {
    data: ProductTranslationCreateManyProductInput | ProductTranslationCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductCategoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    update: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCategoryCreateWithoutProductInput, ProductCategoryUncheckedCreateWithoutProductInput>
  }

  export type ProductCategoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductCategoryWhereUniqueInput
    data: XOR<ProductCategoryUpdateWithoutProductInput, ProductCategoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductCategoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductCategoryScalarWhereInput
    data: XOR<ProductCategoryUpdateManyMutationInput, ProductCategoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutProductInput, ImageUncheckedUpdateWithoutProductInput>
    create: XOR<ImageCreateWithoutProductInput, ImageUncheckedCreateWithoutProductInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutProductInput, ImageUncheckedUpdateWithoutProductInput>
  }

  export type ImageUpdateManyWithWhereWithoutProductInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutProductInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    id?: StringFilter<"Image"> | string
    productId?: StringFilter<"Image"> | string
    url?: StringFilter<"Image"> | string
    createdAt?: DateTimeFilter<"Image"> | Date | string
    updatedAt?: DateTimeFilter<"Image"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    orderId?: StringFilter<"OrderItem"> | string
    price?: StringFilter<"OrderItem"> | string
    productId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
  }

  export type ProductCharacteristicUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductCharacteristicWhereUniqueInput
    update: XOR<ProductCharacteristicUpdateWithoutProductInput, ProductCharacteristicUncheckedUpdateWithoutProductInput>
    create: XOR<ProductCharacteristicCreateWithoutProductInput, ProductCharacteristicUncheckedCreateWithoutProductInput>
  }

  export type ProductCharacteristicUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductCharacteristicWhereUniqueInput
    data: XOR<ProductCharacteristicUpdateWithoutProductInput, ProductCharacteristicUncheckedUpdateWithoutProductInput>
  }

  export type ProductCharacteristicUpdateManyWithWhereWithoutProductInput = {
    where: ProductCharacteristicScalarWhereInput
    data: XOR<ProductCharacteristicUpdateManyMutationInput, ProductCharacteristicUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCharacteristicScalarWhereInput = {
    AND?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
    OR?: ProductCharacteristicScalarWhereInput[]
    NOT?: ProductCharacteristicScalarWhereInput | ProductCharacteristicScalarWhereInput[]
    id?: StringFilter<"ProductCharacteristic"> | string
    productId?: StringFilter<"ProductCharacteristic"> | string
    characteristicId?: StringFilter<"ProductCharacteristic"> | string
    name?: StringFilter<"ProductCharacteristic"> | string
    createAt?: DateTimeFilter<"ProductCharacteristic"> | Date | string
    updateAt?: DateTimeFilter<"ProductCharacteristic"> | Date | string
  }

  export type ProductTranslationUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductTranslationWhereUniqueInput
    update: XOR<ProductTranslationUpdateWithoutProductInput, ProductTranslationUncheckedUpdateWithoutProductInput>
    create: XOR<ProductTranslationCreateWithoutProductInput, ProductTranslationUncheckedCreateWithoutProductInput>
  }

  export type ProductTranslationUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductTranslationWhereUniqueInput
    data: XOR<ProductTranslationUpdateWithoutProductInput, ProductTranslationUncheckedUpdateWithoutProductInput>
  }

  export type ProductTranslationUpdateManyWithWhereWithoutProductInput = {
    where: ProductTranslationScalarWhereInput
    data: XOR<ProductTranslationUpdateManyMutationInput, ProductTranslationUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductTranslationScalarWhereInput = {
    AND?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
    OR?: ProductTranslationScalarWhereInput[]
    NOT?: ProductTranslationScalarWhereInput | ProductTranslationScalarWhereInput[]
    id?: StringFilter<"ProductTranslation"> | string
    createdAt?: DateTimeFilter<"ProductTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductTranslation"> | Date | string
    languageCode?: StringFilter<"ProductTranslation"> | string
    title?: StringFilter<"ProductTranslation"> | string
    description?: StringFilter<"ProductTranslation"> | string
    productId?: StringFilter<"ProductTranslation"> | string
  }

  export type ProductCreateWithoutTranslationsInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ImageCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTranslationsInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ImageUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTranslationsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTranslationsInput, ProductUncheckedCreateWithoutTranslationsInput>
  }

  export type ProductUpsertWithoutTranslationsInput = {
    update: XOR<ProductUpdateWithoutTranslationsInput, ProductUncheckedUpdateWithoutTranslationsInput>
    create: XOR<ProductCreateWithoutTranslationsInput, ProductUncheckedCreateWithoutTranslationsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTranslationsInput, ProductUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ImageUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ImageUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateWithoutImagesInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutImagesInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutImagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
  }

  export type ProductUpsertWithoutImagesInput = {
    update: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutImagesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type ProductUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    price?: string
    quantity?: number
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    price?: string
    productId: string
    quantity?: number
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string
    lastName?: string
    email?: string
    phoneNumber?: string
    address?: string
    avatar?: string
    role?: string
    password?: string
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    firstName?: string
    lastName?: string
    email?: string
    phoneNumber?: string
    address?: string
    avatar?: string
    role?: string
    password?: string
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string
    isPaid?: boolean
    firstName?: string
    lastName?: string
    phone?: string
    email?: string
    orderNumber?: string
    message?: string
    messagngerType?: string
    messenger?: string
    totalPrice?: number
    orderStatus?: $Enums.OrderTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutOrdersInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    isPaid?: boolean
    firstName?: string
    lastName?: string
    phone?: string
    email?: string
    orderNumber?: string
    message?: string
    messagngerType?: string
    messenger?: string
    totalPrice?: number
    orderStatus?: $Enums.OrderTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ImageCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ImageUncheckedCreateNestedManyWithoutProductInput
    productCharacteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderStatus?: EnumOrderTypesFieldUpdateOperationsInput | $Enums.OrderTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderStatus?: EnumOrderTypesFieldUpdateOperationsInput | $Enums.OrderTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ImageUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ImageUncheckedUpdateManyWithoutProductNestedInput
    productCharacteristics?: ProductCharacteristicUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCharacteristicCreateWithoutCharacteristicInput = {
    id?: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    product: ProductCreateNestedOneWithoutProductCharacteristicsInput
    translations?: ProductCharacteristicTranslationCreateNestedManyWithoutProductCharacteristicInput
  }

  export type ProductCharacteristicUncheckedCreateWithoutCharacteristicInput = {
    id?: string
    productId: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    translations?: ProductCharacteristicTranslationUncheckedCreateNestedManyWithoutProductCharacteristicInput
  }

  export type ProductCharacteristicCreateOrConnectWithoutCharacteristicInput = {
    where: ProductCharacteristicWhereUniqueInput
    create: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput>
  }

  export type ProductCharacteristicCreateManyCharacteristicInputEnvelope = {
    data: ProductCharacteristicCreateManyCharacteristicInput | ProductCharacteristicCreateManyCharacteristicInput[]
    skipDuplicates?: boolean
  }

  export type CharacteristicTranslationCreateWithoutCharacteristicInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    languageCode: string
    name: string
  }

  export type CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    languageCode: string
    name: string
  }

  export type CharacteristicTranslationCreateOrConnectWithoutCharacteristicInput = {
    where: CharacteristicTranslationWhereUniqueInput
    create: XOR<CharacteristicTranslationCreateWithoutCharacteristicInput, CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput>
  }

  export type CharacteristicTranslationCreateManyCharacteristicInputEnvelope = {
    data: CharacteristicTranslationCreateManyCharacteristicInput | CharacteristicTranslationCreateManyCharacteristicInput[]
    skipDuplicates?: boolean
  }

  export type ProductCharacteristicUpsertWithWhereUniqueWithoutCharacteristicInput = {
    where: ProductCharacteristicWhereUniqueInput
    update: XOR<ProductCharacteristicUpdateWithoutCharacteristicInput, ProductCharacteristicUncheckedUpdateWithoutCharacteristicInput>
    create: XOR<ProductCharacteristicCreateWithoutCharacteristicInput, ProductCharacteristicUncheckedCreateWithoutCharacteristicInput>
  }

  export type ProductCharacteristicUpdateWithWhereUniqueWithoutCharacteristicInput = {
    where: ProductCharacteristicWhereUniqueInput
    data: XOR<ProductCharacteristicUpdateWithoutCharacteristicInput, ProductCharacteristicUncheckedUpdateWithoutCharacteristicInput>
  }

  export type ProductCharacteristicUpdateManyWithWhereWithoutCharacteristicInput = {
    where: ProductCharacteristicScalarWhereInput
    data: XOR<ProductCharacteristicUpdateManyMutationInput, ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicInput>
  }

  export type CharacteristicTranslationUpsertWithWhereUniqueWithoutCharacteristicInput = {
    where: CharacteristicTranslationWhereUniqueInput
    update: XOR<CharacteristicTranslationUpdateWithoutCharacteristicInput, CharacteristicTranslationUncheckedUpdateWithoutCharacteristicInput>
    create: XOR<CharacteristicTranslationCreateWithoutCharacteristicInput, CharacteristicTranslationUncheckedCreateWithoutCharacteristicInput>
  }

  export type CharacteristicTranslationUpdateWithWhereUniqueWithoutCharacteristicInput = {
    where: CharacteristicTranslationWhereUniqueInput
    data: XOR<CharacteristicTranslationUpdateWithoutCharacteristicInput, CharacteristicTranslationUncheckedUpdateWithoutCharacteristicInput>
  }

  export type CharacteristicTranslationUpdateManyWithWhereWithoutCharacteristicInput = {
    where: CharacteristicTranslationScalarWhereInput
    data: XOR<CharacteristicTranslationUpdateManyMutationInput, CharacteristicTranslationUncheckedUpdateManyWithoutCharacteristicInput>
  }

  export type CharacteristicTranslationScalarWhereInput = {
    AND?: CharacteristicTranslationScalarWhereInput | CharacteristicTranslationScalarWhereInput[]
    OR?: CharacteristicTranslationScalarWhereInput[]
    NOT?: CharacteristicTranslationScalarWhereInput | CharacteristicTranslationScalarWhereInput[]
    id?: StringFilter<"CharacteristicTranslation"> | string
    createAt?: DateTimeFilter<"CharacteristicTranslation"> | Date | string
    updateAt?: DateTimeFilter<"CharacteristicTranslation"> | Date | string
    languageCode?: StringFilter<"CharacteristicTranslation"> | string
    name?: StringFilter<"CharacteristicTranslation"> | string
    characteristicId?: StringFilter<"CharacteristicTranslation"> | string
  }

  export type CharacteristicCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string | null
    productCharacteristics?: ProductCharacteristicCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicUncheckedCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string | null
    productCharacteristics?: ProductCharacteristicUncheckedCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicCreateOrConnectWithoutTranslationsInput = {
    where: CharacteristicWhereUniqueInput
    create: XOR<CharacteristicCreateWithoutTranslationsInput, CharacteristicUncheckedCreateWithoutTranslationsInput>
  }

  export type CharacteristicUpsertWithoutTranslationsInput = {
    update: XOR<CharacteristicUpdateWithoutTranslationsInput, CharacteristicUncheckedUpdateWithoutTranslationsInput>
    create: XOR<CharacteristicCreateWithoutTranslationsInput, CharacteristicUncheckedCreateWithoutTranslationsInput>
    where?: CharacteristicWhereInput
  }

  export type CharacteristicUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: CharacteristicWhereInput
    data: XOR<CharacteristicUpdateWithoutTranslationsInput, CharacteristicUncheckedUpdateWithoutTranslationsInput>
  }

  export type CharacteristicUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productCharacteristics?: ProductCharacteristicUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productCharacteristics?: ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicNestedInput
  }

  export type ProductCreateWithoutProductCharacteristicsInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryCreateNestedManyWithoutProductInput
    images?: ImageCreateNestedManyWithoutProductInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    translations?: ProductTranslationCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutProductCharacteristicsInput = {
    id?: string
    title: string
    description: string
    quantity?: number
    price?: number
    type?: $Enums.ProductType
    isArchived?: boolean
    isFeatured?: boolean
    backgroundColor?: string
    textColor?: string
    position?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    article: string
    categories?: ProductCategoryUncheckedCreateNestedManyWithoutProductInput
    images?: ImageUncheckedCreateNestedManyWithoutProductInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    translations?: ProductTranslationUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutProductCharacteristicsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutProductCharacteristicsInput, ProductUncheckedCreateWithoutProductCharacteristicsInput>
  }

  export type CharacteristicCreateWithoutProductCharacteristicsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string | null
    translations?: CharacteristicTranslationCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicUncheckedCreateWithoutProductCharacteristicsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name?: string
    description?: string | null
    translations?: CharacteristicTranslationUncheckedCreateNestedManyWithoutCharacteristicInput
  }

  export type CharacteristicCreateOrConnectWithoutProductCharacteristicsInput = {
    where: CharacteristicWhereUniqueInput
    create: XOR<CharacteristicCreateWithoutProductCharacteristicsInput, CharacteristicUncheckedCreateWithoutProductCharacteristicsInput>
  }

  export type ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    description: string
  }

  export type ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    description: string
  }

  export type ProductCharacteristicTranslationCreateOrConnectWithoutProductCharacteristicInput = {
    where: ProductCharacteristicTranslationWhereUniqueInput
    create: XOR<ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput, ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput>
  }

  export type ProductCharacteristicTranslationCreateManyProductCharacteristicInputEnvelope = {
    data: ProductCharacteristicTranslationCreateManyProductCharacteristicInput | ProductCharacteristicTranslationCreateManyProductCharacteristicInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutProductCharacteristicsInput = {
    update: XOR<ProductUpdateWithoutProductCharacteristicsInput, ProductUncheckedUpdateWithoutProductCharacteristicsInput>
    create: XOR<ProductCreateWithoutProductCharacteristicsInput, ProductUncheckedCreateWithoutProductCharacteristicsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutProductCharacteristicsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutProductCharacteristicsInput, ProductUncheckedUpdateWithoutProductCharacteristicsInput>
  }

  export type ProductUpdateWithoutProductCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUpdateManyWithoutProductNestedInput
    images?: ImageUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutProductCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    isArchived?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    backgroundColor?: StringFieldUpdateOperationsInput | string
    textColor?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: StringFieldUpdateOperationsInput | string
    categories?: ProductCategoryUncheckedUpdateManyWithoutProductNestedInput
    images?: ImageUncheckedUpdateManyWithoutProductNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    translations?: ProductTranslationUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CharacteristicUpsertWithoutProductCharacteristicsInput = {
    update: XOR<CharacteristicUpdateWithoutProductCharacteristicsInput, CharacteristicUncheckedUpdateWithoutProductCharacteristicsInput>
    create: XOR<CharacteristicCreateWithoutProductCharacteristicsInput, CharacteristicUncheckedCreateWithoutProductCharacteristicsInput>
    where?: CharacteristicWhereInput
  }

  export type CharacteristicUpdateToOneWithWhereWithoutProductCharacteristicsInput = {
    where?: CharacteristicWhereInput
    data: XOR<CharacteristicUpdateWithoutProductCharacteristicsInput, CharacteristicUncheckedUpdateWithoutProductCharacteristicsInput>
  }

  export type CharacteristicUpdateWithoutProductCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: CharacteristicTranslationUpdateManyWithoutCharacteristicNestedInput
  }

  export type CharacteristicUncheckedUpdateWithoutProductCharacteristicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    translations?: CharacteristicTranslationUncheckedUpdateManyWithoutCharacteristicNestedInput
  }

  export type ProductCharacteristicTranslationUpsertWithWhereUniqueWithoutProductCharacteristicInput = {
    where: ProductCharacteristicTranslationWhereUniqueInput
    update: XOR<ProductCharacteristicTranslationUpdateWithoutProductCharacteristicInput, ProductCharacteristicTranslationUncheckedUpdateWithoutProductCharacteristicInput>
    create: XOR<ProductCharacteristicTranslationCreateWithoutProductCharacteristicInput, ProductCharacteristicTranslationUncheckedCreateWithoutProductCharacteristicInput>
  }

  export type ProductCharacteristicTranslationUpdateWithWhereUniqueWithoutProductCharacteristicInput = {
    where: ProductCharacteristicTranslationWhereUniqueInput
    data: XOR<ProductCharacteristicTranslationUpdateWithoutProductCharacteristicInput, ProductCharacteristicTranslationUncheckedUpdateWithoutProductCharacteristicInput>
  }

  export type ProductCharacteristicTranslationUpdateManyWithWhereWithoutProductCharacteristicInput = {
    where: ProductCharacteristicTranslationScalarWhereInput
    data: XOR<ProductCharacteristicTranslationUpdateManyMutationInput, ProductCharacteristicTranslationUncheckedUpdateManyWithoutProductCharacteristicInput>
  }

  export type ProductCharacteristicTranslationScalarWhereInput = {
    AND?: ProductCharacteristicTranslationScalarWhereInput | ProductCharacteristicTranslationScalarWhereInput[]
    OR?: ProductCharacteristicTranslationScalarWhereInput[]
    NOT?: ProductCharacteristicTranslationScalarWhereInput | ProductCharacteristicTranslationScalarWhereInput[]
    id?: StringFilter<"ProductCharacteristicTranslation"> | string
    createdAt?: DateTimeFilter<"ProductCharacteristicTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ProductCharacteristicTranslation"> | Date | string
    languageCode?: StringFilter<"ProductCharacteristicTranslation"> | string
    description?: StringFilter<"ProductCharacteristicTranslation"> | string
    productCharacteristicId?: StringFilter<"ProductCharacteristicTranslation"> | string
  }

  export type ProductCharacteristicCreateWithoutTranslationsInput = {
    id?: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
    product: ProductCreateNestedOneWithoutProductCharacteristicsInput
    characteristic: CharacteristicCreateNestedOneWithoutProductCharacteristicsInput
  }

  export type ProductCharacteristicUncheckedCreateWithoutTranslationsInput = {
    id?: string
    productId: string
    characteristicId: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProductCharacteristicCreateOrConnectWithoutTranslationsInput = {
    where: ProductCharacteristicWhereUniqueInput
    create: XOR<ProductCharacteristicCreateWithoutTranslationsInput, ProductCharacteristicUncheckedCreateWithoutTranslationsInput>
  }

  export type ProductCharacteristicUpsertWithoutTranslationsInput = {
    update: XOR<ProductCharacteristicUpdateWithoutTranslationsInput, ProductCharacteristicUncheckedUpdateWithoutTranslationsInput>
    create: XOR<ProductCharacteristicCreateWithoutTranslationsInput, ProductCharacteristicUncheckedCreateWithoutTranslationsInput>
    where?: ProductCharacteristicWhereInput
  }

  export type ProductCharacteristicUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: ProductCharacteristicWhereInput
    data: XOR<ProductCharacteristicUpdateWithoutTranslationsInput, ProductCharacteristicUncheckedUpdateWithoutTranslationsInput>
  }

  export type ProductCharacteristicUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductCharacteristicsNestedInput
    characteristic?: CharacteristicUpdateOneRequiredWithoutProductCharacteristicsNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateWithoutUserInput = {
    id?: string
    isPaid?: boolean
    firstName?: string
    lastName?: string
    phone?: string
    email?: string
    orderNumber?: string
    message?: string
    messagngerType?: string
    messenger?: string
    totalPrice?: number
    orderStatus?: $Enums.OrderTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutUserInput = {
    id?: string
    isPaid?: boolean
    firstName?: string
    lastName?: string
    phone?: string
    email?: string
    orderNumber?: string
    message?: string
    messagngerType?: string
    messenger?: string
    totalPrice?: number
    orderStatus?: $Enums.OrderTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutUserInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderCreateManyUserInputEnvelope = {
    data: OrderCreateManyUserInput | OrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
    create: XOR<OrderCreateWithoutUserInput, OrderUncheckedCreateWithoutUserInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutUserInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutUserInput, OrderUncheckedUpdateWithoutUserInput>
  }

  export type OrderUpdateManyWithWhereWithoutUserInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutUserInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    isPaid?: BoolFilter<"Order"> | boolean
    firstName?: StringFilter<"Order"> | string
    lastName?: StringFilter<"Order"> | string
    phone?: StringFilter<"Order"> | string
    email?: StringFilter<"Order"> | string
    orderNumber?: StringFilter<"Order"> | string
    message?: StringFilter<"Order"> | string
    messagngerType?: StringFilter<"Order"> | string
    messenger?: StringFilter<"Order"> | string
    totalPrice?: IntFilter<"Order"> | number
    orderStatus?: EnumOrderTypesFilter<"Order"> | $Enums.OrderTypes
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    userId?: StringFilter<"Order"> | string
  }

  export type ReviewPhotoCreateWithoutReviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    url: string
  }

  export type ReviewPhotoUncheckedCreateWithoutReviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    url: string
  }

  export type ReviewPhotoCreateOrConnectWithoutReviewInput = {
    where: ReviewPhotoWhereUniqueInput
    create: XOR<ReviewPhotoCreateWithoutReviewInput, ReviewPhotoUncheckedCreateWithoutReviewInput>
  }

  export type ReviewPhotoCreateManyReviewInputEnvelope = {
    data: ReviewPhotoCreateManyReviewInput | ReviewPhotoCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ReviewTranslationCreateWithoutReviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    languageCode: string
  }

  export type ReviewTranslationUncheckedCreateWithoutReviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    languageCode: string
  }

  export type ReviewTranslationCreateOrConnectWithoutReviewInput = {
    where: ReviewTranslationWhereUniqueInput
    create: XOR<ReviewTranslationCreateWithoutReviewInput, ReviewTranslationUncheckedCreateWithoutReviewInput>
  }

  export type ReviewTranslationCreateManyReviewInputEnvelope = {
    data: ReviewTranslationCreateManyReviewInput | ReviewTranslationCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ReviewPhotoUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewPhotoWhereUniqueInput
    update: XOR<ReviewPhotoUpdateWithoutReviewInput, ReviewPhotoUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewPhotoCreateWithoutReviewInput, ReviewPhotoUncheckedCreateWithoutReviewInput>
  }

  export type ReviewPhotoUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewPhotoWhereUniqueInput
    data: XOR<ReviewPhotoUpdateWithoutReviewInput, ReviewPhotoUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewPhotoUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewPhotoScalarWhereInput
    data: XOR<ReviewPhotoUpdateManyMutationInput, ReviewPhotoUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewPhotoScalarWhereInput = {
    AND?: ReviewPhotoScalarWhereInput | ReviewPhotoScalarWhereInput[]
    OR?: ReviewPhotoScalarWhereInput[]
    NOT?: ReviewPhotoScalarWhereInput | ReviewPhotoScalarWhereInput[]
    id?: StringFilter<"ReviewPhoto"> | string
    createdAt?: DateTimeFilter<"ReviewPhoto"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewPhoto"> | Date | string
    url?: StringFilter<"ReviewPhoto"> | string
    reviewId?: StringFilter<"ReviewPhoto"> | string
  }

  export type ReviewTranslationUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewTranslationWhereUniqueInput
    update: XOR<ReviewTranslationUpdateWithoutReviewInput, ReviewTranslationUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewTranslationCreateWithoutReviewInput, ReviewTranslationUncheckedCreateWithoutReviewInput>
  }

  export type ReviewTranslationUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewTranslationWhereUniqueInput
    data: XOR<ReviewTranslationUpdateWithoutReviewInput, ReviewTranslationUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewTranslationUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewTranslationScalarWhereInput
    data: XOR<ReviewTranslationUpdateManyMutationInput, ReviewTranslationUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewTranslationScalarWhereInput = {
    AND?: ReviewTranslationScalarWhereInput | ReviewTranslationScalarWhereInput[]
    OR?: ReviewTranslationScalarWhereInput[]
    NOT?: ReviewTranslationScalarWhereInput | ReviewTranslationScalarWhereInput[]
    id?: StringFilter<"ReviewTranslation"> | string
    createdAt?: DateTimeFilter<"ReviewTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewTranslation"> | Date | string
    desc?: StringFilter<"ReviewTranslation"> | string
    languageCode?: StringFilter<"ReviewTranslation"> | string
    reviewId?: StringFilter<"ReviewTranslation"> | string
  }

  export type ReviewCreateWithoutPhotoInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    avtor: string
    translation?: ReviewTranslationCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutPhotoInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    avtor: string
    translation?: ReviewTranslationUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutPhotoInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutPhotoInput, ReviewUncheckedCreateWithoutPhotoInput>
  }

  export type ReviewUpsertWithoutPhotoInput = {
    update: XOR<ReviewUpdateWithoutPhotoInput, ReviewUncheckedUpdateWithoutPhotoInput>
    create: XOR<ReviewCreateWithoutPhotoInput, ReviewUncheckedCreateWithoutPhotoInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutPhotoInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutPhotoInput, ReviewUncheckedUpdateWithoutPhotoInput>
  }

  export type ReviewUpdateWithoutPhotoInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    avtor?: StringFieldUpdateOperationsInput | string
    translation?: ReviewTranslationUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutPhotoInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    avtor?: StringFieldUpdateOperationsInput | string
    translation?: ReviewTranslationUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateWithoutTranslationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    avtor: string
    photo?: ReviewPhotoCreateNestedManyWithoutReviewInput
  }

  export type ReviewUncheckedCreateWithoutTranslationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    avtor: string
    photo?: ReviewPhotoUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutTranslationInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutTranslationInput, ReviewUncheckedCreateWithoutTranslationInput>
  }

  export type ReviewUpsertWithoutTranslationInput = {
    update: XOR<ReviewUpdateWithoutTranslationInput, ReviewUncheckedUpdateWithoutTranslationInput>
    create: XOR<ReviewCreateWithoutTranslationInput, ReviewUncheckedCreateWithoutTranslationInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutTranslationInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutTranslationInput, ReviewUncheckedUpdateWithoutTranslationInput>
  }

  export type ReviewUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    avtor?: StringFieldUpdateOperationsInput | string
    photo?: ReviewPhotoUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    avtor?: StringFieldUpdateOperationsInput | string
    photo?: ReviewPhotoUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type DeliveryInfoTranslationCreateWithoutDeliveryInfoInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
  }

  export type DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
  }

  export type DeliveryInfoTranslationCreateOrConnectWithoutDeliveryInfoInput = {
    where: DeliveryInfoTranslationWhereUniqueInput
    create: XOR<DeliveryInfoTranslationCreateWithoutDeliveryInfoInput, DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput>
  }

  export type DeliveryInfoTranslationCreateManyDeliveryInfoInputEnvelope = {
    data: DeliveryInfoTranslationCreateManyDeliveryInfoInput | DeliveryInfoTranslationCreateManyDeliveryInfoInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryInfoTranslationUpsertWithWhereUniqueWithoutDeliveryInfoInput = {
    where: DeliveryInfoTranslationWhereUniqueInput
    update: XOR<DeliveryInfoTranslationUpdateWithoutDeliveryInfoInput, DeliveryInfoTranslationUncheckedUpdateWithoutDeliveryInfoInput>
    create: XOR<DeliveryInfoTranslationCreateWithoutDeliveryInfoInput, DeliveryInfoTranslationUncheckedCreateWithoutDeliveryInfoInput>
  }

  export type DeliveryInfoTranslationUpdateWithWhereUniqueWithoutDeliveryInfoInput = {
    where: DeliveryInfoTranslationWhereUniqueInput
    data: XOR<DeliveryInfoTranslationUpdateWithoutDeliveryInfoInput, DeliveryInfoTranslationUncheckedUpdateWithoutDeliveryInfoInput>
  }

  export type DeliveryInfoTranslationUpdateManyWithWhereWithoutDeliveryInfoInput = {
    where: DeliveryInfoTranslationScalarWhereInput
    data: XOR<DeliveryInfoTranslationUpdateManyMutationInput, DeliveryInfoTranslationUncheckedUpdateManyWithoutDeliveryInfoInput>
  }

  export type DeliveryInfoTranslationScalarWhereInput = {
    AND?: DeliveryInfoTranslationScalarWhereInput | DeliveryInfoTranslationScalarWhereInput[]
    OR?: DeliveryInfoTranslationScalarWhereInput[]
    NOT?: DeliveryInfoTranslationScalarWhereInput | DeliveryInfoTranslationScalarWhereInput[]
    id?: StringFilter<"DeliveryInfoTranslation"> | string
    createdAt?: DateTimeFilter<"DeliveryInfoTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"DeliveryInfoTranslation"> | Date | string
    description?: StringFilter<"DeliveryInfoTranslation"> | string
    languageCode?: StringFilter<"DeliveryInfoTranslation"> | string
    deliveryId?: StringFilter<"DeliveryInfoTranslation"> | string
  }

  export type DeliveryInfoCreateWithoutTranslationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type DeliveryInfoUncheckedCreateWithoutTranslationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type DeliveryInfoCreateOrConnectWithoutTranslationInput = {
    where: DeliveryInfoWhereUniqueInput
    create: XOR<DeliveryInfoCreateWithoutTranslationInput, DeliveryInfoUncheckedCreateWithoutTranslationInput>
  }

  export type DeliveryInfoUpsertWithoutTranslationInput = {
    update: XOR<DeliveryInfoUpdateWithoutTranslationInput, DeliveryInfoUncheckedUpdateWithoutTranslationInput>
    create: XOR<DeliveryInfoCreateWithoutTranslationInput, DeliveryInfoUncheckedCreateWithoutTranslationInput>
    where?: DeliveryInfoWhereInput
  }

  export type DeliveryInfoUpdateToOneWithWhereWithoutTranslationInput = {
    where?: DeliveryInfoWhereInput
    data: XOR<DeliveryInfoUpdateWithoutTranslationInput, DeliveryInfoUncheckedUpdateWithoutTranslationInput>
  }

  export type DeliveryInfoUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryInfoUncheckedUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodTranslationCreateWithoutPaymentMethodInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
  }

  export type PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
  }

  export type PaymentMethodTranslationCreateOrConnectWithoutPaymentMethodInput = {
    where: PaymentMethodTranslationWhereUniqueInput
    create: XOR<PaymentMethodTranslationCreateWithoutPaymentMethodInput, PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentMethodTranslationCreateManyPaymentMethodInputEnvelope = {
    data: PaymentMethodTranslationCreateManyPaymentMethodInput | PaymentMethodTranslationCreateManyPaymentMethodInput[]
    skipDuplicates?: boolean
  }

  export type PaymentMethodTranslationUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentMethodTranslationWhereUniqueInput
    update: XOR<PaymentMethodTranslationUpdateWithoutPaymentMethodInput, PaymentMethodTranslationUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<PaymentMethodTranslationCreateWithoutPaymentMethodInput, PaymentMethodTranslationUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentMethodTranslationUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentMethodTranslationWhereUniqueInput
    data: XOR<PaymentMethodTranslationUpdateWithoutPaymentMethodInput, PaymentMethodTranslationUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type PaymentMethodTranslationUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: PaymentMethodTranslationScalarWhereInput
    data: XOR<PaymentMethodTranslationUpdateManyMutationInput, PaymentMethodTranslationUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type PaymentMethodTranslationScalarWhereInput = {
    AND?: PaymentMethodTranslationScalarWhereInput | PaymentMethodTranslationScalarWhereInput[]
    OR?: PaymentMethodTranslationScalarWhereInput[]
    NOT?: PaymentMethodTranslationScalarWhereInput | PaymentMethodTranslationScalarWhereInput[]
    id?: StringFilter<"PaymentMethodTranslation"> | string
    createdAt?: DateTimeFilter<"PaymentMethodTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentMethodTranslation"> | Date | string
    description?: StringFilter<"PaymentMethodTranslation"> | string
    languageCode?: StringFilter<"PaymentMethodTranslation"> | string
    paymentMethodId?: StringFilter<"PaymentMethodTranslation"> | string
  }

  export type PaymentMethodCreateWithoutTranslationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type PaymentMethodUncheckedCreateWithoutTranslationInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
  }

  export type PaymentMethodCreateOrConnectWithoutTranslationInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutTranslationInput, PaymentMethodUncheckedCreateWithoutTranslationInput>
  }

  export type PaymentMethodUpsertWithoutTranslationInput = {
    update: XOR<PaymentMethodUpdateWithoutTranslationInput, PaymentMethodUncheckedUpdateWithoutTranslationInput>
    create: XOR<PaymentMethodCreateWithoutTranslationInput, PaymentMethodUncheckedCreateWithoutTranslationInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutTranslationInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutTranslationInput, PaymentMethodUncheckedUpdateWithoutTranslationInput>
  }

  export type PaymentMethodUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodUncheckedUpdateWithoutTranslationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type FAQTranslationCreateWithoutFaqInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: string
    answer: string
    languageCode: string
  }

  export type FAQTranslationUncheckedCreateWithoutFaqInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: string
    answer: string
    languageCode: string
  }

  export type FAQTranslationCreateOrConnectWithoutFaqInput = {
    where: FAQTranslationWhereUniqueInput
    create: XOR<FAQTranslationCreateWithoutFaqInput, FAQTranslationUncheckedCreateWithoutFaqInput>
  }

  export type FAQTranslationCreateManyFaqInputEnvelope = {
    data: FAQTranslationCreateManyFaqInput | FAQTranslationCreateManyFaqInput[]
    skipDuplicates?: boolean
  }

  export type FAQTranslationUpsertWithWhereUniqueWithoutFaqInput = {
    where: FAQTranslationWhereUniqueInput
    update: XOR<FAQTranslationUpdateWithoutFaqInput, FAQTranslationUncheckedUpdateWithoutFaqInput>
    create: XOR<FAQTranslationCreateWithoutFaqInput, FAQTranslationUncheckedCreateWithoutFaqInput>
  }

  export type FAQTranslationUpdateWithWhereUniqueWithoutFaqInput = {
    where: FAQTranslationWhereUniqueInput
    data: XOR<FAQTranslationUpdateWithoutFaqInput, FAQTranslationUncheckedUpdateWithoutFaqInput>
  }

  export type FAQTranslationUpdateManyWithWhereWithoutFaqInput = {
    where: FAQTranslationScalarWhereInput
    data: XOR<FAQTranslationUpdateManyMutationInput, FAQTranslationUncheckedUpdateManyWithoutFaqInput>
  }

  export type FAQTranslationScalarWhereInput = {
    AND?: FAQTranslationScalarWhereInput | FAQTranslationScalarWhereInput[]
    OR?: FAQTranslationScalarWhereInput[]
    NOT?: FAQTranslationScalarWhereInput | FAQTranslationScalarWhereInput[]
    id?: StringFilter<"FAQTranslation"> | string
    createdAt?: DateTimeFilter<"FAQTranslation"> | Date | string
    updatedAt?: DateTimeFilter<"FAQTranslation"> | Date | string
    question?: StringFilter<"FAQTranslation"> | string
    answer?: StringFilter<"FAQTranslation"> | string
    languageCode?: StringFilter<"FAQTranslation"> | string
    faqId?: StringFilter<"FAQTranslation"> | string
  }

  export type FAQCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    question: string
    answer: string
  }

  export type FAQUncheckedCreateWithoutTranslationsInput = {
    id?: string
    createdAt?: Date | string
    updateAt?: Date | string
    question: string
    answer: string
  }

  export type FAQCreateOrConnectWithoutTranslationsInput = {
    where: FAQWhereUniqueInput
    create: XOR<FAQCreateWithoutTranslationsInput, FAQUncheckedCreateWithoutTranslationsInput>
  }

  export type FAQUpsertWithoutTranslationsInput = {
    update: XOR<FAQUpdateWithoutTranslationsInput, FAQUncheckedUpdateWithoutTranslationsInput>
    create: XOR<FAQCreateWithoutTranslationsInput, FAQUncheckedCreateWithoutTranslationsInput>
    where?: FAQWhereInput
  }

  export type FAQUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: FAQWhereInput
    data: XOR<FAQUpdateWithoutTranslationsInput, FAQUncheckedUpdateWithoutTranslationsInput>
  }

  export type FAQUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type FAQUncheckedUpdateWithoutTranslationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type HeroBillboardsTranslationCreateManyHeroBillboardInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title?: string
    langCode: string
    subtitle?: string
  }

  export type HeroBillboardsTranslationUpdateWithoutHeroBillboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    langCode?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
  }

  export type HeroBillboardsTranslationUncheckedUpdateWithoutHeroBillboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    langCode?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
  }

  export type HeroBillboardsTranslationUncheckedUpdateManyWithoutHeroBillboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    langCode?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateManyBillboardInput = {
    id?: string
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    maxPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type CategoryUpdateWithoutBillboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryUpdateManyWithoutCategoryNestedInput
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutBillboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutBillboardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductCategoryCreateManyCategoryInput = {
    id?: string
    productId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateManyParentInput = {
    id?: string
    billboardId?: string | null
    name: string
    type?: $Enums.TypeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    maxPrice?: Decimal | DecimalJsLike | number | string | null
  }

  export type ProductCategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    billboard?: BillboardUpdateOneWithoutCategoriesNestedInput
    products?: ProductCategoryUpdateManyWithoutCategoryNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billboardId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    products?: ProductCategoryUncheckedUpdateManyWithoutCategoryNestedInput
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    billboardId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeCategoryFieldUpdateOperationsInput | $Enums.TypeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maxPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductCategoryCreateManyProductInput = {
    id?: string
    categoryId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImageCreateManyProductInput = {
    id?: string
    url: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderId: string
    price?: string
    quantity?: number
  }

  export type ProductCharacteristicCreateManyProductInput = {
    id?: string
    characteristicId: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ProductTranslationCreateManyProductInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    title: string
    description: string
  }

  export type ProductCategoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductCategoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCategoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderId?: StringFieldUpdateOperationsInput | string
    price?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCharacteristicUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characteristic?: CharacteristicUpdateOneRequiredWithoutProductCharacteristicsNestedInput
    translations?: ProductCharacteristicTranslationUpdateManyWithoutProductCharacteristicNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ProductCharacteristicTranslationUncheckedUpdateManyWithoutProductCharacteristicNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    characteristicId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTranslationUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTranslationUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    price?: string
    productId: string
    quantity?: number
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCharacteristicCreateManyCharacteristicInput = {
    id?: string
    productId: string
    name: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type CharacteristicTranslationCreateManyCharacteristicInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    languageCode: string
    name: string
  }

  export type ProductCharacteristicUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutProductCharacteristicsNestedInput
    translations?: ProductCharacteristicTranslationUpdateManyWithoutProductCharacteristicNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: ProductCharacteristicTranslationUncheckedUpdateManyWithoutProductCharacteristicNestedInput
  }

  export type ProductCharacteristicUncheckedUpdateManyWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacteristicTranslationUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicTranslationUncheckedUpdateWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CharacteristicTranslationUncheckedUpdateManyWithoutCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCharacteristicTranslationCreateManyProductCharacteristicInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    languageCode: string
    description: string
  }

  export type ProductCharacteristicTranslationUpdateWithoutProductCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCharacteristicTranslationUncheckedUpdateWithoutProductCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type ProductCharacteristicTranslationUncheckedUpdateManyWithoutProductCharacteristicInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    languageCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type OrderCreateManyUserInput = {
    id?: string
    isPaid?: boolean
    firstName?: string
    lastName?: string
    phone?: string
    email?: string
    orderNumber?: string
    message?: string
    messagngerType?: string
    messenger?: string
    totalPrice?: number
    orderStatus?: $Enums.OrderTypes
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderStatus?: EnumOrderTypesFieldUpdateOperationsInput | $Enums.OrderTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderStatus?: EnumOrderTypesFieldUpdateOperationsInput | $Enums.OrderTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    messagngerType?: StringFieldUpdateOperationsInput | string
    messenger?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    orderStatus?: EnumOrderTypesFieldUpdateOperationsInput | $Enums.OrderTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewPhotoCreateManyReviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    url: string
  }

  export type ReviewTranslationCreateManyReviewInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    desc: string
    languageCode: string
  }

  export type ReviewPhotoUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewPhotoUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewPhotoUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewTranslationUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewTranslationUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewTranslationUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryInfoTranslationCreateManyDeliveryInfoInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
  }

  export type DeliveryInfoTranslationUpdateWithoutDeliveryInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryInfoTranslationUncheckedUpdateWithoutDeliveryInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryInfoTranslationUncheckedUpdateManyWithoutDeliveryInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodTranslationCreateManyPaymentMethodInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    languageCode: string
  }

  export type PaymentMethodTranslationUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodTranslationUncheckedUpdateWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodTranslationUncheckedUpdateManyWithoutPaymentMethodInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type FAQTranslationCreateManyFaqInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: string
    answer: string
    languageCode: string
  }

  export type FAQTranslationUpdateWithoutFaqInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type FAQTranslationUncheckedUpdateWithoutFaqInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }

  export type FAQTranslationUncheckedUpdateManyWithoutFaqInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}